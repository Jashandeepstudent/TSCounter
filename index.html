
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Writer App — Slots UI Improved (fixed v2)</title>
  <style>
    :root{ --bg:#f9fafb;--accent:#4f46e5;--muted:#6b7280; --shadow:0 4px 14px rgba(0,0,0,0.08);--border:#e5e7eb; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter, system-ui, -apple-system, Arial,sans-serif;background:var(--bg);color:#111827;font-size:16px;line-height:1.45;}
    h1,h2{margin:16px 0;text-align:center}
    button,input,select,textarea{font-family:inherit;font-size:14px}
    .btn{padding:14px 20px;border:none;border-radius:14px;cursor:pointer;font-weight:700;transition:0.18s;box-shadow:0 8px 24px rgba(79,70,229,0.12)}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-secondary{background:#e5e7eb;color:#111;border:1px solid #d1d5db}
    .btn:hover{opacity:0.95;transform:translateY(-1px)}
    .hidden{display:none!important}

.story-analytics-modal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.45);
  z-index: 9999;
  padding: 20px;
  box-sizing: border-box;
}
.story-analytics-card {
  width: min(980px, 96%);
  max-height: 90vh;
  overflow: auto;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.25);
  padding: 18px;
  box-sizing: border-box;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}
.analytics-header {
  display:flex;
  gap:12px;
  align-items:center;
  justify-content:space-between;
  margin-bottom:12px;
  flex-wrap:wrap;
}
.analytics-title { font-size:20px; font-weight:700; }
.analytics-summary {
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}
.summary-pill {
  padding:8px 12px;
  border-radius:10px;
  background:#f3f4f6;
  font-weight:600;
}
.status-pill {
  padding:8px 12px;
  border-radius:10px;
  font-weight:700;
  display:inline-block;
}
.analytics-body { margin-top:8px; }
.canvas-wrap { width:100%; height:360px; background:#fff; border-radius:8px; padding:10px; box-sizing:border-box; }
.legend { margin-top:8px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
.legend-item { display:flex; gap:6px; align-items:center; font-size:13px; }
.legend-swatch { width:14px; height:6px; border-radius:2px; display:inline-block; }
.close-analytics {
  background:transparent;
  border:0;
  font-size:18px;
  cursor:pointer;
}
.small-note { color:#6b7280; font-size:13px; margin-top:8px; }

    /* Header */
    header{position:fixed;top:12px;left:12px;z-index:60}
    .profile-btn{width:56px;height:56px;border-radius:50%;background:white; box-shadow:0 10px 30px rgba(0,0,0,0.12); display:flex;align-items:center;justify-content:center; border:none;cursor:pointer;overflow:hidden;font-size:16px}
    .profile-initials{font-weight:700;color:var(--accent);font-size:16px}
    .dropdown{position:absolute;background:white;border:1px solid var(--border);border-radius:10px; box-shadow:0 4px 14px rgba(0,0,0,0.08);padding:8px;display:none;flex-direction:column; min-width:220px;z-index:55}
    .dropdown button{background:transparent;border:none;padding:10px;border-radius:8px;text-align:left;cursor:pointer;font-size:15px}
    .dropdown button:hover{background:#f3f4f6}

    /* Main */
    main{display:flex;flex-direction:column;align-items:center;justify-content:center; height:100vh;text-align:center;padding:20px}
    .buttons{display:flex;flex-direction:column;gap:12px;align-items:center}
    .btn-small{padding:10px 16px;font-size:16px;border-radius:12px}

.jelly-btn {
  background-color: white;
  color: #333; /* dark text */
  font-weight: bold;
  padding: 10px 25px;
  border: 2px solid #ccc;
  border-radius: 50px;
  cursor: pointer;
  font-size: 16px;
  position: relative;
  overflow: hidden;
  outline: none;
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
}

.jelly-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 8px 15px rgba(0,0,0,0.2);
  border-color: #888;
}

.jelly-btn:active {
  animation: jelly 0.6s;
}

/* Wobble animation */
@keyframes jelly {
  0% { transform: scale(1, 1); }
  25% { transform: scale(1.2, 0.8); }
  50% { transform: scale(0.8, 1.2); }
  75% { transform: scale(1.1, 0.9); }
  100% { transform: scale(1, 1); }
}

    /* Form */
    .form-container{max-width:680px;margin:40px auto;padding:24px;background:#fff;border-radius:12px;box-shadow:var(--shadow)}
    label{display:block;margin:8px 0 4px;font-weight:600;color:var(--muted)}
    input,select,textarea{width:100%;padding:10px;border:1px solid var(--border);border-radius:8px;margin-bottom:12px}
    .genres-container{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;margin-bottom:16px}
    .genre-option{padding:8px 14px;border:1px solid var(--border);border-radius:20px;cursor:pointer; background:#f9fafb;transition:0.2s}
    .genre-option.active{background:var(--accent);color:#fff;border-color:var(--accent)}

    /* Dashboard */
    #dashboardPage{padding:24px;min-height:100vh}
    .dashboard-header{display:flex;flex-direction:column;align-items:center;margin-bottom:20px;gap:12px;text-align:center}
    .dashboard-card{padding:16px;background:#fff;margin-bottom:12px;border-radius:12px;box-shadow:var(--shadow);display:flex;justify-content:space-between;gap:8px;align-items:center}
    .dashboard-card .meta{color:var(--muted);font-size:13px;margin-top:6px}
    .dashboard-card h3{margin:0;font-size:18px}
    .dashboard-card p{margin:6px 0;color:#111827}
    .dashboard-card .desc{color:#374151}
    .status-public{color:green;font-weight:700}
    .status-draft{color:#b45309;font-weight:700}
    .card-actions{display:flex;gap:8px;align-items:center}
    .small-btn{padding:6px 10px;border-radius:8px;font-weight:600}

    /* Editor Page */
    #editorPage{position:fixed;inset:0;background:var(--bg);z-index:100;display:flex;flex-direction:column;padding:18px;gap:12px}
    .sheets-bar{display:flex;gap:8px;overflow-x:auto;padding-bottom:8px}
    .sheet-thumb{position:relative;min-width:180px;min-height:80px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:12px;font-size:14px;box-shadow:0 6px 18px rgba(0,0,0,0.08);cursor:pointer;white-space:pre-wrap;overflow:hidden;text-overflow:ellipsis}
    .sheet-thumb.active{border:2px solid var(--accent)}
    .sheet-thumb .del{position:absolute;top:6px;right:6px;background:transparent;border:none;font-size:12px;cursor:pointer;padding:4px;border-radius:4px}
    .add-sheet-btn{min-width:40px;min-height:60px;border:1px dashed var(--accent);border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:bold;color:var(--accent);cursor:pointer;flex-shrink:0}
    .sheet-textarea{flex:1;padding:18px;border:1px solid var(--border);border-radius:12px;font-size:16px;resize:none;min-height:320px}
    .editor-actions{display:flex;gap:12px;justify-content:flex-end;margin-top:8px}

    /* Slots Page */
    #slotsContainer{display:flex;gap:24px;flex-wrap:wrap;justify-content:center;padding:16px}
    .slot-card{width:260px;height:220px;background:#fff;border-radius:20px;display:flex;align-items:center;justify-content:center;flex-direction:column;cursor:pointer;position:relative;box-shadow:0 14px 40px rgba(0,0,0,0.14);font-size:18px;text-align:center;transition:all 0.22s;padding:16px}
    .slot-card:hover{transform:translateY(-4px);box-shadow:0 10px 24px rgba(0,0,0,0.15)}
    .slot-card.locked{background:#f3f4f6;color:#111827;font-weight:600}
    .slot-card.locked::before{content:"🔒";font-size:24px;position:absolute;top:8px;right:8px}
    .slot-card .slot-title{font-weight:700;margin-bottom:6px}
    .slot-card .slot-meta{font-size:13px;color:var(--muted)}

    /* Popups */
    .popup { position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);z-index:300}
    .popup .popup-content{background:#fff;padding:20px;border-radius:12px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.15);max-width:520px;width:92%}
    .popup input{width:100%;padding:10px;margin-bottom:12px;border:1px solid var(--border);border-radius:8px;font-size:16px}

    /* Back button (left bottom) */
    .back-btn{position:fixed;left:18px;bottom:18px;background:#fff;color:#111;padding:10px 14px;border-radius:12px;border:1px solid var(--border);cursor:pointer;font-weight:700;box-shadow:0 8px 30px rgba(0,0,0,0.12)}
    .back-btn .icon{margin-right:8px}

    /* small helpers */
    .row{display:flex;gap:12px;align-items:center;justify-content:center}
    .muted{color:var(--muted)}
  
    
    /* Smaller and mobile-friendly categories */
    #categoriesPage, #serialCategoriesPage {padding:20px;min-height:100vh;display:flex;flex-direction:column;align-items:center;gap:14px;background:var(--bg)}
    .categories-header{max-width:800px;width:100%;text-align:center}
    .categories-grid{display:flex;gap:10px;flex-wrap:nowrap;overflow-x:auto;padding:8px 4px;width:100%;justify-content:center}
    .cat-card{flex:0 0 auto;padding:12px 18px;border-radius:14px;background:#fff;box-shadow:var(--shadow);min-width:110px;text-align:center;cursor:pointer;border:1px solid var(--border);transition:transform .15s, box-shadow .15s}
    .cat-card .cat-title{font-weight:700;margin-bottom:4px;font-size:14px}
    .cat-card .cat-sub{font-size:12px;color:var(--muted)}
    .cat-card:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,0.08)}
    .cat-card.active{background:linear-gradient(135deg,var(--accent),#7c3aed);color:#fff;border-color:transparent;box-shadow:0 14px 35px rgba(79,70,229,0.18)}
    .categories-grid::-webkit-scrollbar{height:6px}
    .categories-grid::-webkit-scrollbar-thumb{background:#d1d5db;border-radius:6px}
    #categoriesBackBtn, #serialCategoriesBackBtn{position:fixed;left:14px;bottom:14px}

#previewFull {
  position: fixed !important;
  inset: 0 !important;
  z-index: 99999 !important;
  display: block !important;
}
#previewFull.hidden {
  display: none !important;
}
5:00 PM 10/27/2025

    /* full-width story cards */
   #storiesCards {
  display: flex;
  flex-direction: column;
  gap: 32px;
  width: 100%;
  align-items: center;
}

.story-card {
  width: 280px;
  height: 420px;
  background: linear-gradient(180deg, #fdf6f0, #e0d8c0);
  border-radius: 14px;
  padding: 24px;
  color: #0f172a;
  box-shadow: 0 10px 25px rgba(0,0,0,0.25);
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  position: relative;
  font-family: 'Georgia', serif;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.story-card:hover {
  transform: translateY(-5px) scale(1.02);
  box-shadow: 0 15px 30px rgba(0,0,0,0.3);
}

.story-card::before {
  content: "";
  position: absolute;
  inset: 0;
  background: url('your-cover-image.jpg') center/cover no-repeat;
  opacity: 0.15;
  pointer-events: none;
}

.story-card h2 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.story-card p {
  margin: 4px 0 0;
  font-size: 1rem;
  font-style: italic;
  text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
}

.story-card .read-btn,
.story-card .view-serial-btn {
  margin-top: 12px;
  padding: 8px 16px;
  border: none;
  background: #1e40af;
  color: #fff;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.2s ease;
}

.story-card .read-btn:hover,
.story-card .view-serial-btn:hover {
  background: #1e3a8a;
}
.scroll-wrap {
  display: flex;
  overflow-x: auto;
  gap: 12px;
  padding: 12px;
  scroll-behavior: smooth;
  flex-wrap: nowrap;
  position: relative; /* important for overlay effect */
}

    /* Fullscreen preview */
    .fullscreen-panel{position:fixed;inset:0;background:var(--bg);z-index:800;display:flex;flex-direction:column;padding:22px;overflow:auto}
    .fullscreen-panel .panel-inner{max-width:1100px;margin:12px auto;display:flex;flex-direction:column;gap:12px}
    .panel-top{display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
    .panel-meta{color:var(--muted)}
    /* Fullscreen reader */
    .reader-full{position:fixed;inset:0;background:#ffffff;z-index:900;display:flex;flex-direction:column;padding:18px;overflow:auto}
    .reader-header{display:flex;justify-content:space-between;align-items:center}
    .reader-body{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center;padding:12px}
    .reader-sheet{width:100%;max-width:980px;border-radius:10px;padding:18px;min-height:240px;font-size:18px;line-height:1.6;background:linear-gradient(180deg,#fff,#fbfbff);box-shadow:0 12px 40px rgba(0,0,0,0.06)}


/* Added tweaks for murbal: ensure story cards use full-color gradient and fixed height */
.story-card{ color:#0f172a; border-radius:12px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,0.08); min-height:180px; display:flex; flex-direction:column; justify-content:space-between; }
.story-card h4{ margin:0; font-size:18px; font-weight:700; }
.story-card p{ margin:0; }

</style>
</head>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
import { getDatabase, ref, set, get, child, onValue } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyCgTh6FzKWYCGyRgBmeclvGKxuuFL3L81Y",
  authDomain: "meurbal.firebaseapp.com",
  databaseURL: "https://meurbal-default-rtdb.firebaseio.com",
  projectId: "meurbal",
  storageBucket: "meurbal.firebasestorage.app",
  messagingSenderId: "917148598257",
  appId: "1:917148598257:web:dd42e5d690b56d2ac08e50",
  measurementId: "G-EHJVB3XC90"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const statusBox = document.createElement('div');
statusBox.id = '__firebase_status_box';
statusBox.textContent = '🟡 Firebase: Connecting...';
statusBox.style.cssText = 'position:fixed;right:12px;bottom:12px;padding:8px 12px;border-radius:10px;background:#fff;font-weight:700;box-shadow:0 8px 30px rgba(0,0,0,0.12);z-index:99999';
document.addEventListener('DOMContentLoaded', ()=> document.body.appendChild(statusBox));
function setStatus(text,color){try{statusBox.textContent=text;if(color)statusBox.style.background=color;}catch(e){}}
get(ref(db,'/')).then(()=>setStatus('🟢 Firebase: Connected','#dcfce7')).catch(()=>setStatus('🔴 Firebase: Offline','#fee2e2'));

window._firebase={app,db,ref,set,get,child};

function saveLocal(k,d){localStorage.setItem(k,JSON.stringify(d));}
function loadLocal(k){try{return JSON.parse(localStorage.getItem(k))||[]}catch{return [];}}

window.storiesData=loadLocal('storiesData');
window.serialsData=loadLocal('serialsData');
window.serialSlots = loadLocal('serialSlots') || []; // ✅ Load serial slots locally

function renderStoriesList(stories){
 const list=document.getElementById('storiesCards');if(!list)return;
 list.innerHTML='';
 stories.forEach(s=>{const c=document.createElement('div');c.className='story-card';c.innerHTML=`<h2>${s.title}</h2><p>${s.genre||''}</p>`;list.appendChild(c);});
}
function renderSerialsList(serials) {
  const list = document.getElementById('serialsCards');
  if (!list) return;
  list.innerHTML = '';

  serials.forEach(s => {
    const c = document.createElement('div');
    c.className = 'story-card';
    c.innerHTML = `
      <h2>${s.title}</h2>
      <p>${s.genre || ''}</p>
      <button class="view-serial-btn">View Serial</button>
    `;

    c.querySelector('.view-serial-btn').addEventListener('click', async () => {
      const titleKey = s.title.trim();
      console.log('🎬 View Serial clicked:', titleKey);

      try {
        const allSnap = await get(ref(window._firebase.db, 'serials'));
        if (!allSnap.exists()) {
          alert('No serials found in Firebase.');
          return;
        }

        const allSerials = allSnap.val();
        let data = null;
let foundKey = null;

// Try exact key match first
if (allSerials[titleKey]) {
  data = allSerials[titleKey];
  foundKey = titleKey;
} else {
  // Otherwise, scan all serials by title field
  for (const [key, obj] of Object.entries(allSerials)) {
    if ((obj.title || '').trim().toLowerCase() === titleKey.toLowerCase()) {
      data = obj;
      foundKey = key;
      break;
    }
  }
}

if (data) {
          console.log(`✅ Found serial "${titleKey}" under key "${foundKey}"`);
          openSerialPreview(data);
        } else {
          console.warn(`⚠️ Serial "${titleKey}" not found in Firebase.`);
          alert(`Serial "${titleKey}" not found!`);
        }

      } catch (err) {
        console.error('❌ Error fetching serial from Firebase:', err);
        alert('Error fetching serial. Check your network connection.');
      }
    });

    list.appendChild(c);
  });
}


function openSerialPreview(serialData) {
  const preview = document.getElementById('previewFull');
  preview.innerHTML = `
    <div class="fullscreen-panel">
      <div class="panel-inner">
        <div class="panel-top">
          <h2>${serialData.title}</h2>
          <button class="btn btn-secondary" id="closePreviewBtn">Close</button>
        </div>
        <div class="panel-meta">
          Genre: ${serialData.genre || 'N/A'} • Episodes: ${serialData.episodes?.length || 0}
        </div>
        <div class="episodes-list">
          ${(serialData.episodes || []).map((ep, i) => `
            <div class="dashboard-card">
              <h3>${ep.title}</h3>
              <p>${ep.description || ''}</p>
            </div>
          `).join('')}
        </div>
      </div>
    </div>
  `;
  preview.classList.remove('hidden');
  document.getElementById('closePreviewBtn').addEventListener('click', () => {
    preview.classList.add('hidden');
  });
}

// ---------- STORIES + SERIALS LOAD FROM FIREBASE ----------

let _storiesRendered = false;

onValue(ref(db, 'stories'), snap => {
  if (snap.exists()) {
    const obj = snap.val();
    window.storiesData = Object.values(obj);
    if (!_storiesRendered) {
      _storiesRendered = true;
    }
  } else {
    window.storiesData = [];
    saveLocal('storiesData', []);
  }
});

onValue(ref(db, 'serials'), snap => {
  if (snap.exists()) {
    const obj = snap.val();
    window.serialsData = Object.values(obj);
    saveLocal('serialsData', window.serialsData);

    console.log(`🔥 Firebase delivered ${window.serialsData.length} serials`);

    // ✅ Update both list and browse views
    if (typeof renderSerialsList === 'function') {
      renderSerialsList(window.serialsData);
    }
    if (typeof renderBrowseSerials === 'function') {
      renderBrowseSerials(window.serialsData, { mergeWithSaved: false });
    }

  } else {
    window.serialsData = [];
    saveLocal('serialsData', []);
    if (typeof renderBrowseSerials === 'function') {
      renderBrowseSerials([], { includeDemo: true, demoCount: 10 });
    }
  }
});

// ---------- OPTIONAL: UPDATE YOUR SAVE CALLS TOO ----------
// Everywhere you have a serial save call like this:
// await set(ref(db, `serials/${encodeURIComponent(ser.title)}`), ser);

// Replace with this:
async function saveSerialToFirebase(ser) {
  try {
    await set(ref(window._firebase.db, `serials/${ser.title}`), ser);
    console.log(`✅ Serial "${ser.title}" saved successfully to Firebase.`);
  } catch (err) {
    console.error('❌ Error saving serial to Firebase:', err);
  }
}

</script>



<body>
  <header>
    <button class="profile-btn" id="profileBtn"><span class="profile-initials">??</span></button>
    <div class="dropdown" id="profileDropdown"></div>
  </header>

  <main id="welcomePage">
    <h1>Welcome!</h1>
    <div class="buttons">
      <button id="browseStoriesBtn" class="btn btn-primary btn-small">📖 Browse Stories</button>
      <button id="browseSerialsBtn" class="btn btn-secondary btn-small">🎬 Browse Serials</button>
      <button id="createContentBtn" class="btn btn-primary btn-small">✍️ Create Story / Serial</button>
    </div>
  </main>


  <!-- Categories Page (opened from Browse Stories) -->
  <div id="categoriesPage" class="hidden">
    <button class="back-btn" id="categoriesBackBtn">← Back</button>
    <div class="categories-header">
      <h2>Browse Stories</h2>
    </div>
    <div style="max-width:980px;margin:8px auto 0;display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div style="flex:1">
        <input id="storiesSearchInput" placeholder="Search your stories..." style="width:100%;padding:10px;border:1px solid var(--border);border-radius:8px" />
      </div>
      <div style="min-width:140px;text-align:right">
        <button id="storiesClearSearchBtn" class="btn btn-secondary" style="padding:8px 10px">Clear</button>
      </div>
    </div>

    <div class="categories-grid" id="categoriesGrid" aria-label="story categories">
      <!-- Stories list shown after selecting a category -->
      </div>
      <div id="storiesBrowseList" style="max-width:980px;margin:18px auto;display:none">
        <h3 style="text-align:left;margin:6px 12px">Stories</h3>
        <div id="storiesCards" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:12px"></div>
      </div>
      <!-- Fullscreen Preview & Reader Containers -->
  


      <div id="readerModal" class="hidden popup">
        <div class="popup-content" style="width:90%;max-width:900px;padding:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <h3 id="readerTitle">Story</h3>
              <div class="muted" id="readerMeta"></div>
            </div>
            <div style="display:flex;gap:8px">
              <button id="readerDownloadBtn" class="btn btn-secondary">Download Story</button>
              <button id="readerLikeBtn" class="btn btn-secondary">👍 Like <span id="readerLikeCount">0</span></button>
              <button id="readerDislikeBtn" class="btn btn-secondary">👎 Dislike <span id="readerDislikeCount">0</span></button>
              <button id="readerCloseBtn" class="btn btn-secondary">Close</button>
            </div>
          </div>
          <div id="readerContent" style="min-height:260px;padding:12px;margin-top:12px;border-radius:8px;background:#fff;overflow:hidden;position:relative">
            <div id="readerSheet" style="min-height:200px"></div>
          </div>
          <div style="display:flex;justify-content:center;gap:12px;margin-top:12px">
            <button id="readerPrevBtn" class="btn btn-secondary">◀ Prev</button>
            <span id="readerPager" class="muted"></span>
            <button id="readerNextBtn" class="btn btn-primary">Next ▶</button>
          </div>
        </div>
      </div>

      <!-- cards injected by JS -->
    </div>
  </div>

  
  <!-- Serials Categories Page -->
  <div id="serialCategoriesPage" class="hidden">
    <button class="back-btn" id="serialCategoriesBackBtn">← Back</button>
    <div class="categories-header">
      <h2>Browse Serial Categories</h2>
      <div style="max-width:980px;margin:8px auto 0;display:flex;gap:8px;align-items:center;justify-content:space-between">
        <div style="flex:1">
          <input id="serialsSearchInput" placeholder="Search your serials..." style="width:100%;padding:10px;border:1px solid var(--border);border-radius:8px" />
        </div>
        <div style="min-width:140px;text-align:right">
          <button id="serialsClearSearchBtn" class="btn btn-secondary" style="padding:8px 10px">Clear</button>
        </div>
      </div>
      <div id="serialSearchResults" style="max-width:980px;margin:12px auto;display:none">
        <div id="serialsCards" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:12px"></div>
      </div>

      <p class="muted" style="margin:6px 0 12px">Choose a genre to explore serials. Swipe or scroll horizontally to see all categories.</p>
    </div>
    <div class="categories-grid" id="serialCategoriesGrid" aria-label="serial categories">
      <!-- serial cards injected by JS -->
    </div>
  </div>

  <!-- Profile Form -->
  <div id="profileFormPage" class="form-container hidden">
    <h2>Create Writer Profile</h2>
    <label>Name</label><input type="text" id="profileName">
    <label>Age</label><input type="number" id="profileAge">
    <label>Country</label><input type="text" id="profileCountry">
    <label>Favourite Genres</label>
    <div class="genres-container" id="genresContainer">
      <label class="genre-option"><input type="checkbox" value="Horror">Horror</label>
      <label class="genre-option"><input type="checkbox" value="Comedy">Comedy</label>
      <label class="genre-option"><input type="checkbox" value="Action">Action</label>
      <label class="genre-option"><input type="checkbox" value="Tragic">Tragic</label>
      <label class="genre-option"><input type="checkbox" value="Romance">Romance</label>
      <label class="genre-option"><input type="checkbox" value="Fantasy">Fantasy</label>
      <label class="genre-option"><input type="checkbox" value="Thriller">Thriller</label>
         <label class="genre-option"><input type="checkbox" value="Adventure">Adventure</label>
      <label class="genre-option"><input type="checkbox" value="Crime">Crime</label>
      <label class="genre-option"><input type="checkbox" value="Historic">Historic</label>
    </div>
    <button class="btn btn-primary" id="saveProfileBtn">Create Profile</button>
  </div>

  <!-- Choose Type Popup -->
  <div id="chooseTypePopup" class="hidden popup">
    <div class="popup-content">
      <h2>What do you want to create?</h2>
      <div style="display:flex;gap:12px;justify-content:center;margin-top:12px">
        <button id="createStoryBtn" class="btn btn-primary">Story</button>
        <button id="createSerialBtn" class="btn btn-secondary">Serial</button>
      </div>
    </div>
  </div>

  <!-- Slot Name / Unlock Popup -->
  <div id="slotNamePopup" class="hidden popup">
    <div class="popup-content">
      <h3>Name this slot</h3>
      <input id="slotNameInput" placeholder='Slot name (e.g. "My Fantasy Series")'>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
        <button id="slotNameCancelBtn" class="btn btn-secondary">Cancel</button>
        <button id="slotNameUnlockBtn" class="btn btn-primary">Unlock Slot</button>
      </div>
    </div>
  </div>

  <!-- Serial Create Popup (series + episode1) -->
 <div id="serialCreatePopup" class="hidden popup">
  <div class="popup-content" style="max-width:480px;padding:16px;">
    <h3 style="margin-bottom:8px;">Create / Edit Serial</h3>

    <!-- Series Section -->
    <div style="margin-bottom:8px;">
      <label style="font-weight:600;">Series Title</label>
      <input id="seriesTitleInput" placeholder="e.g. The Lost Scrolls" style="margin-bottom:6px;">
      <label>Genre</label>
      <select id="seriesGenreInput" style="margin-bottom:6px;">
        <option value="">Select genre</option>
        <option>Comedy</option>
        <option>Fantasy</option>
        <option>Horror</option>
        <option>Romance</option>
        <option>Action</option>
        <option>Tragic</option>
        <option>Thriller</option>
        <option>Adventure</option>
        <option>Crime</option>
        <option>Historic</option>
      </select>
      <label>Description (optional)</label>
      <textarea id="seriesDescInput" rows="2" placeholder="Short series description" style="margin-bottom:6px;"></textarea>
    </div>

    <!-- Tags -->
    <div style="margin-bottom:10px;">
      <label>Tags</label>
      <div style="display:flex;gap:6px;align-items:center;margin-top:4px;margin-bottom:6px;">
        <input id="seriesTagInput" placeholder="type a tag" style="flex:1;padding:8px;border-radius:6px;border:1px solid var(--border)">
        <button id="addSeriesTagBtn" class="btn btn-secondary" type="button" style="padding:6px 10px;">Add</button>
      </div>
      <div id="seriesTagsContainer" style="display:flex;flex-wrap:wrap;gap:6px;"></div>
    </div>

    <hr style="margin:10px 0;opacity:0.5;">

    <!-- Episode Section -->
    <div style="margin-bottom:8px;">
      <label style="font-weight:600;">Episode 1</label>
      <input id="ep1TitleInput" placeholder="Episode 1 title" style="margin-bottom:6px;">
      <textarea id="ep1DescInput" rows="2" placeholder="Short episode description" style="margin-bottom:6px;"></textarea>

      <!-- Cover -->
      <label>Series Cover</label>
      <input type="file" id="serialCoverInput" accept="image/*">
      <div id="serialCoverPreview" style="margin-top:6px;text-align:center;">
        <img id="serialCoverImg" src="" alt="Cover Preview"
          style="max-width:100px;height:180px;object-fit:cover;border-radius:8px;display:none;">
      </div>
    </div>

    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
      <button id="serialCreateCancelBtn" class="btn btn-secondary" style="padding:6px 12px;">Cancel</button>
      <button id="serialCreateConfirmBtn" class="btn btn-primary" style="padding:6px 12px;">Create / Update</button>
    </div>
  </div>
</div>


  <!-- Add Episode Popup -->
  <div id="addEpisodePopup" class="hidden popup">
    <div class="popup-content">
      <h3>Add Episode</h3>
      <label>Episode Title</label>
      <input id="addEpTitleInput" placeholder="Episode title">
      <label>Episode Description (optional)</label>
      <textarea id="addEpDescInput" rows="2" placeholder="Episode description"></textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="addEpCancelBtn" class="btn btn-secondary">Cancel</button>
        <button id="addEpConfirmBtn" class="btn btn-primary">Add Episode</button>
      </div>
    </div>
  </div>

  <!-- Slots Page -->
  <div id="slidesPage" class="hidden">
    <button class="back-btn" id="slotsBackBtn">← Back</button>
    <h2 style="text-align:center;margin-top:30px">Select a Slot</h2>
    <div id="slotsContainer"></div>
  </div>

  <!-- Story Form -->
  <div id="storyFormPage" class="form-container hidden">
    <h2>Create Story / Serial</h2>
    <label>Title</label><input type="text" id="storyTitle">
    <label>Genre</label>
    <select id="storyGenre">
      <option value="">Select genre</option>
      <option>Horror</option><option>Comedy</option><option>Action</option>
      <option>Romance</option><option>Tragic</option><option>Fantasy</option>
      <option>Thriller</option><option>Adventure</option><option>Crime</option>
       <option>Historic</option>
    </select>
    <label>Description</label>
    <textarea id="storyDesc" rows="3"></textarea>
    <label>Cover Image</label>
<input type="file" id="storyCoverInput" accept="image/*">

    <div id="storyCoverPreview" style="margin-top:10px;text-align:center;">
      <img id="storyCoverImg" src="" alt="Cover Preview" style="max-width:120px;height:220px;object-fit:cover;border-radius:12px;display:none;">
    </div>
    <!-- Story Tags UI (paste after storyDesc) -->
<label>Tags (press Add)</label>
<div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
  <input id="storyTagInput" placeholder="type a tag and press Add" style="flex:1;padding:10px;border-radius:8px;border:1px solid var(--border)" />
  <button id="addStoryTagBtn" class="btn btn-secondary" type="button">Add</button>
</div>
<div id="storyTagsContainer" style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px"></div>

    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button class="btn btn-secondary" id="cancelCreateBtn">Cancel</button>
      <button class="btn btn-primary" id="startCreatingBtn">Start Creating</button>
    </div>
  </div>

  <!-- Dashboard -->
<div id="dashboardPage" class="hidden">
  <div class="dashboard-header">
    <h2>Your Content</h2>
    <div class="row">
      <button class="btn btn-primary" id="showStoriesBtn">Your Stories</button>
      <button class="btn btn-secondary" id="showSerialsBtn">Your Serials</button>
    </div>
  </div>

  <div id="dashboardList"></div>
  <button class="back-btn hidden" id="dashboardBackBtn">← Back</button>
</div>


  <script>
    // ---------- Variables ----------
    const STORAGE_KEY = "writerProfile_v1";

    // palette for random card colors (bright)
    const CARD_COLOR_PALETTE = ['#FF6B6B','#FF8A65','#FFB86B','#FFD166','#6EE7B7','#4FD1FF','#60A5FA','#A78BFA','#FF7AB6','#2DD4BF'];
    function pickCardColor(){ return CARD_COLOR_PALETTE[Math.floor(Math.random()*CARD_COLOR_PALETTE.length)]; }

    let profileExists = false, storiesData = [], serialsData = [];
    let storySlots = [], serialSlots = [];
    let currentType = 'story', selectedSlot = null;

    // Elements
    const profileBtn = document.getElementById('profileBtn');
    const profileDropdown = document.getElementById('profileDropdown');
    const profileFormPage = document.getElementById('profileFormPage');
    const saveProfileBtn = document.getElementById('saveProfileBtn');
    const profileName = document.getElementById('profileName');
    const profileAge = document.getElementById('profileAge');
    const profileCountry = document.getElementById('profileCountry');
    const welcomePage = document.getElementById('welcomePage');
    const createContentBtn = document.getElementById('createContentBtn');
    const storyFormPage = document.getElementById('storyFormPage');
    const storyTitleInput = document.getElementById('storyTitle');
    const storyGenreSelect = document.getElementById('storyGenre');
    const storyDescInput = document.getElementById('storyDesc');
    const startCreatingBtn = document.getElementById('startCreatingBtn');
    const dashboardPage = document.getElementById('dashboardPage');
    const dashboardList = document.getElementById('dashboardList');
    const slidesPage = document.getElementById('slidesPage');
    const slotsContainer = document.getElementById('slotsContainer');
    const chooseTypePopup = document.getElementById('chooseTypePopup');
    const createStoryBtn = document.getElementById('createStoryBtn');
    const createSerialBtn = document.getElementById('createSerialBtn');
    const showStoriesBtn = document.getElementById('showStoriesBtn');
    const showSerialsBtn = document.getElementById('showSerialsBtn');
    const slotsBackBtn = document.getElementById('slotsBackBtn');
    const dashboardBackBtn = document.getElementById('dashboardBackBtn');
    const cancelCreateBtn = document.getElementById('cancelCreateBtn');

    // new popups
    const slotNamePopup = document.getElementById('slotNamePopup');
    const slotNameInput = document.getElementById('slotNameInput');
    const slotNameUnlockBtn = document.getElementById('slotNameUnlockBtn');
    const slotNameCancelBtn = document.getElementById('slotNameCancelBtn');

    const serialCreatePopup = document.getElementById('serialCreatePopup');
    const seriesTitleInput = document.getElementById('seriesTitleInput');
    const seriesGenreInput = document.getElementById('seriesGenreInput');
    const seriesDescInput = document.getElementById('seriesDescInput');
    const ep1TitleInput = document.getElementById('ep1TitleInput');
    const ep1DescInput = document.getElementById('ep1DescInput');
    const serialCreateConfirmBtn = document.getElementById('serialCreateConfirmBtn');
    const serialCreateCancelBtn = document.getElementById('serialCreateCancelBtn');

    const addEpisodePopup = document.getElementById('addEpisodePopup');
    const addEpTitleInput = document.getElementById('addEpTitleInput');
    const addEpDescInput = document.getElementById('addEpDescInput');
    const addEpConfirmBtn = document.getElementById('addEpConfirmBtn');
    const addEpCancelBtn = document.getElementById('addEpCancelBtn');
    let addEpisodeSerialIndex = null; // which serial we're adding to

    
// ---- Cover Image Handling ----
const coverInput = document.getElementById('storyCoverInput');
const coverImg = document.getElementById('storyCoverImg');
if (coverInput) {
  coverInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        coverImg.src = ev.target.result;
        coverImg.style.display = 'block';
        window._currentStoryCover = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });
}

// ---- Serial cover handling ----
const serialCoverInput = document.getElementById('serialCoverInput');
const serialCoverImg = document.getElementById('serialCoverImg');
if (serialCoverInput) {
  serialCoverInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        if (serialCoverImg) {
          serialCoverImg.src = ev.target.result;
          serialCoverImg.style.display = 'block';
        }
        window._currentSerialCover = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });
} else {
  // create placeholders if elements aren't present yet
  window._serialCoverPending = true;
}

// Ensure current cover vars exist
window._currentStoryCover = window._currentStoryCover || '';
window._currentSerialCover = window._currentSerialCover || '';

// ---------- Profile ----------
    function loadProfile(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(raw){
          const profile = JSON.parse(raw);
          profileExists = true;
          updateProfileUI(profile);
        }
      }catch(e){console.warn(e)}
    }
    
    // show profile button only on home (welcomePage) — hide everywhere else
function updateHeaderVisibility() {
  const welcomePage = document.getElementById('welcomePage');
  const categoriesPage = document.getElementById('categoriesPage');
  const serialCategoriesPage = document.getElementById('serialCategoriesPage');
  const profileDropdown = document.getElementById('profileDropdown');
  const profileBtn = document.getElementById('profileBtn'); // your reference

  if (!welcomePage || !categoriesPage || !serialCategoriesPage || !profileBtn) return;

  const onHome = !welcomePage.classList.contains('hidden');
  const onBrowseStories = !categoriesPage.classList.contains('hidden');
  const onBrowseSerials = !serialCategoriesPage.classList.contains('hidden');

  if (onHome) {
    profileBtn.classList.remove('hidden');
    profileDropdown?.classList.remove('hidden');
  } else if (onBrowseStories || onBrowseSerials) {
    profileBtn.classList.add('hidden');
    profileDropdown?.classList.add('hidden');
  } else {
    profileBtn.classList.remove('hidden');
    profileDropdown?.classList.remove('hidden');
  }

  console.log('Header updated:', { onHome, onBrowseStories, onBrowseSerials });
}

function updateProfileUI(profile){
      const initials = (profile.name||'??').slice(0,2).toUpperCase();
      profileBtn.innerHTML = `<span class="profile-initials">${initials}</span>`;
    }
   profileBtn.addEventListener('click', () => {
  // prevent dropdown opening on browse pages
  const onBrowseStories = !document.getElementById('categoriesPage').classList.contains('hidden');
  const onBrowseSerials = !document.getElementById('serialCategoriesPage').classList.contains('hidden');
  if (onBrowseStories || onBrowseSerials) return;

  profileDropdown.style.display = (profileDropdown.style.display === 'flex' ? 'none' : 'flex');
  renderDropdown();
});

    function renderDropdown(){
      profileDropdown.innerHTML = '';
      if(!profileExists){
        const btn = document.createElement('button');
        btn.textContent = '✍️ Create Profile';
        btn.addEventListener('click', ()=>{ profileFormPage.classList.remove('hidden'); welcomePage.classList.add('hidden'); profileDropdown.style.display='none'; });
        profileDropdown.appendChild(btn);
      } else {
        const btn = document.createElement('button');
        btn.textContent = '🧭 Writer Dashboard';
        btn.addEventListener('click', ()=>{ showDashboard('stories'); });
        profileDropdown.appendChild(btn);
      }
    }
    saveProfileBtn.addEventListener('click', ()=>{
      const genres = Array.from(document.querySelectorAll('#genresContainer input:checked')).map(c=>c.value);
      const profile = {name:profileName.value,age:profileAge.value,country:profileCountry.value,genres};
      localStorage.setItem(STORAGE_KEY, JSON.stringify(profile));
      profileExists = true; updateProfileUI(profile);
      profileFormPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); updateHeaderVisibility();
    });
    document.querySelectorAll('.genre-option').forEach(opt=>{
      opt.addEventListener('click', ()=>{ const input=opt.querySelector('input'); input.checked=!input.checked; opt.classList.toggle('active', input.checked); });
    });

    // ---------- Browse ----------
document.getElementById('browseStoriesBtn').addEventListener('click', () => {
  openCategoriesPage();
  updateHeaderVisibility(); // ✅ update header after page change
});

document.getElementById('browseSerialsBtn').addEventListener('click', () => {
  openSerialCategoriesPage();
  updateHeaderVisibility(); // ✅ update header after page change
});

    
    
  // ---------- Categories Page ----------
document.addEventListener('DOMContentLoaded', function() {
  // Elements
  const _browseStoriesBtn = document.getElementById('browseStoriesBtn');
  const _browseSerialsBtn = document.getElementById('browseSerialsBtn');
  const _categoriesBackBtn = document.getElementById('categoriesBackBtn');
  const _serialCategoriesBackBtn = document.getElementById('serialCategoriesBackBtn');

  const _welcomePage = document.getElementById('welcomePage');
  const _categoriesPage = document.getElementById('categoriesPage');
  const _categoriesGrid = document.getElementById('categoriesGrid');
  const _serialCategoriesPage = document.getElementById('serialCategoriesPage');
  const _serialCategoriesGrid = document.getElementById('serialCategoriesGrid');

  // Safe header updater
  function safeUpdateHeader() {
    if (typeof updateHeaderVisibility === 'function') {
      updateHeaderVisibility();
    }
  }

  // Render categories
  function renderCategories(targetGrid){
    if(!targetGrid) return;
    targetGrid.innerHTML = '';
    CATEGORIES.forEach(cat=>{
      const card = document.createElement('div');
      card.className = 'cat-card';
      card.innerHTML = '<div class="cat-title">'+cat+'</div><div class="cat-sub">'+(cat==='All' ? 'All genres' : (cat + ' stories'))+'</div>';
      card.addEventListener('click', ()=>{
        targetGrid.querySelectorAll('.cat-card').forEach(c=>c.classList.remove('active'));
        card.classList.add('active');
      });
      targetGrid.appendChild(card);
    });
  }

  // Event listeners
  _browseStoriesBtn?.addEventListener('click', () => {
    _welcomePage?.classList.add('hidden');
    _categoriesPage?.classList.remove('hidden');
    if (_categoriesGrid) {
      renderCategories(_categoriesGrid);
      _categoriesGrid.scrollLeft = 0;
    }
   updateHeaderVisibility();
  });

  _browseSerialsBtn?.addEventListener('click', () => {
    _welcomePage?.classList.add('hidden');
    _serialCategoriesPage?.classList.remove('hidden');
    if (_serialCategoriesGrid) {
      renderCategories(_serialCategoriesGrid);
      _serialCategoriesGrid.scrollLeft = 0;
    }
   updateHeaderVisibility();
  });

  _categoriesBackBtn?.addEventListener('click', () => {
    _categoriesPage?.classList.add('hidden');
    _welcomePage?.classList.remove('hidden');
    updateHeaderVisibility();
  });

  _serialCategoriesBackBtn?.addEventListener('click', () => {
    _serialCategoriesPage?.classList.add('hidden');
    _welcomePage?.classList.remove('hidden');
    updateHeaderVisibility();
  });
});



    // ---------- End Categories Page ----------
    
    // ---------- Create ----------
    createContentBtn.addEventListener('click', ()=>{ if(!profileExists){ alert('Create a writer profile first!'); return; } chooseTypePopup.classList.remove('hidden'); });
    createStoryBtn.addEventListener('click', ()=>{ currentType='story'; chooseTypePopup.classList.add('hidden'); showSlotsPage(); });
    createSerialBtn.addEventListener('click', ()=>{ currentType='serial'; chooseTypePopup.classList.add('hidden'); showSlotsPage(); });

    // ---------- Slots Page ----------
    function showSlotsPage(){ welcomePage.classList.add('hidden'); slidesPage.classList.remove('hidden'); renderSlots(); updateHeaderVisibility(); }
    function renderSlots(){
      slotsContainer.innerHTML='';
      let slots = currentType==='story'? storySlots : serialSlots;
      if(slots.length===0) slots = [{id:0,unlocked:false,name:''}];
      slots.forEach((slot,index)=>{
        const div = document.createElement('div');
        div.className = 'slot-card ' + (slot.unlocked ? 'unlocked' : 'locked');
        const meta = slot.unlocked ? (`Episodes: ${ (slot.episodes || []).length }`) : 'Unlock to start';
        div.innerHTML = `<div class="slot-title">${slot.unlocked? (slot.name || ('Slot '+(slot.id+1))) : 'Locked Slot'}</div>
                         <div class="slot-meta">${meta}</div>`;
        
div.addEventListener('click', ()=> {
  selectedSlot = slot;
  if (!slot.unlocked) {
    // first click: ask to name & unlock (do not auto-open editor)
    slotNameInput.value = slot.name || '';
    slotNamePopup.dataset.slotIndex = index;
    // clear any temporary cover selection so new slots don't inherit previous cover
    window._currentStoryCover = '';
    window._currentSerialCover = '';
    if (document.getElementById('storyCoverImg')) { document.getElementById('storyCoverImg').style.display='none'; document.getElementById('storyCoverImg').src=''; }
    if (document.getElementById('serialCoverImg')) { document.getElementById('serialCoverImg').style.display='none'; document.getElementById('serialCoverImg').src=''; }
    slotNamePopup.dataset.slotIndex = index;
    slotNamePopup.classList.remove('hidden');
  } else {
    // already unlocked
    if (currentType === 'story') {
      // ----- NEW: If a story matching this slot name exists, open the editor in edit mode -----
      const existingStoryIndex = storiesData.findIndex(s => (s.title || '').trim() === (slot.name || '').trim());
      if (existingStoryIndex >= 0) {
        // open editor with isEdit=true so sheets/pages are loaded
        createEditorPage(storiesData[existingStoryIndex].title, storiesData[existingStoryIndex].genre || '', storiesData[existingStoryIndex].description || '', {
          isEdit: true,
          editType: 'story',
          index: existingStoryIndex
        });
      } else {
        // no saved story for this slot yet — open story creation form prefilled with slot name
        showStoryForm(slot.name || '');
      }
    } else {
  // SERIALS: If serial exists in this slot, open it directly in edit mode
  const existingIndex = serialsData.findIndex(s => (s.title || '').trim() === (slot.name || '').trim());
  if (existingIndex >= 0) {
    // open editor for first episode if it exists
    const ser = serialsData[existingIndex];
    const epIndex = ser.episodes && ser.episodes.length ? 0 : null;
    createEditorPage(
      epIndex != null ? ser.episodes[epIndex].title : ser.title,
      ser.genre,
      epIndex != null ? ser.episodes[epIndex].description : ser.description,
      { isEdit: true, editType: 'serial', index: existingIndex, episodeIndex: epIndex }
    );
  } else {
    // if no existing serial, show create form
    serialCreatePopup.dataset.slotIndex = index;
    seriesTitleInput.value = slot.name || '';
    seriesGenreInput.value = '';
    seriesDescInput.value = '';
    ep1TitleInput.value = '';
    ep1DescInput.value = '';
    window._currentSerialCover = '';
    if (document.getElementById('serialCoverImg')) {
      document.getElementById('serialCoverImg').style.display = 'none';
      document.getElementById('serialCoverImg').src = '';
    }
    serialCreatePopup.classList.remove('hidden');
  }
}
  }
});

        slotsContainer.appendChild(div);
      });
      if(currentType==='story') storySlots = slots; else serialSlots = slots;
    }
    slotsBackBtn.addEventListener('click', ()=>{ slidesPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); updateHeaderVisibility(); });

    // ---------- Slot Name Popup handlers ----------
    slotNameCancelBtn.addEventListener('click', ()=>{ slotNamePopup.classList.add('hidden'); });
    slotNameUnlockBtn.addEventListener('click', ()=>{
      const idx = parseInt(slotNamePopup.dataset.slotIndex || '0', 10);
      const name = slotNameInput.value.trim();
      let slotsArr = currentType==='story' ? storySlots : serialSlots;
      if(slotsArr.length === 0) slotsArr = [{id:0,unlocked:false,name:''}];
      if(!slotsArr[idx]){ slotsArr[idx] = { id: idx, unlocked: false, name: '' }; }
      // set name and unlock, but DO NOT open the create form immediately
      slotsArr[idx].name = name || ('Slot ' + (idx+1));
      slotsArr[idx].unlocked = true;
      // ensure there is always an empty locked slot at the end
      if(slotsArr[slotsArr.length-1] === slotsArr[idx]) slotsArr.push({id: slotsArr.length, unlocked: false, name: ''});
      if(currentType==='story') storySlots = slotsArr; else serialSlots = slotsArr;
      slotNamePopup.classList.add('hidden');
      renderSlots();
    });

    // ---------- Serial Create Popup handlers ----------
    serialCreateCancelBtn.addEventListener('click', ()=>{ serialCreatePopup.classList.add('hidden'); });
    serialCreateConfirmBtn.addEventListener('click', ()=>{
      const title = seriesTitleInput.value.trim();
      const genre = seriesGenreInput.value.trim();
      const sdesc = seriesDescInput.value.trim();
      const epTitle = ep1TitleInput.value.trim();
      const epDesc = ep1DescInput.value.trim();
      if(!title){ alert('Series title is required'); return; }

      // If a serial with same title exists, update it; otherwise create new
      let serIndex = serialsData.findIndex(s=> s.title === title);
      let ser;
      if(serIndex >= 0){
        ser = serialsData[serIndex];
        ser.genre = genre; ser.description = sdesc;
      } else {
        ser = { title, genre, description: sdesc, episodes: [], cover: (window._currentSerialCover || '') };
        serialsData.push(ser);
        serIndex = serialsData.indexOf(ser);
      }
      // always update cover from current selection
      ser.cover = window._currentSerialCover || '';


      // If episode1 fields were provided, create episode 1 and open editor for it
      if(epTitle){
        ser.episodes = ser.episodes || [];
        // Only add episode if none exist or the last episode title differs
        const lastEp = ser.episodes[ser.episodes.length - 1];
        if(!lastEp || lastEp.title !== epTitle){
          ser.episodes.push({ title: epTitle, description: epDesc || '', sheets: [], status: 'Draft' });
        }
      }

      // update slot that matches this title (or slot index passed)
      const idx = parseInt(serialCreatePopup.dataset.slotIndex || '-1', 10);
      let slotsArr = serialSlots.length? serialSlots : [{id:0,unlocked:false,name:''}];
      // find slot with same name, else use idx
      let slotToUpdate = slotsArr.find(s=> s.name === title) || (slotsArr[idx] || slotsArr[0]);
      slotToUpdate.unlocked = true; slotToUpdate.name = title; slotToUpdate.episodes = ser.episodes.slice(); slotToUpdate.cover = ser.cover || '';
      if(slotsArr[slotsArr.length-1] === slotToUpdate) slotsArr.push({id: slotsArr.length, unlocked: false, name: ''});
      serialSlots = slotsArr;

      serialCreatePopup.classList.add('hidden');
      renderSlots();

      // open editor for the newly created episode if we added one (choose last created episode index)
      if(epTitle){
        const epIndex = ser.episodes.length - 1;
        createEditorPage(ser.episodes[epIndex].title, ser.genre, ser.episodes[epIndex].description, { isEdit:true, editType:'serial', index: serIndex, episodeIndex: epIndex });
      }
    });

    // ---------- Add Episode Popup handlers ----------
    addEpCancelBtn.addEventListener('click', ()=>{ addEpisodePopup.classList.add('hidden'); addEpisodeSerialIndex = null; });
    addEpConfirmBtn.addEventListener('click', ()=>{
      const title = addEpTitleInput.value.trim(); const desc = addEpDescInput.value.trim();
      if(!title){ alert('Episode title is required'); return; }
      if(addEpisodeSerialIndex == null){ alert('Serial not selected'); addEpisodePopup.classList.add('hidden'); return; }
      const ser = serialsData[addEpisodeSerialIndex]; if(!ser){ alert('Serial not found'); addEpisodePopup.classList.add('hidden'); return; }
      addEpisodePopup.classList.add('hidden');
      createEditorPage(title, ser.genre, desc, { isEdit:false, editType:'serial', index: addEpisodeSerialIndex, isNewEpisode:true });
      addEpisodeSerialIndex = null;
    });

    // ---------- Story Form & Editor ----------
    function showStoryForm(title=''){ slidesPage.classList.add('hidden'); storyFormPage.classList.remove('hidden'); storyTitleInput.value = title; storyGenreSelect.value=''; storyDescInput.value=''; updateHeaderVisibility(); }
    cancelCreateBtn.addEventListener('click', ()=>{ storyFormPage.classList.add('hidden'); slidesPage.classList.remove('hidden'); updateHeaderVisibility(); });

    startCreatingBtn.addEventListener('click', ()=>{
      // carry-over any tags entered in the story form into pending tags map
      try{
        const t = (document.getElementById('storyTitle') && document.getElementById('storyTitle').value && document.getElementById('storyTitle').value.trim()) ? document.getElementById('storyTitle').value.trim() : 'temp_story';
        const tagsFromForm = getTagsFromContainer(document.getElementById('storyTagsContainer')) || [];
        window._pendingTags = window._pendingTags || {};
        if (tagsFromForm.length) window._pendingTags[t] = Array.from(new Set([...(window._pendingTags[t]||[]), ...tagsFromForm]));
      }catch(e){ console.warn('carry tags into pending failed', e); }

      if(!storyTitleInput.value || !storyGenreSelect.value){ alert('Fill Title & Genre'); return; }
      storyFormPage.classList.add('hidden'); createEditorPage(storyTitleInput.value, storyGenreSelect.value, storyDescInput.value, {isEdit:false, editType:'story'});
    });

    function createEditorPage(title, genre, desc, opts={}){
      // opts: {isEdit, editType:'story'|'serial', index, episodeIndex, isNewEpisode}
      const editType = opts.editType || 'story';
      const isEdit = !!opts.isEdit;
      const isNewEpisode = !!opts.isNewEpisode;

      const editorDiv = document.createElement('div'); editorDiv.id='editorPage';
      editorDiv.innerHTML = `
  ${(editType==='serial' && opts.isEdit && opts.episodeIndex===0) ? `
    <div style="background:#fff8e1;border:1px solid #facc15; border-radius:10px;padding:10px;margin-bottom:8px; text-align:center;font-weight:600;color:#92400e;"> ⚠️ Please create a new sheet before writing your Episode 1 by clicking the + button. </div>` : ''}

        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
          <div>
            <h2 style="margin:0">${editType==='serial' ? (isEdit && opts.episodeIndex!=null ? 'Edit Episode' : (isNewEpisode ? 'New Episode' : 'Edit Serial')) : (isEdit? 'Edit Story' : 'New Story')}</h2>
            <div class="muted">${genre || ''} ${desc? (' • '+desc) : ''}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="btn btn-secondary" id="closeEditorBtn">Close</button>
          </div>
        </div>
        <div class="sheets-bar" id="sheetsBar"><div class="add-sheet-btn" id="addSheetBtn">+</div></div>
        <textarea id="sheetTextarea" class="sheet-textarea" placeholder="Type your story..."></textarea>
        <div style="display:flex;justify-content:flex-start;gap:8px;margin-top:6px"><button id="deleteSheetBtn" class="btn btn-secondary">Delete Active Sheet</button></div>
        <div class="editor-actions">
          <button class="btn btn-secondary" id="saveDraftBtn">Save Draft</button>
          <button class="btn btn-primary" id="publishStoryBtn">${isEdit && editType==='story' ? 'Update' : (isEdit && editType==='serial' && opts.episodeIndex!=null ? 'Update' : (editType==='story' ? 'Publish' : 'Publish Episode'))}</button>
        </div>
      `;
      document.body.appendChild(editorDiv); updateHeaderVisibility();

      const sheetsBar = editorDiv.querySelector('#sheetsBar');
      const addSheetBtn = editorDiv.querySelector('#addSheetBtn');
      const sheetTextarea = editorDiv.querySelector('#sheetTextarea');
      const publishStoryBtn = editorDiv.querySelector('#publishStoryBtn');
      const saveDraftBtnLocal = editorDiv.querySelector('#saveDraftBtn');
      const closeEditorBtn = editorDiv.querySelector('#closeEditorBtn');
      const deleteSheetBtn = editorDiv.querySelector('#deleteSheetBtn');

      let sheets = [], activeSheetId = 0;
      function addNewSheet(content=''){ saveActiveSheet(); const id = sheets.length; sheets.push({id,content}); activeSheetId=id; renderSheetsBar(); sheetTextarea.value = content; sheetTextarea.focus(); }
      function renderSheetsBar(){
        sheetsBar.querySelectorAll('.sheet-thumb').forEach(e=>e.remove());
        sheets.forEach(sheet=>{
          const thumb = document.createElement('div'); thumb.className = 'sheet-thumb' + (sheet.id===activeSheetId ? ' active' : '');
          thumb.innerHTML = `<div class="thumb-text">${(sheet.content||'').slice(0,60) || 'Empty'}</div>`;
          // delete button on the thumb
          const del = document.createElement('button'); del.className = 'del'; del.innerHTML = '✖';
          del.title = 'Delete this sheet';
          del.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(!confirm('Delete this sheet? This cannot be undone.')) return; deleteSheetById(sheet.id); });
          thumb.appendChild(del);
          thumb.addEventListener('click', ()=>{ saveActiveSheet(); activeSheetId = sheet.id; sheetTextarea.value = sheet.content || ''; renderSheetsBar(); });
          sheetsBar.insertBefore(thumb, addSheetBtn);
        });
      }
      function saveActiveSheet(){ const s = sheets.find(s=>s.id===activeSheetId); if(s) s.content = sheetTextarea.value; }
      function deleteSheetById(id){ const idx = sheets.findIndex(s=> s.id === id); if(idx === -1) return; sheets.splice(idx,1); // reassign ids
        sheets = sheets.map((s,i)=> ({id:i, content: s.content}));
        // adjust activeSheetId
        if(sheets.length===0){ addNewSheet(''); return; }
        activeSheetId = Math.min(activeSheetId, sheets.length-1);
        sheetTextarea.value = sheets[activeSheetId].content || '';
        renderSheetsBar();
      }

      addSheetBtn.addEventListener('click', ()=> addNewSheet(''));

      // Delete active sheet button
      deleteSheetBtn.addEventListener('click', ()=>{
        if(!confirm('Delete the active sheet? This cannot be undone.')) return;
        deleteSheetById(activeSheetId);
      });

      // initialize: load existing when editing
      if(isEdit){
        if(editType==='story'){
          const obj = storiesData[opts.index] || {sheets:[]};
          sheets = (obj.sheets||[]).map((s,i)=>({id:i,content:s.content||s})); activeSheetId=0; renderSheetsBar(); sheetTextarea.value = sheets[0] ? sheets[0].content : '';
        } else if(editType==='serial'){
          const ser = serialsData[opts.index] || {episodes:[]};
          if(opts.episodeIndex!=null){
            const ep = (ser.episodes||[])[opts.episodeIndex] || {sheets:[]};
            sheets = (ep.sheets||[]).map((s,i)=>({id:i,content:s.content||s})); activeSheetId=0; renderSheetsBar(); sheetTextarea.value = sheets[0] ? sheets[0].content : '';
          } else {
            sheets = []; addNewSheet('');
          }
        }
      } else {
        // new story or new episode
        addNewSheet('');
      }

      publishStoryBtn.addEventListener('click', async ()=>{
        saveActiveSheet(); const payloadSheets = sheets.map(s=>({content: s.content || ''}));
        if(editType === 'story'){
          const payload = { title: title, genre: genre, description: desc, sheets: payloadSheets, status: 'Public', cover: window._currentStoryCover || '' };
          // Save locally first
          if(isEdit){ storiesData[opts.index] = Object.assign({}, storiesData[opts.index], payload); }
          else { storiesData.push(payload); }
          // Attempt to save to Firebase (overwrite same title key)
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `stories/${encodeURIComponent(title)}`), payload);
              console.log('Saved story to Firebase:', title);
            }
          }catch(err){ console.warn('Firebase save failed for story', err); }
          editorDiv.remove(); showDashboard('stories');
          return;
        }
        // serial path
        if(editType === 'serial'){
          const ser = serialsData[opts.index]; if(!ser){ alert('Serial not found'); return; }
          if(isEdit && opts.episodeIndex!=null){
            ser.episodes[opts.episodeIndex] = Object.assign({}, ser.episodes[opts.episodeIndex], { title: title, description: desc, sheets: payloadSheets, status: 'Public' });
            serialsData[opts.index] = ser;
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
              saveLocal('serialsData', serialsData);
saveLocal('serialSlots', serialSlots);
// ✅ Upload full serial with new episode to Firebase
try {
  if (window._firebase && window._firebase.set) {
    const { db, ref, set } = window._firebase;
    await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
    console.log('✅ Uploaded full serial with new episode to Firebase:', ser.title);
  }
} catch (err) {
  console.warn('❌ Firebase update failed for new episode:', err);
}
console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else if(isNewEpisode){
            ser.episodes = ser.episodes || [];
            ser.episodes.push({ title: title || 'Episode', description: desc || '', sheets: payloadSheets, status: 'Public' });
            serialsData[opts.index] = ser;
            try{
              if(window._firebase && window._firebase.set){
                const { db, ref, set } = window._firebase;
                await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
                saveLocal('serialsData', serialsData);
saveLocal('serialSlots', serialSlots);
// ✅ Upload full serial with new episode to Firebase
try {
  if (window._firebase && window._firebase.set) {
    const { db, ref, set } = window._firebase;
    await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
    console.log('✅ Uploaded full serial with new episode to Firebase:', ser.title);
  }
} catch (err) {
  console.warn('❌ Firebase update failed for new episode:', err);
}
console.log('Saved new episode (serial) to Firebase:', ser.title);
              }
            }catch(err){ console.warn('Firebase save failed for new episode', err); }

          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
              saveLocal('serialsData', serialsData);
saveLocal('serialSlots', serialSlots);
// ✅ Upload full serial with new episode to Firebase
try {
  if (window._firebase && window._firebase.set) {
    const { db, ref, set } = window._firebase;
    await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
    console.log('✅ Uploaded full serial with new episode to Firebase:', ser.title);
  }
} catch (err) {
  console.warn('❌ Firebase update failed for new episode:', err);
}
console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else {
            serialsData[opts.index] = Object.assign({}, ser, { title: title, genre: genre, description: desc });
          }
          const slot = serialSlots.find(s=> s.name === ser.title);
          if(slot) slot.episodes = ser.episodes.slice();
          editorDiv.remove(); showDashboard('serials');
          return;
        }
      });

      saveDraftBtnLocal.addEventListener('click', async ()=>{
        saveActiveSheet(); const payloadSheets = sheets.map(s=>({content: s.content || ''}));
        if(editType === 'story'){
          const payload = { title: title, genre: genre, description: desc, sheets: payloadSheets, status: 'Draft', cover: window._currentStoryCover || '' };
          if(isEdit){ storiesData[opts.index] = Object.assign({}, storiesData[opts.index], payload); }
          else { storiesData.push(payload); }
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `stories/${encodeURIComponent(title)}`), payload);
              console.log('Saved story draft to Firebase:', title);
            }
          }catch(err){ console.warn('Firebase draft save failed', err); }
          editorDiv.remove(); showDashboard('stories');
          return;
        }
        if(editType === 'serial'){
          const ser = serialsData[opts.index]; if(!ser){ alert('Serial not found'); return; }
          if(isEdit && opts.episodeIndex!=null){
            ser.episodes[opts.episodeIndex] = Object.assign({}, ser.episodes[opts.episodeIndex], { title: title, description: desc, sheets: payloadSheets, status: 'Draft' });
            serialsData[opts.index] = ser;
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
              saveLocal('serialsData', serialsData);
saveLocal('serialSlots', serialSlots);
// ✅ Upload full serial with new episode to Firebase
try {
  if (window._firebase && window._firebase.set) {
    const { db, ref, set } = window._firebase;
    await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
    console.log('✅ Uploaded full serial with new episode to Firebase:', ser.title);
  }
} catch (err) {
  console.warn('❌ Firebase update failed for new episode:', err);
}
console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else if(isNewEpisode){
            ser.episodes = ser.episodes || [];
            ser.episodes.push({ title: title || 'Episode', description: desc || '', sheets: payloadSheets, status: 'Draft' });
            serialsData[opts.index] = ser;
            try{
              if(window._firebase && window._firebase.set){
                const { db, ref, set } = window._firebase;
                await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
                saveLocal('serialsData', serialsData);
saveLocal('serialSlots', serialSlots);
// ✅ Upload full serial with new episode to Firebase
try {
  if (window._firebase && window._firebase.set) {
    const { db, ref, set } = window._firebase;
    await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
    console.log('✅ Uploaded full serial with new episode to Firebase:', ser.title);
  }
} catch (err) {
  console.warn('❌ Firebase update failed for new episode:', err);
}
console.log('Saved serial draft to Firebase:', ser.title);
              }
            }catch(err){ console.warn('Firebase draft save failed for serial', err); }

          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
              saveLocal('serialsData', serialsData);
saveLocal('serialSlots', serialSlots);
// ✅ Upload full serial with new episode to Firebase
try {
  if (window._firebase && window._firebase.set) {
    const { db, ref, set } = window._firebase;
    await set(ref(db, `serials/${encodeURIComponent(ser.title.trim())}`), ser);
    console.log('✅ Uploaded full serial with new episode to Firebase:', ser.title);
  }
} catch (err) {
  console.warn('❌ Firebase update failed for new episode:', err);
}
console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else {
            serialsData[opts.index] = Object.assign({}, ser, { title: title, genre: genre, description: desc });
          }
          const slot = serialSlots.find(s=> s.name === ser.title);
          if(slot) slot.episodes = ser.episodes.slice();
          editorDiv.remove(); showDashboard('serials');
          return;
        }
      });

      closeEditorBtn.addEventListener('click', ()=>{ if(confirm('Close editor? Unsaved changes will be lost.')) editorDiv.remove(); });
    }

    // ---------- Dashboard ----------
      function showDashboard(type='stories', genreFilter='All'){
      welcomePage.classList.add('hidden'); profileFormPage.classList.add('hidden'); storyFormPage.classList.add('hidden'); slidesPage.classList.add('hidden'); dashboardPage.classList.remove('hidden'); dashboardBackBtn.classList.remove('hidden');
      dashboardList.innerHTML='';
      updateHeaderVisibility();
      if(type==='stories'){
        const published = storiesData.filter(s=>s.status==='Public');
        const drafts = storiesData.filter(s=>s.status!=='Public');
        const ordered = [...published, ...drafts];
        // apply genre filter if requested
        const filtered = (genreFilter && genreFilter !== 'All') ? ordered.filter(s=> (s.genre||'').toLowerCase() === genreFilter.toLowerCase()) : ordered;
        const finalList = filtered;
        finalList.forEach((s, idx)=>{
          const card = document.createElement('div'); card.className='dashboard-card';
          const left = document.createElement('div'); left.className='left';
          left.innerHTML = `<div style="max-width:65%"><h3>${s.title}</h3>
                            <div class="meta">Genre: ${s.genre || '—'}</div>
                            <p class="desc">${s.description || ''}</p>
                            <p>Status: <span class="${s.status==='Public'?'status-public':'status-draft'}">${s.status}</span></p></div>`;
          const actions = document.createElement('div'); actions.className='card-actions';
          const editBtn = document.createElement('button');
editBtn.className = 'small-btn btn btn-secondary';
editBtn.textContent = s.status === 'Public' ? 'Update' : 'Edit';
editBtn.addEventListener('click', () => {
  createEditorPage(s.title, s.genre, s.description, {
    isEdit: true,
    editType: 'story',
    index: storiesData.indexOf(s)
  });
});
actions.appendChild(editBtn);

// Add Analytics button only for published stories
if (s.status === 'Public') {
  const analyticsBtn = document.createElement('button');
  analyticsBtn.className = 'small-btn btn btn-primary';
  analyticsBtn.textContent = 'Analytics';
  analyticsBtn.addEventListener('click', () => {
    showStoryAnalytics(s);
  });
  actions.appendChild(analyticsBtn);
}


          card.appendChild(left); card.appendChild(actions); dashboardList.appendChild(card);
        });
      } else {
        const ordered = [...serialsData];
        ordered.forEach((s, idx)=>{
          const card = document.createElement('div'); card.className='dashboard-card';
          const left = document.createElement('div'); left.className='left';
          left.innerHTML = `<div style="max-width:65%"><h3>${s.title}</h3>
                            <div class="meta">${s.genre || '—'} ${s.description? ('• ' + s.description) : ''}</div>
                            <p class="desc">Episodes: ${(s.episodes||[]).length}</p></div>`;
const actions = document.createElement('div');
actions.className = 'card-actions';

// --- Edit Episodes button ---
const editEpisodesBtn = document.createElement('button');
editEpisodesBtn.className = 'small-btn btn btn-secondary';
editEpisodesBtn.textContent = 'Edit Episodes';
editEpisodesBtn.addEventListener('click', () => {
  showSerialEpisodesEditor(serialsData.indexOf(s));
});

const addEpisodeBtn = document.createElement('button');
addEpisodeBtn.className = 'small-btn btn btn-primary';
addEpisodeBtn.textContent = 'Add Episode';

addEpisodeBtn.addEventListener('click', () => {
  addEpisodeSerialIndex = serialsData.indexOf(s);
  addEpTitleInput.value = '';
  addEpDescInput.value = '';
  addEpisodePopup.classList.remove('hidden');
});
const AnalyticBtn = document.createElement('button');
AnalyticBtn.className = 'small-btn btn btn-primary';
AnalyticBtn.textContent = 'Analytics';

AnalyticBtn.addEventListener('click', () => {
    // Get index of the current serial
    const serialIndex = serialsData.indexOf(s);

    // Call a function to show Serial Analytics
    showSerialAnalytics(s, serialIndex);
});



actions.appendChild(editEpisodesBtn);
actions.appendChild(addEpisodeBtn);
actions.appendChild(AnalyticBtn);
card.appendChild(left);
card.appendChild(actions);

dashboardList.appendChild(card);
});
}
}






// ---------- Reader Like/Dislike handlers (persisted in localStorage) ----------
function initReaderLikeButtons(){
  const likeBtn = document.getElementById('readerLikeBtn');
  const dislikeBtn = document.getElementById('readerDislikeBtn');
  const likeCountEl = document.getElementById('readerLikeCount');
  const dislikeCountEl = document.getElementById('readerDislikeCount');
  if(!likeBtn || !dislikeBtn) return;

  // keying based on readerTitle and (if present) episode marker in readerMeta.
  function getKey(){
    const title = (document.getElementById('readerTitle') && document.getElementById('readerTitle').textContent) || 'untitled';
    const meta = (document.getElementById('readerMeta') && document.getElementById('readerMeta').textContent) || '';
    // Try to detect "Episode X" in meta; if present, include it in key
    const epMatch = meta.match(/Episode\s*(\d+)/i);
    const key = epMatch ? `${title}::episode${epMatch[1]}` : title;
    return key;
  }

  function loadCounts(){
    const store = JSON.parse(localStorage.getItem('global_votes_v1') || '{}');
    const key = getKey();
    const data = store[key] || {likes:0, dislikes:0};
    likeCountEl.textContent = data.likes || 0;
    dislikeCountEl.textContent = data.dislikes || 0;
  }

  function saveVote(deltaLike, deltaDislike){
    const store = JSON.parse(localStorage.getItem('global_votes_v1') || '{}');
    const key = getKey();
    store[key] = store[key] || {likes:0, dislikes:0};
    store[key].likes = (store[key].likes || 0) + (deltaLike||0);
    store[key].dislikes = (store[key].dislikes || 0) + (deltaDislike||0);
    localStorage.setItem('global_votes_v1', JSON.stringify(store));
    loadCounts();
  }

  likeBtn.addEventListener('click', ()=> saveVote(1,0));
  dislikeBtn.addEventListener('click', ()=> saveVote(0,1));

  // observe title/meta changes to update counts when reader opens different items
  const titleNode = document.getElementById('readerTitle');
  const metaNode = document.getElementById('readerMeta');
  const obs = new MutationObserver(()=> loadCounts());
  if(titleNode) obs.observe(titleNode, {childList:true, characterData:true, subtree:true});
  if(metaNode) obs.observe(metaNode, {childList:true, characterData:true, subtree:true});

  // initial load
  setTimeout(loadCounts, 120);
}
document.addEventListener('DOMContentLoaded', initReaderLikeButtons);
function showStoryAnalytics(s) {
  // Remove existing analytics page
  const existing = document.getElementById("analyticsPage");
  if (existing) existing.remove();

  // Main container
  const page = document.createElement("div");
  page.id = "analyticsPage";
  Object.assign(page.style, {
    position: "fixed",
    inset: "0",
    background: "#f9fafb",
    color: "#111",
    zIndex: 9999,
    overflowY: "auto",
    padding: "40px 20px",
    fontFamily: "Poppins, system-ui, sans-serif",
  });

  // Back button
  const backBtn = document.createElement("button");
  backBtn.textContent = "← Back";
  Object.assign(backBtn.style, {
    position: "fixed",
    top: "20px",
    left: "20px",
    padding: "10px 18px",
    background: "#fff",
    border: "1px solid #ddd",
    borderRadius: "12px",
    fontWeight: "600",
    cursor: "pointer",
    boxShadow: "0 4px 14px rgba(0,0,0,0.08)",
  });
  backBtn.addEventListener("click", () => page.remove());
  page.appendChild(backBtn);

  // Title
  const title = document.createElement("h2");
  title.textContent = `${s.title || "Story"} Analytics`;
  Object.assign(title.style, { textAlign: "center", fontSize: "30px", marginBottom: "18px", fontWeight: "800" });
  page.appendChild(title);

  // Top stats cards
  const globalVotes = JSON.parse(localStorage.getItem("global_votes_v1") || "{}");
  const votes = globalVotes[s.title] || { likes: 0, dislikes: 0 };
  const reads = Number(s.reads || 0);

  let statusText = "ON GOING", statusColor = "#3b82f6";
  if (reads <= 10) { statusText = "ON GOING"; statusColor = "#3b82f6"; }
  else if (reads <= 40) { statusText = "REACHING WELL"; statusColor = "#10b981"; }
  else if (reads <= 75) { statusText = "TRENDING"; statusColor = "#f59e0b"; }
  else { statusText = "POPULAR"; statusColor = "#ef4444"; }

  const statsWrap = document.createElement("div");
  Object.assign(statsWrap.style, {
    display: "flex",
    justifyContent: "space-between",
    gap: "20px",
    marginBottom: "22px",
    maxWidth: "1000px",
    marginLeft: "auto",
    marginRight: "auto",
  });

  const makeBox = (label, value, color) => {
    const box = document.createElement("div");
    Object.assign(box.style, {
      flex: "1",
      background: "#fff",
      borderRadius: "16px",
      padding: "18px",
      boxShadow: "0 6px 20px rgba(0,0,0,0.06)",
      fontWeight: "700",
      textAlign: "center",
      transition: "transform 0.15s",
    });
    box.addEventListener("mouseover", ()=> box.style.transform="translateY(-2px)");
    box.addEventListener("mouseout", ()=> box.style.transform="translateY(0)");
    box.innerHTML = `<div style="font-size:13px;color:#6b7280">${label}</div>
                     <div style="font-size:24px;color:${color || "#111"}">${value}</div>`;
    return box;
  };

  statsWrap.appendChild(makeBox("👁️ Reads", reads, "#3b82f6"));
  statsWrap.appendChild(makeBox("👍 Likes", votes.likes || 0, "#10b981"));
  statsWrap.appendChild(makeBox("📊 Status", statusText, statusColor));
  page.appendChild(statsWrap);

  // --- Chart area (replaces history) ---

  // Helpers
  const getDateKey = (d) => {
    const dt = new Date(d);
    const y = dt.getFullYear();
    const m = String(dt.getMonth() + 1).padStart(2, "0");
    const day = String(dt.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  };

  // Try to build timeseries from several sources:
  // 1) If story has a history array like [{date:'2025-10-16', reads:10, likes:2}, ...] use that
  // 2) Otherwise, use snapshot store in localStorage ('story_daily_snapshots_v1') keyed by story title
  // 3) Always add current snapshot (today) with current reads/likes so chart is up-to-date.

  const snapshotStoreKey = "story_daily_snapshots_v1";
  const store = JSON.parse(localStorage.getItem(snapshotStoreKey) || "{}");

  // If s.history exists and looks usable, normalize it
  let series = {};
  if (Array.isArray(s.history) && s.history.length > 0) {
    s.history.forEach(h => {
      // Expect h to have date (or publishedAt) and reads/likes
      const dateKey = getDateKey(h.date || h.publishedAt || h.day || new Date());
      series[dateKey] = series[dateKey] || { reads: 0, likes: 0 };
      series[dateKey].reads = Math.max(series[dateKey].reads, Number(h.reads || h.r || 0));
      series[dateKey].likes = Math.max(series[dateKey].likes, Number(h.likes || h.l || 0));
    });
  }

  // Merge snapshots from store (for this story)
  const storyKey = s.title || (s.id ? `id_${s.id}` : "untitled");
  const storedForStory = store[storyKey] || {};
  Object.keys(storedForStory).forEach(dateKey => {
    series[dateKey] = series[dateKey] || { reads: 0, likes: 0 };
    // stored snapshot expected shape: { reads: N, likes: M }
    series[dateKey].reads = Math.max(series[dateKey].reads, Number(storedForStory[dateKey].reads || 0));
    series[dateKey].likes = Math.max(series[dateKey].likes, Number(storedForStory[dateKey].likes || 0));
  });

  // Add today's snapshot (so chart shows current)
  const todayKey = getDateKey(new Date());
  series[todayKey] = series[todayKey] || { reads: 0, likes: 0 };
  series[todayKey].reads = Math.max(series[todayKey].reads, reads);
  series[todayKey].likes = Math.max(series[todayKey].likes, votes.likes || 0);

  // Persist today's snapshot into localStorage for future charts
  store[storyKey] = store[storyKey] || {};
  store[storyKey][todayKey] = {
    reads: series[todayKey].reads,
    likes: series[todayKey].likes,
    ts: Date.now()
  };
  localStorage.setItem(snapshotStoreKey, JSON.stringify(store));

  // Build sorted dataPoints
  const dateKeys = Object.keys(series).sort((a,b) => new Date(a) - new Date(b));
  // If nothing meaningful, show a friendly message
  if (dateKeys.length === 0) {
    const noData = document.createElement("div");
    noData.textContent = "No analytics data yet — publish and come back after some reads.";
    Object.assign(noData.style, { textAlign: "center", marginTop: "40px", color: "#6b7280" });
    page.appendChild(noData);
    document.body.appendChild(page);
    return;
  }

  const dataPoints = dateKeys.map(dk => ({ date: dk, reads: Number(series[dk].reads || 0), likes: Number(series[dk].likes || 0) }));

  // Chart container
  const chartWrap = document.createElement("div");
  Object.assign(chartWrap.style, {
    maxWidth: "1000px",
    margin: "0 auto 60px",
    background: "#fff",
    padding: "20px",
    borderRadius: "14px",
    boxShadow: "0 6px 20px rgba(0,0,0,0.04)"
  });

  // Legend and controls
  const legend = document.createElement("div");
  legend.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px;">
      <div style="display:flex;gap:12px;align-items:center;">
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:12px;height:12px;border-radius:2px;background:#3b82f6"></div><div style="font-size:13px;color:#374151">Reads</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:12px;height:12px;border-radius:2px;background:#10b981"></div><div style="font-size:13px;color:#374151">Likes</div>
        </div>
      </div>
      <div style="font-size:13px;color:#6b7280">Grouped by date</div>
    </div>
  `;
  chartWrap.appendChild(legend);

  // Build SVG chart
  const svgWidth = Math.min(960, Math.max(600, dataPoints.length * 70));
  const svgHeight = 300;
  const padding = { top: 20, right: 20, bottom: 60, left: 48 };
  const innerW = svgWidth - padding.left - padding.right;
  const innerH = svgHeight - padding.top - padding.bottom;

  // Compute max value to scale bars
  const maxVal = Math.max(...dataPoints.flatMap(d => [d.reads, d.likes]), 1);
  // nice round max
  const niceMax = (() => {
    const exp = Math.floor(Math.log10(maxVal));
    const base = Math.pow(10, exp);
    return Math.ceil(maxVal / base) * base;
  })();

  // Create SVG element
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.style.display = "block";
  svg.style.margin = "0 auto";

  // Axes group
  const g = document.createElementNS(svgNS, "g");
  g.setAttribute("transform", `translate(${padding.left},${padding.top})`);
  svg.appendChild(g);

  // Y grid lines and labels
  const ticks = 4;
  for (let i = 0; i <= ticks; i++) {
    const y = innerH - (i / ticks) * innerH;
    const val = Math.round((i / ticks) * niceMax);
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", 0);
    line.setAttribute("y1", y);
    line.setAttribute("x2", innerW);
    line.setAttribute("y2", y);
    line.setAttribute("stroke", "#e6e9ee");
    line.setAttribute("stroke-width", "1");
    g.appendChild(line);

    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", -10);
    label.setAttribute("y", y + 4);
    label.setAttribute("text-anchor", "end");
    label.setAttribute("font-size", "11");
    label.setAttribute("fill", "#6b7280");
    label.textContent = val;
    g.appendChild(label);
  }

  // Bars: grouped per date (reads + likes)
  const groupGap = 14;
  const groupWidth = innerW / dataPoints.length;
  const barWidth = Math.min(24, (groupWidth - groupGap) / 2);

  // Tooltip element (HTML overlay)
  const tooltip = document.createElement("div");
  Object.assign(tooltip.style, {
    position: "fixed",
    padding: "8px 10px",
    background: "#111",
    color: "#fff",
    fontSize: "12px",
    borderRadius: "6px",
    pointerEvents: "none",
    opacity: 0,
    transition: "opacity 0.12s",
    zIndex: 10000
  });
  document.body.appendChild(tooltip);

  dataPoints.forEach((d, i) => {
    const groupX = i * groupWidth + groupWidth / 2 - (barWidth + 6) / 2 - 6; // center groups

    // Reads bar (left)
    const readsH = (d.reads / niceMax) * innerH;
    const readsRect = document.createElementNS(svgNS, "rect");
    readsRect.setAttribute("x", groupX);
    readsRect.setAttribute("y", innerH - readsH);
    readsRect.setAttribute("width", barWidth);
    readsRect.setAttribute("height", Math.max(1, readsH));
    readsRect.setAttribute("fill", "#3b82f6");
    readsRect.style.cursor = "pointer";
    g.appendChild(readsRect);

    // Likes bar (right)
    const likesH = (d.likes / niceMax) * innerH;
    const likesRect = document.createElementNS(svgNS, "rect");
    likesRect.setAttribute("x", groupX + barWidth + 6);
    likesRect.setAttribute("y", innerH - likesH);
    likesRect.setAttribute("width", barWidth);
    likesRect.setAttribute("height", Math.max(1, likesH));
    likesRect.setAttribute("fill", "#10b981");
    likesRect.style.cursor = "pointer";
    g.appendChild(likesRect);

    // X label (date)
    const lbl = document.createElementNS(svgNS, "text");
    lbl.setAttribute("x", i * groupWidth + groupWidth / 2);
    lbl.setAttribute("y", innerH + 18);
    lbl.setAttribute("text-anchor", "middle");
    lbl.setAttribute("font-size", "11");
    lbl.setAttribute("fill", "#374151");
    lbl.textContent = d.date.slice(5); // show MM-DD for compactness
    g.appendChild(lbl);

    // Hover events for reads
    const attachHover = (elem, type) => {
      elem.addEventListener("mousemove", (ev) => {
        tooltip.style.left = (ev.pageX + 12) + "px";
        tooltip.style.top = (ev.pageY + 12) + "px";
        tooltip.innerHTML = `<strong style="display:block">${type}</strong><div style="font-size:13px">${d[type.toLowerCase()]}</div><div style="font-size:11px;color:#cbd5e1">${d.date}</div>`;
        tooltip.style.opacity = "1";
      });
      elem.addEventListener("mouseleave", () => tooltip.style.opacity = "0");
    };
    attachHover(readsRect, "Reads");
    attachHover(likesRect, "Likes");
  });

  // Y-axis label
  const yAxisLabel = document.createElementNS(svgNS, "text");
  yAxisLabel.setAttribute("x", -padding.left + 6);
  yAxisLabel.setAttribute("y", -6);
  yAxisLabel.setAttribute("font-size", "12");
  yAxisLabel.setAttribute("fill", "#6b7280");
  yAxisLabel.textContent = "Count";
  g.appendChild(yAxisLabel);

  chartWrap.appendChild(svg);

  // Small footnote and export CSV
  const footer = document.createElement("div");
  footer.style.display = "flex";
  footer.style.justifyContent = "space-between";
  footer.style.alignItems = "center";
  footer.style.marginTop = "12px";

  const note = document.createElement("div");
note.style.color = "#6b7280";
note.style.fontSize = "13px";
note.textContent = "Data shown per date (reads vs likes).";

const exportBtn = document.createElement("button");
exportBtn.textContent = "";
Object.assign(exportBtn.style, {
  display: "none", // ✅ this hides the button completely
  fontSize: "13px"
});

footer.appendChild(note);
// exportBtn is hidden but harmless
footer.appendChild(exportBtn);

  exportBtn.addEventListener("click", () => {
    // Build CSV
    const rows = [["date","reads","likes"], ...dataPoints.map(d => [d.date, d.reads, d.likes])];
    const csv = rows.map(r => r.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${(s.title || "story").replace(/\s+/g,'_')}_analytics.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  footer.appendChild(note);
  footer.appendChild(exportBtn);
  chartWrap.appendChild(footer);

  page.appendChild(chartWrap);

  // Basic story meta card
  const storyCard = document.createElement("div");
  Object.assign(storyCard.style, {
    background: "#fff",
    padding: "14px",
    borderRadius: "12px",
    boxShadow: "0 6px 20px rgba(0,0,0,0.04)",
    maxWidth: "1000px",
    margin: "0 auto 40px",
  });

  const createdAt = new Date(s.publishedAt || s.published || s.publishDate || Date.now());
  const getCharCount = (story) => {
    if (story.content) return story.content.length;
    if (story.body) return story.body.length;
    if (story.text) return story.text.length;
    if (story.serial && Array.isArray(story.serial)) {
      return story.serial.reduce((sum, part) => sum + (part.text?.length || 0), 0);
    }
    return 0;
  };
  const charCount = getCharCount(s);

  storyCard.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
    <div>
      <div style="font-size:16px;font-weight:600;color:#111">${s.title || "Untitled Story"}</div>
      <div style="font-size:13px;color:#6b7280;margin-top:4px">Created: ${createdAt.toLocaleString()}</div>
    <div style="text-align:right">
      <div style="font-size:13px;color:#6b7280">Total reads</div>
      <div style="font-size:20px;font-weight:700;color:#3b82f6">${reads}</div>
    </div>
  </div>`;

  page.appendChild(storyCard);

  document.body.appendChild(page);
}


function showSerialAnalytics(serialOrTitle) {
  const VOTES_STORE_KEY = 'global_votes_v1';
  const SNAPSHOT_KEY = 'story_daily_snapshots_v1';
  const READS_KEY = 'serial_reads_v1'; // 🆕 added

  // Safe loader
  function loadSaved() {
    try {
      return typeof loadSavedSerials === 'function'
        ? loadSavedSerials()
        : JSON.parse(localStorage.getItem('saved_serials_v1') || '[]');
    } catch (e) {
      return (serialsData || []).slice();
    }
  }

  const serial =
    typeof serialOrTitle === 'string'
      ? (loadSaved().find(s => s.title === serialOrTitle) ||
         (serialsData || []).find(s => s.title === serialOrTitle))
      : serialOrTitle;

  if (!serial) {
    alert('Serial not found');
    return;
  }

  // Remove old analytics
  const existing = document.getElementById('serialAnalyticsPage');
  if (existing) existing.remove();

  // Main page
  const page = document.createElement('div');
  page.id = 'serialAnalyticsPage';
  Object.assign(page.style, {
    position: 'fixed',
    inset: 0,
    background: '#f9fafb',
    color: '#111',
    zIndex: 9999,
    overflowY: 'auto',
    padding: '36px 20px',
    boxSizing: 'border-box',
    fontFamily: 'Poppins, system-ui, sans-serif'
  });

  // Back button
  const backBtn = document.createElement('button');
  backBtn.textContent = '← Back';
  Object.assign(backBtn.style, {
    position: 'fixed',
    top: '20px',
    left: '20px',
    padding: '10px 18px',
    background: '#fff',
    border: '1px solid #ddd',
    borderRadius: '12px',
    fontWeight: 600,
    cursor: 'pointer',
    boxShadow: '0 4px 14px rgba(0,0,0,0.08)'
  });
  backBtn.addEventListener('click', () => page.remove());
  page.appendChild(backBtn);

  // Title
  const title = document.createElement('h2');
  title.textContent = `${serial.title || 'Untitled Serial'} Analytics`;
  Object.assign(title.style, {
    textAlign: 'center',
    fontSize: '28px',
    margin: '8px 0 20px',
    fontWeight: 800
  });
  page.appendChild(title);

  // Votes
  const votesStore = JSON.parse(localStorage.getItem(VOTES_STORE_KEY) || '{}');
  const voteKey = `serial::${serial.title || 'untitled'}`;
  const votes = votesStore[voteKey] || { likes: Number(serial.likes || 0), dislikes: Number(serial.dislikes || 0) };

  // 🆕 Load reads from the read tracking store
  const readsStore = JSON.parse(localStorage.getItem(READS_KEY) || '{}');
  const readKey = `serial::${serial.title || 'untitled'}`;
  const readData = readsStore[readKey] || { total: 0, episodes: {} };

  const totalReads = Number(readData.total || 0);
  const episodeCount = Array.isArray(serial.episodes) ? serial.episodes.length : 0;

  // --- Top Stats ---
  const statsWrap = document.createElement('div');
  Object.assign(statsWrap.style, {
    display: 'flex',
    gap: '18px',
    justifyContent: 'space-between',
    maxWidth: '980px',
    margin: '0 auto 18px',
    flexWrap: 'wrap'
  });

  const makeBox = (label, value, color) => {
    const b = document.createElement('div');
    Object.assign(b.style, {
      flex: '1',
      minWidth: '180px',
      background: '#fff',
      borderRadius: '12px',
      padding: '14px',
      boxShadow: '0 8px 28px rgba(0,0,0,0.06)',
      textAlign: 'center',
      fontWeight: 700
    });
    b.innerHTML = `<div style="font-size:13px;color:#6b7280">${label}</div><div style="font-size:22px;color:${color ||
      '#111'}">${value}</div>`;
    return b;
  };

  statsWrap.appendChild(makeBox('Episodes', episodeCount, '#7c3aed'));
  statsWrap.appendChild(makeBox('Total Reads', totalReads, '#3b82f6'));
  statsWrap.appendChild(makeBox('👍 Likes', votes.likes || 0, '#10b981'));
  page.appendChild(statsWrap);

  // --- Per Episode Reads Table ---
  if (episodeCount > 0) {
    const table = document.createElement('table');
    Object.assign(table.style, {
      width: '100%',
      maxWidth: '980px',
      margin: '0 auto 30px',
      borderCollapse: 'collapse',
      background: '#fff',
      borderRadius: '12px',
      overflow: 'hidden',
      boxShadow: '0 8px 28px rgba(0,0,0,0.04)'
    });

    table.innerHTML = `
      <thead style="background:#f3f4f6">
        <tr>
          <th style="text-align:left;padding:10px 14px;font-size:14px;">Episode</th>
          <th style="text-align:center;padding:10px 14px;font-size:14px;">Reads</th>
        </tr>
      </thead>
      <tbody>
        ${serial.episodes
          .map((ep, i) => {
            const r = readData.episodes && readData.episodes[i] ? readData.episodes[i] : 0;
            return `<tr>
              <td style="padding:8px 14px;border-top:1px solid #eee;">${i + 1}. ${ep.title || 'Untitled'}</td>
              <td style="padding:8px 14px;border-top:1px solid #eee;text-align:center;color:#3b82f6;font-weight:600">${r}</td>
            </tr>`;
          })
          .join('')}
      </tbody>
    `;
    page.appendChild(table);
  }

  // --- Chart (reads vs likes per day) ---
  // (same as before, unchanged for brevity)
  // you can keep your existing chart + CSV export code here

  document.body.appendChild(page);
}


  
    dashboardBackBtn.addEventListener('click', ()=>{ dashboardPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); dashboardBackBtn.classList.add('hidden'); });

    function showSerialOptions(slot){
      const modal = document.createElement('div'); modal.className='popup';
      modal.innerHTML = `<div class="popup-content"><h3>${slot.name} — Serial Options</h3>
                         <div style="display:flex;flex-direction:column;gap:8px;margin-top:12px;text-align:left">
                           <button id="manageEpsBtn" class="btn btn-secondary">Manage Episodes</button>
                           <button id="addEpBtn" class="btn btn-primary">Add Episode</button>
                           <button id="openCreateBtn" class="btn btn-primary">Open Serial Form</button>
                           <button id="closeSlotOpts" class="btn btn-secondary" style="margin-top:8px">Close</button>
                         </div></div>`;
      document.body.appendChild(modal);
      modal.querySelector('#manageEpsBtn').addEventListener('click', ()=>{ modal.remove(); showSerialEpisodesEditor(serialSlots.indexOf(slot)); });
      modal.querySelector('#addEpBtn').addEventListener('click', ()=>{ modal.remove();
        const ser = serialsData.find(s=> s.title === slot.name);
        if(!ser){ const newSer = { title: slot.name, genre: '', description: '', episodes: slot.episodes ? slot.episodes.slice() : [] }; serialsData.push(newSer); }
        const serIndex = serialsData.findIndex(s=> s.title === slot.name);
        addEpisodeSerialIndex = serIndex; addEpTitleInput.value = ''; addEpDescInput.value = ''; addEpisodePopup.classList.remove('hidden');
      });
      modal.querySelector('#openCreateBtn').addEventListener('click', ()=>{ modal.remove();
        serialCreatePopup.dataset.slotIndex = serialSlots.indexOf(slot);
        const existing = serialsData.find(s=> s.title === slot.name);
        if(existing){ seriesTitleInput.value = existing.title || slot.name || ''; seriesGenreInput.value = existing.genre || ''; seriesDescInput.value = existing.description || ''; }
        else { seriesTitleInput.value = slot.name || ''; seriesGenreInput.value = ''; seriesDescInput.value = ''; }
        ep1TitleInput.value = ''; ep1DescInput.value = '';
        serialCreatePopup.classList.remove('hidden');
      });
      modal.querySelector('#closeSlotOpts').addEventListener('click', ()=> modal.remove());
    }

    function showSerialEpisodesEditor(serialIndex){
      const ser = serialsData[serialIndex]; if(!ser) { alert('Serial not found'); return; }
      const modal = document.createElement('div'); modal.className='popup'; modal.innerHTML = `<div class="popup-content"><h3>${ser.title} — Episodes</h3><div id="epsList" style="max-height:300px;overflow:auto;margin-top:10px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="closeEps" class="btn btn-secondary">Close</button></div></div>`;
      document.body.appendChild(modal);
      const epsList = modal.querySelector('#epsList'); const closeEps = modal.querySelector('#closeEps');
      (ser.episodes||[]).forEach((ep, i)=>{
        const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='8px 0';
        row.innerHTML = `<div style="max-width:70%"><strong>${i+1}. ${ep.title}</strong><div style="font-size:13px;color:var(--muted)">${ep.description||''}</div><div style="font-size:12px;color:var(--muted)">Status: ${ep.status||'Draft'}</div></div>`;
        const buttons = document.createElement('div'); buttons.style.display='flex'; buttons.style.gap='8px';
        const editBtn = document.createElement('button'); editBtn.className='small-btn btn btn-secondary'; editBtn.textContent='Edit'; editBtn.addEventListener('click', ()=>{ modal.remove(); createEditorPage(ep.title, ser.genre, ep.description, {isEdit:true, editType:'serial', index: serialIndex, episodeIndex: i, isNewEpisode:false}); });
        buttons.appendChild(editBtn);
        row.appendChild(buttons); epsList.appendChild(row);
      });
      closeEps.addEventListener('click', ()=> modal.remove());
    }

    // ---------- Init ----------
    loadProfile();
    storySlots = [{id:0,unlocked:false,name:''}];
    serialSlots = [{id:0,unlocked:false,name:''}];
    updateHeaderVisibility();
  
    // ---------- Browse Stories rendering & Preview/Reader ----------
// Story browsing & rendering (full snippet, fixed demo merge bug)

const STORY_ALGO_CONFIG = {
  popularityWeight: 0.5,      // lower to allow new creators
  recencyWeight: 0.25,        // same as before
  noveltyWeight: 0.25,        // gives less popular stories a chance
  randomWeight: 0.1,          // small exploration
  freshDaysBoost: 21,         // recent content boost
  freshBoostMultiplier: 1.4,  // stronger boost for fresh content
  explorationFraction: 0.25,
  cardsPerViewport: 6
};

// Session RNG (seeded per page load)
(function initStorySeed() {
  if (window.__STORY_RENDER_SEED) return;
  let extra = 0;
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    extra = arr[0];
  } else {
    extra = Math.floor(Math.random() * 0xffffffff);
  }
  window.__STORY_RENDER_SEED = ((Date.now() & 0xffffffff) ^ extra) >>> 0;
})();
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r = r + Math.imul(r ^ (r >>> 7), 61 | r) ^ r;
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function rngForStoryRender() {
  return mulberry32(window.__STORY_RENDER_SEED);
}

// Utilities
function daysSince(dateString) {
  if (!dateString) return Number.MAX_SAFE_INTEGER;
  const d = new Date(dateString);
  if (isNaN(d)) return Number.MAX_SAFE_INTEGER;
  return Math.floor((Date.now() - d.getTime()) / (1000*60*60*24));
}
function normalizeArray(values) {
  const clean = values.map(v => Number.isFinite(v) ? v : 0);
  const min = Math.min(...clean);
  const max = Math.max(...clean);
  return max === min ? clean.map(() => 0.5) : clean.map(v => (v - min) / (max - min));
}
function shuffleArray(arr, rng=Math.random) {
  for (let i = arr.length-1; i>0; i--) {
    const j = Math.floor(rng()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function computeStoryPopularity(s) {
  const reads = Number(s.reads ?? s.readCount ?? 0);
  const likes = Number(s.likes ?? 0);
  return Math.log1p(reads) + 1.5*Math.log1p(likes);
}

// ================= SCORING =================
function scoredStories(stories, rng) {
  rng = rng || Math.random;

  const popArr = stories.map(computeStoryPopularity);
  const ageArr = stories.map(s => Math.max(0, 365 - Math.min(daysSince(s.published||s.createdAt||s.date||s.uploadedAt),365)));

  const popNorm = normalizeArray(popArr);
  const recNorm = normalizeArray(ageArr);

  return stories.map((s,i) => {
    const pop = popNorm[i];
    const rec = recNorm[i];
    const novelty = Math.max(0.2, 1-pop); // ensure new stories get minimum chance
    const randomEps = (rng ? rng() : Math.random()) * STORY_ALGO_CONFIG.randomWeight;

    let score = STORY_ALGO_CONFIG.popularityWeight*pop
              + STORY_ALGO_CONFIG.recencyWeight*rec
              + STORY_ALGO_CONFIG.noveltyWeight*novelty
              + randomEps;

    const ageDays = daysSince(s.published||s.createdAt||s.date||s.uploadedAt);
    if (ageDays <= STORY_ALGO_CONFIG.freshDaysBoost) score *= STORY_ALGO_CONFIG.freshBoostMultiplier;

    return Object.assign({}, s, {
      __score: score,
      __popNorm: pop,
      __recNorm: rec,
      __novelty: novelty,
      __ageDays: ageDays
    });
  });
}

// ================= EXPLORATION =================
function pickStoryExploration(candidates, count, rng) {
  if (!candidates || candidates.length===0 || count<=0) return [];
  rng = rng || Math.random;

  const scored = candidates.map(s => {
    const novelty = s.__novelty ?? 0.5;
    const recency = s.__recNorm ?? 0.5;
    return Object.assign({}, s, { __exploreScore: novelty*0.6 + recency*0.4 + rng()*0.1 });
  });

  scored.sort((a,b) => b.__exploreScore - a.__exploreScore);
  return shuffleArray(scored.slice(0, Math.min(count, scored.length)), rng);
}

// Demo stories generator
function generateDemoStories(count=50, rng) {
  rng = rng || rngForStoryRender();
  const genres=["Action","Romance","Comedy","Fantasy","Horror","Tragic","Thriller","Adventure","Crime","Historic"];
  const covers=[
    "https://picsum.photos/seed/demo1/600/900",
    "https://picsum.photos/seed/demo2/600/900",
    "https://picsum.photos/seed/demo3/600/900",
    "https://picsum.photos/seed/demo4/600/900",
    "https://picsum.photos/seed/demo5/600/900",
    "https://picsum.photos/seed/demo6/600/900"
  ];
  const stories=[];
  for(let i=0;i<count;i++){
    const genre=genres[Math.floor(rng()*genres.length)];
    const title=`${genre} Demo Story ${i+1}`;
    const readCount=Math.floor(rng()*1000);
    const likes=Math.floor(rng()*400);
    const daysAgo=Math.floor(rng()*400);
    const date=new Date(Date.now()-daysAgo*86400000).toISOString();
    stories.push({
      id:`demo-${i+1}`,
      title,
      genre,
      description:`Demo ${genre.toLowerCase()} story — random readCount ${readCount}.`,
      cover:covers[i%covers.length],
      readCount,
      reads:readCount,
      likes,
      createdAt:date
    });
  }
  return stories;
}

// Main render function

function renderBrowseStories(
  selectedCategory = "All",
  opts = { includeDemo: false, demoCount: 50, mergeWithSaved: false }
) {
  const rng = rngForStoryRender();
  try {
    const storiesListDiv = document.getElementById("storiesBrowseList");
    const cards = document.getElementById("storiesCards");
    if (!cards) return;

    if (storiesListDiv) storiesListDiv.style.display = "block";
    cards.style.display = "block";
    cards.style.width = "100%";
    cards.style.flexWrap = "wrap";

    const allStoriesData = window.storiesData || [];
    const publicStories = allStoriesData.filter(
      (s) => s.status === "Public" || !s.status
    );

    let filteredStories =
      selectedCategory !== "All"
        ? publicStories.filter(
            (s) =>
              (s.genre || "").toLowerCase() === selectedCategory.toLowerCase()
          )
        : publicStories;

    const demoStories =
      (!filteredStories.length && opts.includeDemo)
        ? generateDemoStories(opts.demoCount || 50, rng)
        : [];

    let allStories = [...filteredStories, ...demoStories];
    if (!allStories.length) {
      if (storiesListDiv) storiesListDiv.style.display = "none";
      return;
    }

    const oldScrollX = {};
    cards.querySelectorAll("div[data-genre]").forEach((sec) => {
      const g = sec.dataset.genre;
      const sc = sec.querySelector(".scroll-wrap");
      if (sc) oldScrollX[g] = sc.scrollLeft;
    });

    const genresOrder = [
      "Action",
      "Romance",
      "Comedy",
      "Fantasy",
      "Horror",
      "Tragic",
      "Thriller",
      "Adventure",
      "Crime",
      "Historic",
    ];

    const grouped = {};
    allStories.forEach((s) => {
      const g = s.genre ? s.genre.trim() : "Other";
      if (!grouped[g]) grouped[g] = [];
      grouped[g].push(s);
    });

    const allScored = scoredStories(allStories, rng);
    const scoredMap = new Map();
    allScored.forEach((s) => scoredMap.set(s.id ?? s.title, s));

    const imagesToWait = [];

    genresOrder.forEach((genre) => {
      const list = grouped[genre];
      if (!list || list.length === 0) return;

      let section = cards.querySelector(`div[data-genre="${genre}"]`);
      if (!section) {
        section = document.createElement("div");
        section.dataset.genre = genre;
        section.style.display = "block";
        section.style.marginBottom = "32px";
        cards.appendChild(section);

        const heading = document.createElement("h3");
        heading.textContent = genre;
        heading.style.margin = "6px 12px";
        heading.style.textAlign = "left";
        section.appendChild(heading);
      }

      let scrollWrap = section.querySelector(".scroll-wrap");
      if (!scrollWrap) {
        scrollWrap = document.createElement("div");
        scrollWrap.className = "scroll-wrap";
        scrollWrap.style.display = "flex";
        scrollWrap.style.overflowX = "auto";
        scrollWrap.style.gap = "12px";
        scrollWrap.style.padding = "12px";
        scrollWrap.style.scrollBehavior = "smooth";
        scrollWrap.style.scrollbarWidth = "thin";
        scrollWrap.style.flexWrap = "nowrap";
        section.appendChild(scrollWrap);
      }
      scrollWrap.innerHTML = "";

      const scoredList = list.map(
        (s) =>
          scoredMap.get(s.id ?? s.title) ||
          Object.assign({}, s, { __score: rng() * 0.2 })
      );
      const sorted = scoredList.slice().sort((a, b) => b.__score - a.__score);

      const displayCount = Math.min(
        sorted.length,
        Math.max(STORY_ALGO_CONFIG.cardsPerViewport, Math.ceil(sorted.length))
      );
      const explorationCount = Math.ceil(
        displayCount * STORY_ALGO_CONFIG.explorationFraction
      );
      const topCandidates = sorted.slice(0, displayCount - explorationCount);
      const explorationPool = sorted.slice(displayCount - explorationCount);
      const explorationPicked = pickStoryExploration(
        explorationPool,
        explorationCount,
        rng
      );

      const finalList = [];
      const maxLen = Math.max(topCandidates.length, explorationPicked.length);
      for (let i = 0; i < maxLen; i++) {
        if (i < topCandidates.length) finalList.push(topCandidates[i]);
        if (i < explorationPicked.length) finalList.push(explorationPicked[i]);
      }
      if (!finalList.length)
        finalList.push(...sorted.slice(0, displayCount));
      shuffleArray(finalList, rng);

      finalList.forEach((s) => {
        const card = document.createElement("div");
        card.className = "story-card";
        card.dataset.title = s.title || "";
        card.style.minWidth = "260px";
        card.style.flex = "0 0 auto";
        card.style.borderRadius = "14px";
        card.style.padding = "14px";
        card.style.boxShadow = "0 6px 16px rgba(0,0,0,0.1)";
        card.style.display = "flex";
        card.style.flexDirection = "column";
        card.style.justifyContent = "space-between";
        card.style.cursor = "pointer";
        card.style.position = "relative";
        card.style.transition = "box-shadow 0.25s ease-out";

        if (s.cover) {
          const img = new Image();
          img.src = s.cover;
          imagesToWait.push(
            new Promise((res) => {
              if (img.complete) return res();
              img.onload = img.onerror = () => res();
            })
          );
          card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)),url(${s.cover})`;
          card.style.backgroundSize = "cover";
          card.style.backgroundPosition = "center";
          card.style.color = "#fff";
        } else {
          const colorMap = {
            action: "#ff4b4b",
            romance: "#ff6fa8",
            comedy: "#ffd54f",
            tragic: "#4fc3f7",
            horror: "#000",
            fantasy: "#a78bfa",
            thriller: "#A52A2A",
            crime: "#FF0000",
            adventure: "#FF0000",
            historic: "#C0C0C0",
          };
          const color = colorMap[(s.genre || "").toLowerCase()] || "#888";
          card.style.background = color;
          card.style.color = color === "#000" ? "#fff" : "#000";
        }

        const titleEl = document.createElement("h4");
        titleEl.textContent = s.title || "Untitled";
        titleEl.style.margin = "0 0 6px";
        titleEl.style.fontSize = "17px";
        titleEl.style.fontWeight = "700";
        titleEl.style.textShadow = s.cover
          ? "1px 1px 3px rgba(0,0,0,0.6)"
          : "";

        const genreEl = document.createElement("p");
        genreEl.textContent = s.genre || "Unknown";
        genreEl.style.margin = "0 0 6px";
        genreEl.style.fontSize = "13px";
        genreEl.style.fontWeight = "600";
        genreEl.style.opacity = "0.9";
        genreEl.style.textShadow = s.cover
          ? "1px 1px 2px rgba(0,0,0,0.4)"
          : "";

        const desc = document.createElement("p");
        desc.textContent = s.description || "";
        desc.style.margin = "4px 0 8px";
        desc.style.fontSize = "14px";
        desc.style.lineHeight = "1.4";
        desc.style.overflow = "hidden";
        desc.style.display = "-webkit-box";
        desc.style.webkitLineClamp = "3";
        desc.style.webkitBoxOrient = "vertical";
        desc.style.textShadow = s.cover
          ? "1px 1px 2px rgba(0,0,0,0.4)"
          : "";

        const bottomRow = document.createElement("div");
        bottomRow.style.display = "flex";
        bottomRow.style.justifyContent = "space-between";
        bottomRow.style.alignItems = "center";
        bottomRow.style.marginTop = "auto";

        const reads = document.createElement("div");
        reads.textContent = "👁️ " + (s.reads || 0);
        reads.style.fontSize = "13px";
        reads.style.fontWeight = "600";

        const readBtn = document.createElement("button");
        readBtn.className = "btn btn-primary";
        readBtn.textContent = "Read";
        readBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          openPreviewFullScreen(s);
        });

        bottomRow.appendChild(reads);
        bottomRow.appendChild(readBtn);

        card.appendChild(titleEl);
        card.appendChild(genreEl);
        card.appendChild(desc);
        card.appendChild(bottomRow);

        scrollWrap.appendChild(card);
      });

      if (oldScrollX[genre] !== undefined) {
        const prevBehavior = scrollWrap.style.scrollBehavior;
        scrollWrap.style.scrollBehavior = "auto";
        scrollWrap.scrollLeft = oldScrollX[genre];
        scrollWrap.style.scrollBehavior = prevBehavior || "smooth";
      }
    });
  } catch (err) {
    console.warn("renderBrowseStories error:", err);
  }
}


// Example helper (you likely have your own implementation)
function openPreviewFullScreen(story) {
  // placeholder: implement your preview open logic
  console.log('Open preview for', story.title || story.id);
}

// Run render (explicitly disable demo cards by default)
renderBrowseStories('All', { includeDemo: false, demoCount: 0, mergeWithSaved: false });




    // open preview modal for a story object
    function openPreview(story){
      const modal = document.getElementById('previewModal');
      document.getElementById('previewTitle').textContent = story.title;
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      let author = '—';
      if(profileRaw){ try{ const p = JSON.parse(profileRaw); author = p.name || '—'; }catch(e){} }
      const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];
      document.getElementById('previewMeta').textContent = `${story.genre || '—'} • Written by ${author} • Written on ${dateStr}`;
      document.getElementById('previewDesc').textContent = story.description || '';
      // pick random sentence(s) from sheets
      let snippet = '';
      try{
        const allText = (story.sheets||[]).map(sh => sh.content || '').join(' ');
        const sentences = allText.split(/(?<=[.!?])\s+/).filter(Boolean);
        for(let i=0;i<3 && i<sentences.length;i++){
          const r = Math.floor(Math.random()*sentences.length);
          snippet += (sentences[r] || '') + ' ';
        }
        snippet = snippet.trim().slice(0,300) + (snippet.length>300 ? '...' : '');
      }catch(e){ snippet = (story.sheets && story.sheets[0] && story.sheets[0].content.slice(0,200)) || ''; }
      document.getElementById('previewSnippet').textContent = snippet;
      modal.classList.remove('hidden');
      document.getElementById('previewCloseBtn').onclick = ()=> modal.classList.add('hidden');
      document.getElementById('startReadingBtn').onclick = ()=> { modal.classList.add('hidden'); openReader(story); };
    }

    // Reader
    let _currentReader = { story:null, sheetIndex:0 };
    function openReader(story){
      const modal = document.getElementById('readerModal');
      const titleEl = document.getElementById('readerTitle');
      const metaEl = document.getElementById('readerMeta');
      const sheetEl = document.getElementById('readerSheet');
      const pager = document.getElementById('readerPager');
      _currentReader.story = story;
      _currentReader.sheetIndex = 0;
      titleEl.textContent = story.title;
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      let author = '—';
      if(profileRaw){ try{ const p = JSON.parse(profileRaw); author = p.name || '—'; }catch(e){} }
      const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];
      metaEl.textContent = `${story.genre || '—'} • Written by ${author} • Published on ${dateStr}`;
      function renderSheet(){
        const sheets = story.sheets || [];
        const s = sheets[_currentReader.sheetIndex] || { content: '' };
        sheetEl.textContent = s.content || '';
        pager.textContent = `${_currentReader.sheetIndex+1} / ${Math.max(1,sheets.length)}`;
        document.getElementById('readerPrevBtn').disabled = _currentReader.sheetIndex===0;
        document.getElementById('readerNextBtn').disabled = _currentReader.sheetIndex >= sheets.length-1;
      }
      document.getElementById('readerPrevBtn').onclick = ()=> { if(_currentReader.sheetIndex>0) _currentReader.sheetIndex--; renderSheet(); };
      document.getElementById('readerNextBtn').onclick = ()=> { if((_currentReader.sheetIndex+1) < (story.sheets||[]).length) _currentReader.sheetIndex++; renderSheet(); };
      document.getElementById('readerCloseBtn').onclick = ()=> { modal.classList.add('hidden'); };
      document.getElementById('readerDownloadBtn').onclick = ()=> { downloadSingleStory(story); };
      // simple swipe support
      let startX = null;
      const readerContent = document.getElementById('readerContent');
      readerContent.ontouchstart = (e)=> { startX = e.touches[0].clientX; };
      readerContent.ontouchend = (e)=> {
        if(startX==null) return;
        const dx = e.changedTouches[0].clientX - startX;
        if(dx < -40){ // swipe left -> next
          if(_currentReader.sheetIndex < (story.sheets||[]).length-1) _currentReader.sheetIndex++;
        } else if(dx > 40){ // swipe right -> prev
          if(_currentReader.sheetIndex > 0) _currentReader.sheetIndex--;
        }
        renderSheet();
        startX = null;
      };
      modal.classList.remove('hidden');
      renderSheet();
    }

    // Download functions
    function downloadAllContent(){
      const data = { stories: storiesData, serials: serialsData, exportedOn: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'writer_content_export_'+(new Date().toISOString().slice(0,10))+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    function downloadSingleStory(story){
      const blob = new Blob([JSON.stringify(story, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = (story.title || 'story').replace(/[^\w\-]/g,'_') + '.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    // wire dashboard download button
    document.addEventListener('click', function(e){
      if(e.target && e.target.id === 'dashboardDownloadBtn') downloadAllContent();
    });

    // Ensure published stories show up in Browse after publish/save (hook used in createEditorPage)
    const originalPublishHook = null; // placeholder
    // We'll monkey-patch the place where storiesData is pushed: after publish or saveDraft in createEditorPage, renderBrowseStories is called.
    // To be safe, call renderBrowseStories periodically and when dashboard opens.
    setInterval(()=>{ renderBrowseStories(currentCategorySelection || 'All'); }, 1200);

    // hook categories selection to render browse list appropriately
    const cats = document.querySelectorAll('.cat-card');
    let currentCategorySelection = 'All';
    function attachCategoryClicks(){
      const grid = document.getElementById('categoriesGrid');
      if(!grid) return;
      grid.querySelectorAll('.cat-card').forEach(c=>{
        c.addEventListener('click', ()=>{
          const cat = c.querySelector('.cat-title').textContent || 'All'; currentCategorySelection = cat;
          renderBrowseStories(cat);
        });
      });
    }
    // attach on DOM ready
    window.addEventListener('DOMContentLoaded', ()=>{ setTimeout(attachCategoryClicks, 400); });

    // Fix profile header visibility when returning from dashboard - ensure profile button shown on welcome page
    dashboardBackBtn.addEventListener('click', ()=>{ dashboardPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); dashboardBackBtn.classList.add('hidden'); profileBtn.style.display = 'inline-flex'; });

    // Also whenever showDashboard is called, ensure profile button hidden and dropdown closed
    const originalShowDashboard = showDashboard;
    showDashboard = function(type, genreFilter){ profileBtn.style.display = 'none'; profileDropdown.style.display = 'none'; originalShowDashboard(type, genreFilter); };

    // Ensure renderBrowseStories runs when storiesData changes: override publish/save code paths by wrapping push functions
    // To keep it simple, we override the global arrays' push to call renderBrowseStories after new story added (only for storiesData)
    (function(){
      const origPush = storiesData.push;
      storiesData.push = function(){
        const res = origPush.apply(this, arguments);
        try{ renderBrowseStories(currentCategorySelection || 'All'); }catch(e){};
        return res;
      };
    })();

    // Also when editor publishes (the code in createEditorPage already pushes and then calls showDashboard), but renderBrowseStories will update automatically.
    // Finally, when page loads, render browse stories once
    window.addEventListener('load', ()=>{ setTimeout(()=> renderBrowseStories('All'), 600); });


// ======================
// Updated openPreviewFullScreen
// - Share & Comments buttons moved below author/date
// - Deep-link via ?previewStory=<title> (history updated on open/close)
// ======================
function openPreviewFullScreen(story){
  const previewFull = document.getElementById('previewFull');
  previewFull.innerHTML = '';

  const panel = document.createElement('div');
  panel.className = 'fullscreen-panel';
  const inner = document.createElement('div');
  inner.className = 'panel-inner';

  // --- Author & Date ---
  const profileRaw = localStorage.getItem(window.STORAGE_KEY || 'user_profile_v1');
  let author = 'Jashandeep'; // fallback
  if(profileRaw){
    try{
      const p = JSON.parse(profileRaw);
      if(p.name && p.name.trim()) author = p.name;
    }catch(e){}
  }
  const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];

  // --- Snippet from first sheet ---
  let topSnippet = '';
  try{
    const firstSheet = (story.sheets && story.sheets[0] && story.sheets[0].content) || '';
    const sentences = firstSheet.split(/(?<=[.!?])\s+/).filter(Boolean);
    topSnippet = sentences.length ? sentences.slice(0,2).join(' ').trim().slice(0,360) : firstSheet.slice(0,300);
  }catch(e){ topSnippet = ''; }

  const storyTitle = story.title && story.title.trim() ? story.title : 'GENZ';

  // helper escape
  function escapeHtml(str){
    return String(str == null ? '' : str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  // --- Build inner HTML ---
  // Note: Share + Comments buttons placed below author/date (as requested)
  inner.innerHTML = `
  <div class="panel-top" style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start">
    <div style="flex:1;min-width:0">
      <h1 style="margin:6px 0 4px 0;word-break:break-word">${escapeHtml(storyTitle)}</h1>

      <div class="panel-meta" style="word-break:break-word">${escapeHtml(story.description || '')}</div>
      <div class="panel-meta" style="margin-top:6px">Written by ${escapeHtml(author)} • Written on ${escapeHtml(dateStr)}</div>

      <!-- Share & Comments moved below the author/date -->
      <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
        <button id="previewShareBtn" class="share-btn-small" aria-expanded="false">Share</button>
        <button id="previewCommentsBtn" class="share-btn-small" aria-expanded="false">Comments</button>
      </div>

      <div style="display:flex;align-items:center;gap:12px;font-size:14px;color:var(--muted);margin-top:8px">
        <span>Genre: ${escapeHtml(story.genre || '—')}</span>
        <span id="previewReadCount" style="font-weight:600;color:#fff;background:#000000;padding:2px 6px;border-radius:4px;">👁️ ${story.reads || 0} Reads</span>
      </div>
    </div>
  </div>

  <hr />

  <div style="font-style:italic;color:var(--muted);margin-top:8px;min-height:44px;">${escapeHtml(topSnippet)}</div>
  <div style="margin-top:12px;color:var(--muted);font-size:14px">(Preview shows a few sentences from the story. Click Start Reading to open the full reader.)</div>

  <div id="previewFullTags" class="tag-row" style="margin-top:12px"></div>

  <div style="display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap">
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="previewCloseBtn" class="btn btn-secondary">Close</button>
      <button id="previewStartBtn" class="btn btn-primary">Start Reading</button>
    </div>
  </div>

  <div style="display:flex;gap:12px;align-items:center;margin-top:12px">
    <div style="display:flex;align-items:center;gap:8px">
      <button id="previewLikeBtn" class="btn btn-secondary" aria-pressed="false">👍 Like</button>
      <span id="previewLikeCount" class="muted">0</span>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <button id="previewDislikeBtn" class="btn btn-secondary" aria-pressed="false">👎 Dislike</button>
      <span id="previewDislikeCount" class="muted">0</span>
    </div>
  </div>
  `;

  panel.appendChild(inner);
  previewFull.appendChild(panel);
  previewFull.classList.remove('hidden');

  // --- when opening preview, set previewStory param so shared link opens this preview directly ---
  // Use URL and URLSearchParams to preserve other params
  try {
    const urlObj = new URL(window.location.href);
    urlObj.searchParams.set('previewStory', story.title || '');
    history.replaceState(null, '', urlObj.toString());
  } catch (e) {
    // ignore if URL API fails
  }

  // --- Render Tags ---
  const tagContainer = document.getElementById('previewFullTags');
  tagContainer.innerHTML = '';

  // Safe merge: story.tags + pending tags
  const storyKey = story.title ? story.title.trim() : '';
  const pendingTags = (window._pendingTags && Array.isArray(window._pendingTags[storyKey])) ? window._pendingTags[storyKey] : [];
  const storyTags = Array.isArray(story.tags) ? story.tags : [];
  const tags = [...new Set([...storyTags, ...pendingTags])]; // merge & remove duplicates

  if(tags.length === 0){
    const placeholder = document.createElement('span');
    placeholder.className = 'muted';
    placeholder.textContent = '(No tags yet)';
    tagContainer.appendChild(placeholder);
  } else {
    tags.forEach(t => {
      const chip = document.createElement('div');
      chip.className = 'tag-chip';
      chip.textContent = t;
      tagContainer.appendChild(chip);
    });
  }

  // --- Reads counter ---
  try{
    const previewStartBtn = inner.querySelector('#previewStartBtn');
    if(previewStartBtn){
      previewStartBtn.addEventListener('click', function(){
        story.reads = (story.reads || 0) + 1;
        try{ localStorage.setItem('storiesData', JSON.stringify(storiesData)); }catch(e){}
      });
    }
  }catch(e){ console.warn('reads init failed', e); }

  // --- Like/Dislike logic (kept as you had) ---
  (function setupPreviewVotes(){
    try{
      const keyGlobal = 'global_votes_v1';
      const keyMine = 'my_votes_v1';
      const title = (story && (story.title || 'untitled')).toString();

      function loadJSON(k){ try{ return JSON.parse(localStorage.getItem(k)||'{}'); }catch(e){ return {}; } }
      function saveJSON(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} }

      const globalVotes = loadJSON(keyGlobal);
      const myVotes = loadJSON(keyMine);

      if(!globalVotes[title]) globalVotes[title] = { likes: story.likes||0, dislikes: story.dislikes||0 };
      story.likes = globalVotes[title].likes;
      story.dislikes = globalVotes[title].dislikes;

      const likeBtn = inner.querySelector('#previewLikeBtn');
      const dislikeBtn = inner.querySelector('#previewDislikeBtn');
      const likeCount = inner.querySelector('#previewLikeCount');
      const dislikeCount = inner.querySelector('#previewDislikeCount');

      function render(){
        const mine = myVotes[title] || null;
        if(likeCount) likeCount.textContent = globalVotes[title].likes || 0;
        if(dislikeCount) dislikeCount.textContent = globalVotes[title].dislikes || 0;
        if(likeBtn){
          likeBtn.classList.toggle('btn-primary', mine==='like');
          likeBtn.classList.toggle('btn-secondary', mine!=='like');
        }
        if(dislikeBtn){
          dislikeBtn.classList.toggle('btn-primary', mine==='dislike');
          dislikeBtn.classList.toggle('btn-secondary', mine!=='dislike');
        }
      }

      function saveAndRender(){ saveJSON(keyGlobal, globalVotes); saveJSON(keyMine, myVotes); render(); }

      if(likeBtn) likeBtn.addEventListener('click', function(e){
        e.stopPropagation();
        const prev = myVotes[title] || null;
        if(prev==='like'){
          globalVotes[title].likes = Math.max(0, (globalVotes[title].likes||0)-1);
          delete myVotes[title];
        } else if(prev==='dislike'){
          globalVotes[title].dislikes = Math.max(0, (globalVotes[title].dislikes||0)-1);
          globalVotes[title].likes = (globalVotes[title].likes||0)+1;
          myVotes[title]='like';
        } else {
          globalVotes[title].likes = (globalVotes[title].likes||0)+1;
          myVotes[title]='like';
        }
        saveAndRender();
      });

      if(dislikeBtn) dislikeBtn.addEventListener('click', function(e){
        e.stopPropagation();
        const prev = myVotes[title] || null;
        if(prev==='dislike'){
          globalVotes[title].dislikes = Math.max(0, (globalVotes[title].dislikes||0)-1);
          delete myVotes[title];
        } else if(prev==='like'){
          globalVotes[title].likes = Math.max(0, (globalVotes[title].likes||0)-1);
          globalVotes[title].dislikes = (globalVotes[title].dislikes||0)+1;
          myVotes[title]='dislike';
        } else {
          globalVotes[title].dislikes = (globalVotes[title].dislikes||0)+1;
          myVotes[title]='dislike';
        }
        saveAndRender();
      });

      render();
    }catch(e){ console.warn('vote setup failed', e); }
  })();

  // --- Share UI styles injection (if not already) ---
  if (!document.getElementById('share-ui-style')) {
    const style = document.createElement('style');
    style.id = 'share-ui-style';
    style.textContent = `
      .share-btn-small { background: linear-gradient(135deg,#6ea8fe,#8bd3ff); border:none; color:#fff; padding:6px 10px; border-radius:12px; cursor:pointer; font-weight:600; font-size:13px; transition:transform .15s ease,box-shadow .15s ease; }
      .share-btn-small:hover{ transform:scale(1.03); box-shadow:0 4px 10px rgba(0,0,0,0.12); }
      .share-menu { position:absolute; background:#fff; border:1px solid #e6e6e6; border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:8px; min-width:210px; box-shadow:0 8px 24px rgba(15,15,15,0.12); z-index:1400; }
      .share-option { display:flex; align-items:center; gap:10px; padding:8px; border-radius:8px; border:none; background:#fbfbfb; cursor:pointer; font-weight:500; }
      .share-option:hover { background:#fff1e6; }
      /* Comments panel styles (kept compact) */
       .comments-panel { position: fixed; inset: 0; background: rgba(255,255,255,0.98); z-index: 1500; display: flex; flex-direction: column; padding: 18px; gap: 12px; overflow: hidden; }
  .comments-top { display:flex;align-items:center;justify-content:space-between;gap:12px;border-bottom:1px solid #eee;padding-bottom:12px; }
  .comments-list { display:flex; flex-direction:column; gap:12px; padding:12px 4px; max-width:900px; width:100%; margin:0 auto; overflow:auto; flex:1 1 auto; padding-bottom:120px; } /* reserve space for sticky input */
  .comment-card { background:#fff; border:1px solid #eee; border-radius:12px; padding:12px; box-shadow:0 4px 12px rgba(0,0,0,0.03); }
  .comment-input-wrap { position: sticky; bottom: 12px; display:flex; justify-content:center; width:100%; align-items:center; padding:12px 0 4px; z-index: 1510; pointer-events: auto; }
  .comment-input-wrapper-bg { width:100%; display:flex; justify-content:center; }
  .comment-input { width: min(880px, 96%); display:flex; gap:8px; align-items:center; border-radius:999px; padding:8px; border:1px solid #e5e7eb; box-shadow:0 6px 20px rgba(0,0,0,0.03); background:#fff; }
  .comment-input textarea { flex:1; border:none; outline:none; resize:none; font-size:14px; padding:10px 14px; border-radius:999px; line-height:1.3; background:transparent; color:inherit; }
  .comment-send { background:linear-gradient(90deg,#7c3aed,#06b6d4); color:#fff; border:none; padding:10px 16px; border-radius:999px; cursor:pointer; font-weight:700; box-shadow:0 8px 24px rgba(124,58,237,0.14); transition: transform .12s ease, box-shadow .12s ease; }
  .comment-send:hover { transform: translateY(-2px); box-shadow:0 14px 34px rgba(124,58,237,0.18); }

    `;
    document.head.appendChild(style);
  }

  // --- Create share menu (and make it deep-link aware) ---
  const existingMenu = document.getElementById('story-preview-share-menu');
  if (existingMenu) existingMenu.remove();

  const shareMenu = document.createElement('div');
  shareMenu.id = 'story-preview-share-menu';
  shareMenu.className = 'share-menu';
  shareMenu.style.display = 'none';
  document.body.appendChild(shareMenu);

  function getShareLink(platform){
    // deep link that opens the preview directly: preserves origin/path and sets previewStory param
    try {
      const u = new URL(window.location.href);
      u.searchParams.set('previewStory', story.title || '');
      const link = u.toString();
      const message = `Title: ${story.title || 'Untitled'}\nGenre: ${story.genre || '—'}\nDescription: ${story.description || ''}\nRead here: ${link}`;
      if(platform === 'WhatsApp') return `https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`;
      if(platform === 'Facebook') return `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(link)}`;
      if(platform === 'Twitter') return `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
      return link;
    } catch (e) {
      // fallback simple link
      const link = `${location.origin}${location.pathname}?previewStory=${encodeURIComponent(story.title || '')}`;
      return link;
    }
  }

  const options = [
    { name: 'WhatsApp', label: 'WhatsApp', emoji: '🟢' },
    { name: 'Facebook', label: 'Facebook', emoji: '🔵' },
    { name: 'Twitter', label: 'Twitter', emoji: '🐦' },
    { name: 'Copy', label: 'Copy Link', emoji: '🔗' }
  ];

  options.forEach(opt => {
    const btn = document.createElement('button');
    btn.className = 'share-option';
    btn.type = 'button';
    btn.innerHTML = `${opt.emoji} ${opt.label}`;
    btn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      const link = getShareLink(opt.name);
      if(opt.name === 'Copy'){
        try{
          await navigator.clipboard.writeText(link);
          btn.textContent = '✅ Link Copied!';
          setTimeout(()=> btn.innerHTML = `${opt.emoji} ${opt.label}`, 1400);
        }catch(e){
          // fallback copy
          const tmp = document.createElement('input');
          tmp.value = link;
          document.body.appendChild(tmp);
          tmp.select();
          try{ document.execCommand('copy'); btn.textContent = '✅ Link Copied!'; }catch(_){}
          tmp.remove();
          setTimeout(()=> btn.innerHTML = `${opt.emoji} ${opt.label}`, 1400);
        }
      } else {
        window.open(link, '_blank');
      }
      shareMenu.style.display = 'none';
      const shareBtn = inner.querySelector('#previewShareBtn');
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    });
    shareMenu.appendChild(btn);
  });

  // Position & toggle share menu
  const shareBtn = inner.querySelector('#previewShareBtn');
  if (shareBtn) {
    shareBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const rect = shareBtn.getBoundingClientRect();
      const spaceBelow = window.innerHeight - rect.bottom;
      const menuHeightGuess = 200;
      if(spaceBelow > menuHeightGuess) {
        shareMenu.style.top = (rect.bottom + window.scrollY + 8) + 'px';
      } else {
        shareMenu.style.top = Math.max(8, rect.top + window.scrollY - menuHeightGuess - 8) + 'px';
      }
      const left = rect.right + window.scrollX - Math.min(shareMenu.offsetWidth || 220, 220);
      shareMenu.style.left = (left > 8 ? left : rect.left + window.scrollX) + 'px';
      shareMenu.style.display = shareMenu.style.display === 'flex' || shareMenu.style.display === 'block' ? 'none' : 'flex';
      shareMenu.style.flexDirection = 'column';
      shareBtn.setAttribute('aria-expanded', shareMenu.style.display !== 'none');
    });
  }

  // Close share menu on outside click or escape
  function closeShareMenuOnClick(e){
    if(!shareMenu.contains(e.target) && e.target !== shareBtn) {
      shareMenu.style.display = 'none';
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    }
  }
  function closeShareMenuOnEsc(e){
    if(e.key === 'Escape') {
      shareMenu.style.display = 'none';
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    }
  }
  document.addEventListener('click', closeShareMenuOnClick);
  document.addEventListener('keydown', closeShareMenuOnEsc);

  // --- Close / Start Reading buttons (and cleanup of previewStory param) ---
  const closeBtn = inner.querySelector('#previewCloseBtn');
  const startBtn = inner.querySelector('#previewStartBtn');
  function cleanupPreviewParam(){
    try {
      const u = new URL(window.location.href);
      u.searchParams.delete('previewStory');
      history.replaceState(null, '', u.pathname + u.search + u.hash);
    } catch(e) {}
  }
  if(closeBtn) closeBtn.addEventListener('click', ()=>{
    previewFull.classList.add('hidden');
    cleanupPreviewParam();
  });
  if(startBtn) startBtn.addEventListener('click', ()=> {
    previewFull.classList.add('hidden');
    cleanupPreviewParam();
    if(typeof openReaderFullScreen === 'function') openReaderFullScreen(story);
  });

  // ============================
  // COMMENTS: full panel logic (same pattern as serials)
  // ============================
  (function integrateComments(){
    const COMMENTS_KEY = 'comments_v1';
    const STORAGE_KEY_LOCAL = window.STORAGE_KEY || 'user_profile_v1';
    const commentsKey = `comments::${story.title || 'untitled'}`;

    function loadStore(k){ try{ return JSON.parse(localStorage.getItem(k) || '{}'); }catch(e){ return {}; } }
    function saveStore(k,v){ try{ localStorage.setItem(k, JSON.stringify(v || {})); }catch(e){} }

    // ensure structure exists
    const base = loadStore(COMMENTS_KEY);
    base[commentsKey] = base[commentsKey] || { comments: [] };
    saveStore(COMMENTS_KEY, base);

    const commentsBtn = inner.querySelector('#previewCommentsBtn');
    if (commentsBtn) {
      commentsBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        openCommentsPanel();
      });
    }

    function getCurrentUserName(){
      try{
        const p = JSON.parse(localStorage.getItem(STORAGE_KEY_LOCAL) || '{}');
        if(p && p.name && p.name.trim()) return p.name.trim();
      }catch(e){}
      return 'You';
    }

    function generateId(){ return 'c_' + Date.now().toString(36) + '_' + Math.floor(Math.random()*1000).toString(36); }

    // state for UI
    const expandedReplies = new Set();
    let currentReplyTo = null;

    function loadCommentsObj(){
      const s = loadStore(COMMENTS_KEY);
      s[commentsKey] = s[commentsKey] || { comments: [] };
      return s;
    }
    function saveCommentsObj(obj){
      saveStore(COMMENTS_KEY, obj);
    }

    function openCommentsPanel(){
      // remove existing to re-create fresh
      let cpanel = document.getElementById('previewCommentsFull');
      if(cpanel) cpanel.remove();

      cpanel = document.createElement('div');
      cpanel.id = 'previewCommentsFull';
      cpanel.className = 'comments-panel';

      const top = document.createElement('div');
      top.className = 'comments-top';
      top.innerHTML = `
        <div style="display:flex;align-items:center;gap:12px;flex:1">
          <div class="comments-title" style="display:flex;gap:12px;align-items:center">
            <span style="font-size:20px">${escapeHtml(story.title || 'Untitled')}</span>
            <span class="comments-count-badge" id="previewCommentsCount">${(loadCommentsObj()[commentsKey].comments || []).length} comments</span>
          </div>
          <div class="small-muted" style="margin-left:auto">Likes: <strong id="previewSerialLikeBadge">${story.likes || 0}</strong></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="closePreviewCommentsBtn" class="share-btn-small" style="background:linear-gradient(90deg,#ef4444,#f97316)">Close</button>
        </div>
      `;
      cpanel.appendChild(top);

      const list = document.createElement('div');
      list.className = 'comments-list';
      list.id = 'previewCommentsList';
      cpanel.appendChild(list);

      const inputWrap = document.createElement('div');
      inputWrap.className = 'comment-input-wrap';
      inputWrap.innerHTML = `
        <div id="previewReplyModeIndicatorWrap" style="display:none;"></div>
        <div class="comment-input">
          <textarea id="previewCommentTextArea" placeholder="Add a public comment..." rows="2"></textarea>
          <button id="previewSendCommentBtn" class="comment-send">Send</button>
        </div>
      `;
      cpanel.appendChild(inputWrap);

      document.body.appendChild(cpanel);

      document.getElementById('closePreviewCommentsBtn').addEventListener('click', ()=> cpanel.remove() );
      document.getElementById('previewSendCommentBtn').addEventListener('click', sendComment);
      document.getElementById('previewCommentTextArea').addEventListener('keydown', function(e){
        if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendComment(); }
      });

      renderComments();
    }

    function sendComment(){
      const ta = document.getElementById('previewCommentTextArea');
      if(!ta) return;
      const text = ta.value.trim();
      if(!text) return;
      const user = getCurrentUserName();
      const obj = loadCommentsObj();

      if(currentReplyTo){
        const parent = (obj[commentsKey].comments || []).find(x => x.id === currentReplyTo);
        if(!parent){
          currentReplyTo = null;
        } else {
          const newReply = { id: generateId(), author: user, text: text, ts: Date.now(), likes: 0, dislikes: 0 };
          parent.replies = parent.replies || [];
          parent.replies.push(newReply);
          expandedReplies.add(parent.id);
          saveCommentsObj(obj);
          ta.value = '';
          currentReplyTo = null;
          renderComments();
          updateReplyModeIndicator();
          return;
        }
      }

      const newComment = { id: generateId(), author: user, text: text, ts: Date.now(), likes: 0, dislikes: 0, replies: [] };
      obj[commentsKey].comments.unshift(newComment);
      saveCommentsObj(obj);
      ta.value = '';
      renderComments();
    }

    function updateReplyModeIndicator(){
      const wrap = document.getElementById('previewReplyModeIndicatorWrap');
      if(!wrap) return;
      if(currentReplyTo){
        const obj = loadCommentsObj();
        const c = (obj[commentsKey].comments || []).find(x => x.id === currentReplyTo);
        const name = c ? c.author : '';
        wrap.style.display = 'block';
        wrap.innerHTML = `<div class="reply-mode-indicator">Replying to <strong>${escapeHtml(name)}</strong>
          <button id="previewCancelReplyMode" class="btn-action" style="margin-left:8px">Cancel</button></div>`;
        const cancel = document.getElementById('previewCancelReplyMode');
        if(cancel) cancel.addEventListener('click', ()=>{
          currentReplyTo = null;
          updateReplyModeIndicator();
          const ta = document.getElementById('previewCommentTextArea');
          if(ta) ta.focus();
        });
      } else {
        wrap.style.display = 'none';
        wrap.innerHTML = '';
      }
    }

    function renderComments(){
      const list = document.getElementById('previewCommentsList');
      if(!list) return;
      list.innerHTML = '';
      const obj = loadCommentsObj();
      const arr = obj[commentsKey].comments || [];
      const badge = document.getElementById('previewCommentsCount');
      if(badge) badge.textContent = `${arr.length} comments`;
      const likeBadge = document.getElementById('previewSerialLikeBadge');
      if(likeBadge) likeBadge.textContent = story.likes || 0;

      arr.forEach(comment => {
        const card = document.createElement('div');
        card.className = 'comment-card';
        card.dataset.cid = comment.id;

        const meta = document.createElement('div');
        meta.className = 'comment-meta';

        const left = document.createElement('div');
        left.innerHTML = `${escapeHtml(comment.author)} <span class="small-muted" style="font-weight:500;margin-left:8px">${new Date(comment.ts).toLocaleString()}</span>`;

        const right = document.createElement('div');

        if(comment.author === getCurrentUserName()){
          const delBtn = document.createElement('button');
          delBtn.className = 'btn-action delete-comment';
          delBtn.textContent = 'Delete';
          delBtn.addEventListener('click', ()=>{
            if(!confirm('Delete this comment?')) return;
            deleteComment(comment.id);
          });
          right.appendChild(delBtn);
        }

        meta.appendChild(left);
        meta.appendChild(right);
        card.appendChild(meta);

        const text = document.createElement('div');
        text.className = 'comment-text';
        text.innerHTML = escapeHtml(comment.text);
        card.appendChild(text);

        const actions = document.createElement('div');
        actions.className = 'comment-actions';
        const repliesCount = (comment.replies || []).length;
        actions.innerHTML = `
          <button class="btn-action like-comment">👍 <span class="cnt">${comment.likes || 0}</span></button>
          <button class="btn-action dislike-comment">👎 <span class="cnt">${comment.dislikes || 0}</span></button>
          <button class="btn-action reply-open">Reply</button>
          <button class="btn-action replies-toggle">Replies (${repliesCount})</button>
        `;
        card.appendChild(actions);

        const replyList = document.createElement('div');
        replyList.className = 'reply-list';
        replyList.style.display = expandedReplies.has(comment.id) ? 'flex' : 'none';

        (comment.replies || []).forEach(reply => {
          const r = document.createElement('div');
          r.className = 'reply-card';
          r.dataset.rid = reply.id;

          const topRow = document.createElement('div');
          topRow.style.display = 'flex';
          topRow.style.justifyContent = 'space-between';
          topRow.style.alignItems = 'center';

          const authorDiv = document.createElement('div');
          authorDiv.style.fontWeight = '600';
          authorDiv.innerHTML = `${escapeHtml(reply.author)} <span class="small-muted" style="font-weight:500;margin-left:8px">${new Date(reply.ts).toLocaleString()}</span>`;

          const rightTop = document.createElement('div');

          if(reply.author === getCurrentUserName()){
            const delR = document.createElement('button');
            delR.className = 'btn-action delete-reply';
            delR.textContent = 'Delete';
            delR.addEventListener('click', ()=>{
              if(!confirm('Delete this reply?')) return;
              deleteReply(comment.id, reply.id);
            });
            rightTop.appendChild(delR);
          }

          topRow.appendChild(authorDiv);
          topRow.appendChild(rightTop);

          const replyText = document.createElement('div');
          replyText.style.marginTop = '6px';
          replyText.innerHTML = escapeHtml(reply.text);

          const replyActions = document.createElement('div');
          replyActions.style.marginTop = '8px';
          replyActions.style.display = 'flex';
          replyActions.style.gap = '8px';
          replyActions.innerHTML = `<button class="btn-action like-reply">👍 <span class="cnt">${reply.likes || 0}</span></button>
                                    <button class="btn-action dislike-reply">👎 <span class="cnt">${reply.dislikes || 0}</span></button>`;

          r.appendChild(topRow);
          r.appendChild(replyText);
          r.appendChild(replyActions);

          replyActions.querySelector('.like-reply').addEventListener('click', ()=> toggleReplyVote(comment.id, reply.id, 'like'));
          replyActions.querySelector('.dislike-reply').addEventListener('click', ()=> toggleReplyVote(comment.id, reply.id, 'dislike'));

          replyList.appendChild(r);
        });

        card.appendChild(replyList);

        actions.querySelector('.like-comment').addEventListener('click', ()=> toggleCommentVote(comment.id, 'like'));
        actions.querySelector('.dislike-comment').addEventListener('click', ()=> toggleCommentVote(comment.id, 'dislike'));

        actions.querySelector('.reply-open').addEventListener('click', ()=> {
          currentReplyTo = comment.id;
          updateReplyModeIndicator();
          const ta = document.getElementById('previewCommentTextArea');
          if(ta) ta.focus();
        });

        actions.querySelector('.replies-toggle').addEventListener('click', ()=> {
          if(expandedReplies.has(comment.id)) expandedReplies.delete(comment.id);
          else expandedReplies.add(comment.id);
          renderComments();
        });

        list.appendChild(card);
      });

      updateReplyModeIndicator();
    }

    function toggleCommentVote(commentId, mode){
      const obj = loadCommentsObj();
      const comments = obj[commentsKey].comments || [];
      const c = comments.find(x => x.id === commentId);
      if(!c) return;
      if(mode === 'like') c.likes = (c.likes || 0) + 1;
      else c.dislikes = (c.dislikes || 0) + 1;
      saveCommentsObj(obj);
      renderComments();
    }

    function toggleReplyVote(commentId, replyId, mode){
      const obj = loadCommentsObj();
      const comments = obj[commentsKey].comments || [];
      const c = comments.find(x => x.id === commentId);
      if(!c) return;
      const r = (c.replies || []).find(rr => rr.id === replyId);
      if(!r) return;
      if(mode === 'like') r.likes = (r.likes || 0) + 1;
      else r.dislikes = (r.dislikes || 0) + 1;
      saveCommentsObj(obj);
      renderComments();
    }

    function deleteComment(commentId){
      const obj = loadCommentsObj();
      obj[commentsKey].comments = (obj[commentsKey].comments || []).filter(c => c.id !== commentId);
      saveCommentsObj(obj);
      expandedReplies.delete(commentId);
      renderComments();
    }

    function deleteReply(commentId, replyId){
      const obj = loadCommentsObj();
      const c = (obj[commentsKey].comments || []).find(x => x.id === commentId);
      if(!c) return;
      c.replies = (c.replies || []).filter(r => r.id !== replyId);
      saveCommentsObj(obj);
      renderComments();
    }
  })();

  // optional: remove listeners when preview closed to avoid leaks
  const observer = new MutationObserver((mutations)=>{
    if(previewFull.classList.contains('hidden')){
      try{
        document.removeEventListener('click', closeShareMenuOnClick);
        document.removeEventListener('keydown', closeShareMenuOnEsc);
      }catch(_){}
      const menu = document.getElementById('story-preview-share-menu');
      if(menu) menu.style.display = 'none';
      const cp = document.getElementById('previewCommentsFull');
      if(cp) cp.remove();

      // cleanup previewStory param (in case user closed by other means)
      try {
        const u = new URL(window.location.href);
        u.searchParams.delete('previewStory');
        history.replaceState(null, '', u.pathname + u.search + u.hash);
      } catch(e) {}
      observer.disconnect();
    }
  });
  observer.observe(previewFull, { attributes: true, attributeFilter: ['class'] });

  // small helper declarations used above (ensure they exist in scope for cleanup)
  function closeShareMenuOnClick(e){ if(!document.getElementById('story-preview-share-menu')) return; const menu = document.getElementById('story-preview-share-menu'); const btn = inner.querySelector('#previewShareBtn'); if(menu && !menu.contains(e.target) && e.target !== btn) { menu.style.display = 'none'; if(btn) btn.setAttribute('aria-expanded', 'false'); } }
  function closeShareMenuOnEsc(e){ const menu = document.getElementById('story-preview-share-menu'); const btn = inner.querySelector('#previewShareBtn'); if(e.key === 'Escape' && menu) { menu.style.display = 'none'; if(btn) btn.setAttribute('aria-expanded', 'false'); } }
}

// Auto-open preview if URL contains ?previewStory=...
(function autoOpenPreviewFromUrl(){
  try {
    const params = new URLSearchParams(window.location.search);
    const t = params.get('previewStory');
    if (!t) return;
    // find story by title (case-sensitive match like your other code)
    if (Array.isArray(storiesData)) {
      const s = storiesData.find(x => x && x.title === t);
      if (s && typeof openPreviewFullScreen === 'function') {
        // small timeout to ensure UI is ready
        setTimeout(()=> openPreviewFullScreen(s), 80);
      }
    }
  } catch(e) { /* ignore */ }
})();
	
    // ---------- Fullscreen Reader ----------
function openReaderFullScreen(story) {
  const readerFull = document.getElementById('readerFull');
  readerFull.innerHTML = '';

  const panel = document.createElement('div');
  panel.className = 'reader-full';
  panel.style.position = 'fixed';
  panel.style.top = 0;
  panel.style.left = 0;
  panel.style.width = '100vw';
  panel.style.height = '100vh';
  panel.style.background = '#f7f7fb';
  panel.style.zIndex = 1200;
  panel.style.display = 'flex';
  panel.style.flexDirection = 'column';

  // --- HEADER ---
  const header = document.createElement('div');
  header.className = 'reader-header';
  header.style.display = 'flex';
  header.style.justifyContent = 'space-between';
  header.style.alignItems = 'center';
  header.style.padding = '12px 18px';
  header.style.background = '#fff';

  const profileRaw = localStorage.getItem(STORAGE_KEY);
  let author = '—';
  if (profileRaw) {
    try { author = JSON.parse(profileRaw).name || '—'; } catch (e) {}
  }
  const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];

  header.innerHTML = `
    <div>
      <strong>${story.title}</strong>
      <div class="muted" style="font-size:12px">${story.genre || '—'} • Written by ${author} • ${dateStr}</div>
    </div>
    <div>
      <button id="readerCloseFullBtn" class="btn btn-secondary">Close</button>
    </div>
  `;
  panel.appendChild(header);

  // --- BODY ---
  const body = document.createElement('div');
  body.className = 'reader-body';
  body.style.flex = 1;
  body.style.overflowY = 'auto';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.justifyContent = 'flex-start';
  body.style.padding = '12px';

  const sheet = document.createElement('div');
  sheet.className = 'reader-sheet';
  sheet.style.position = 'relative';
  sheet.style.width = '100%';
  sheet.style.maxWidth = '880px';
  sheet.style.minHeight = '400px';
  sheet.style.padding = '20px';
  sheet.style.background = '#fffef9';
  sheet.style.border = '1px solid #e5d7b7';
  sheet.style.borderRadius = '12px';
  sheet.style.boxShadow = '0 8px 16px rgba(0,0,0,0.1)';
  sheet.style.fontFamily = `'Georgia', 'Times New Roman', serif`;
  sheet.style.fontSize = '16px';
  sheet.style.lineHeight = '1.6';
  sheet.style.color = '#2e2b23';
  sheet.style.textAlign = 'justify';
  sheet.style.letterSpacing = '0.3px';
  sheet.style.whiteSpace = 'pre-wrap';
  sheet.style.overflowWrap = 'break-word';
  body.appendChild(sheet);

  // --- CANVAS ---
  const canvas = document.createElement('canvas');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.pointerEvents = 'none';
  sheet.appendChild(canvas);

  // --- CONTROLS ---
  const controls = document.createElement('div');
  controls.className = 'reader-controls';
  controls.style.display = 'flex';
  controls.style.flexWrap = 'wrap';
  controls.style.gap = '6px';
  controls.style.marginTop = '12px';
  controls.innerHTML = `
    <button id="prevFullBtn" class="btn btn-secondary">◀ Prev</button>
    <button id="startFullBtn" class="btn btn-primary">Start</button>
    <button id="nextFullBtn" class="btn btn-secondary">Next ▶</button>
    <button id="markBtn" class="btn btn-warning">✏️ Mark Last Read</button>
    <button id="removeMarkBtn" class="btn btn-danger" style="display:none;">🗑️ Remove Last Mark</button>
  `;
  body.appendChild(controls);
  panel.appendChild(body);
  readerFull.appendChild(panel);
  readerFull.classList.remove('hidden');

  const sheets = story.sheets || [{ content: '' }];
  let idx = 0;
  const savedKey = `lastReadMark_${story.id || story.title}`;

  // --- CANVAS CONTEXT ---
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  let drawing = false;
  let lastX = 0, lastY = 0;

  function enableDrawing(canvas, context) {
    // Desktop
    canvas.addEventListener('mousedown', e => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    });
    canvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      context.beginPath();
      context.moveTo(lastX, lastY);
      context.lineTo(x, y);
      context.stroke();
      lastX = x;
      lastY = y;
    });
    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseout', () => drawing = false);

    // Mobile / Touch
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.touches[0].clientX - rect.left;
      lastY = e.touches[0].clientY - rect.top;
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      context.beginPath();
      context.moveTo(lastX, lastY);
      context.lineTo(x, y);
      context.stroke();
      lastX = x;
      lastY = y;
    }, { passive: false });

    canvas.addEventListener('touchend', () => drawing = false);
    canvas.addEventListener('touchcancel', () => drawing = false);
  }

  // --- LOAD MARK ---
  function loadMark() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const imgData = localStorage.getItem(`${savedKey}_${idx}`);
    if (imgData) {
      const img = new Image();
      img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      img.src = imgData;
      removeMarkBtn.style.display = 'inline-block';
    } else {
      removeMarkBtn.style.display = 'none';
    }
  }

  const markBtn = document.getElementById('markBtn');
  const removeMarkBtn = document.getElementById('removeMarkBtn');
  const startBtn = document.getElementById('startFullBtn');

  // --- INITIAL LOAD ---
  sheet.textContent = sheets[idx].content || '';
  loadMark();

  // --- EVENT LISTENERS ---
  markBtn.addEventListener('click', () => {
    canvas.style.pointerEvents = 'auto';
    enableDrawing(canvas, ctx);
  });

  removeMarkBtn.addEventListener('click', () => {
    canvas.style.pointerEvents = 'none';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    localStorage.removeItem(`${savedKey}_${idx}`);
    removeMarkBtn.style.display = 'none';
  });

  startBtn.addEventListener('click', () => {
    if (canvas) {
      localStorage.setItem(`${savedKey}_${idx}`, canvas.toDataURL());
      canvas.style.pointerEvents = 'none';
      removeMarkBtn.style.display = 'inline-block';
    }
  });

  document.getElementById('prevFullBtn').addEventListener('click', () => {
    if (idx > 0) {
      idx--;
      sheet.textContent = sheets[idx].content || '';
      loadMark();
    }
  });

  document.getElementById('nextFullBtn').addEventListener('click', () => {
    if (idx < sheets.length - 1) {
      idx++;
      sheet.textContent = sheets[idx].content || '';
      loadMark();
    }
  });

  document.getElementById('readerCloseFullBtn').addEventListener('click', () => {
    readerFull.classList.add('hidden');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
}
    
// --- Fix: Show only one section (stories or serials) and highlight active tab ---
function setDashboardTabHighlight(type) {
  const storiesBtn = document.getElementById('showStoriesBtn');
  const serialsBtn = document.getElementById('showSerialsBtn');

  if (type === 'stories') {
    storiesBtn.classList.add('btn-primary');
    storiesBtn.classList.remove('btn-secondary');
    serialsBtn.classList.add('btn-secondary');
    serialsBtn.classList.remove('btn-primary');
  } else {
    serialsBtn.classList.add('btn-primary');
    serialsBtn.classList.remove('btn-secondary');
    storiesBtn.classList.add('btn-secondary');
    storiesBtn.classList.remove('btn-primary');
  }
}

document.getElementById('showStoriesBtn').addEventListener('click', () => {
  showDashboard('stories');
  setDashboardTabHighlight('stories');
});

document.getElementById('showSerialsBtn').addEventListener('click', () => {
  showDashboard('serials');
  setDashboardTabHighlight('serials');
});

const oldShowDashboard = showDashboard;
showDashboard = function(type = 'stories', genreFilter = 'All') {
  oldShowDashboard(type, genreFilter);
  setDashboardTabHighlight(type);
};

</script>

<!-- START: SERIALS EXTENSION INJECTION -->
<script>
// Saved serials storage key
const SAVED_SERIALS_KEY = 'savedSerials_v1';

// Utility: load/save serials from localStorage
function loadSavedSerials(){
  try{ const raw = localStorage.getItem(SAVED_SERIALS_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ console.warn(e); return []; }
}
function saveSavedSerials(arr){ try{ localStorage.setItem(SAVED_SERIALS_KEY, JSON.stringify(arr)); }catch(e){ console.warn(e); } }

// Ensure serialsData syncs to savedSerials periodically and on key events
function syncSerialsToStorage(){
  try{
    const current = loadSavedSerials();
    // merge serialsData into saved (by title)
    (serialsData || []).forEach(s => {
      if(!s || !s.title) return;
      const existing = current.find(x => x.title === s.title);
      if(existing){
        // update existing
        existing.genre = s.genre || existing.genre;
        existing.description = s.description || existing.description;
        existing.episodes = s.episodes || existing.episodes || [];
      } else {
        current.push(JSON.parse(JSON.stringify(s)));
      }
    });
    saveSavedSerials(current);
      }catch(e){ console.warn(e); }
}
// call periodically as a safety net
setInterval(syncSerialsToStorage, 1500);

// Hook some UI actions that already exist to call sync after create/update
try{
  // when serial create popup confirms
  const origSerialCreateConfirm = window.serialCreateConfirmBtn;
}catch(e){ /* ignore if not accessible */ }

// expose a function to render serials browse listing
const ALGO_CONFIG = {
  popularityWeight: 0.5,
  recencyWeight: 0.25,
  noveltyWeight: 0.25,
  randomWeight: 0.1,
  freshDaysBoost: 21,
  freshBoostMultiplier: 1.4,
  explorationFraction: 0.25,
  cardsPerViewport: 6,
  trending: {
    addThreshold: 50,
    keepThreshold: 100,
    dropThreshold: 40,
    expireDays: 7
  },
  recentlyReadLimit: 50
};

// LocalStorage keys
const SERIAL_READS_KEY = 'serial_reads_v1';
const TRENDING_STATE_KEY = 'trending_serials_v1';
const RECENTLY_READ_KEY = 'recently_read_v1';

// ---------------- SESSION SEED / PRNG ----------------
(function initSessionSeed() {
  if (window.__SERIALS_RENDER_SEED) return;
  let extra = 0;
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    extra = arr[0];
  } else {
    extra = Math.floor(Math.random() * 0xffffffff);
  }
  window.__SERIALS_RENDER_SEED = ((Date.now() & 0xffffffff) ^ extra) >>> 0;
})();

function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r = r + Math.imul(r ^ (r >>> 7), 61 | r) ^ r;
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function rngForThisRender() { return mulberry32(window.__SERIALS_RENDER_SEED); }

// ---------------- UTILITIES ----------------
function daysSince(dateString) {
  if (!dateString) return Number.MAX_SAFE_INTEGER;
  const d = new Date(dateString);
  if (isNaN(d)) return Number.MAX_SAFE_INTEGER;
  return Math.floor((Date.now() - d.getTime()) / (1000 * 60 * 60 * 24));
}
function normalizeArray(values) {
  const clean = values.map(v => Number.isFinite(v) ? v : 0);
  const min = Math.min(...clean);
  const max = Math.max(...clean);
  return max === min ? clean.map(() => 0.5) : clean.map(v => (v - min) / (max - min));
}
function shuffleArray(arr, rng = Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor((rng ? rng() : Math.random()) * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function computePopularityMetric(s) {
  const reads = Number(s.reads ?? s.readCount ?? 0);
  const likes = Number(s.likes ?? 0);
  return Math.log1p(reads) + 1.5 * Math.log1p(likes);
}

// ---------------- TRENDING state helpers ----------------
function loadTrendingState() {
  try {
    const raw = localStorage.getItem(TRENDING_STATE_KEY);
    return raw ? JSON.parse(raw) : { ids: {}, lastUpdated: Date.now() };
  } catch (e) { return { ids: {}, lastUpdated: Date.now() }; }
}
function saveTrendingState(state) {
  try { localStorage.setItem(TRENDING_STATE_KEY, JSON.stringify(state)); } catch (e) {}
}

function getRecentReadsForSerial(s) {
  const candidates = [ s.recentReads, s.readsLast24h, s.readsToday, s.readsLastDay, s.dailyReads ];
  for (let c of candidates) if (Number.isFinite(c)) return Number(c);
  if (Number.isFinite(s.readCount) && Number.isFinite(s.prevReadCount)) {
    return Math.max(0, Number(s.readCount) - Number(s.prevReadCount));
  }
  return undefined;
}

function updateTrendingStateForSerials(serials) {
  const state = loadTrendingState();
  const now = Date.now();
  const cfg = ALGO_CONFIG.trending;
  serials.forEach(s => {
    const id = s.id ?? s.slug ?? s.title;
    if (!id) return;
    const recent = getRecentReadsForSerial(s);
    const currentlyTrending = !!state.ids[id];

    if (Number.isFinite(recent)) {
      if (recent >= cfg.keepThreshold) {
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (recent >= cfg.addThreshold) {
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (currentlyTrending && recent < cfg.dropThreshold) {
        delete state.ids[id];
      } else if (currentlyTrending) {
        state.ids[id] = { ...state.ids[id], lastSeen: now, recent };
      }
    } else {
      if (currentlyTrending) {
        const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
        const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
        if (cfg.expireDays && daysSinceSeen > cfg.expireDays) delete state.ids[id];
      }
    }
  });

  // prune stale ids not in current list if expired
  const presentIds = new Set(serials.map(s => s.id ?? s.slug ?? s.title));
  Object.keys(state.ids).forEach(id => {
    if (!presentIds.has(id)) {
      const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
      const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
      if (ALGO_CONFIG.trending.expireDays && daysSinceSeen > ALGO_CONFIG.trending.expireDays) {
        delete state.ids[id];
      }
    }
  });

  state.lastUpdated = now;
  saveTrendingState(state);
  return state;
}
function getTrendingSerialsFromState(serials, state) {
  const ids = new Set(Object.keys(state.ids || {}));
  return serials.filter(s => {
    const id = s.id ?? s.slug ?? s.title;
    return id && ids.has(id);
  });
}

// ---------------- RECENTLY READ helpers ----------------
function recordRecentlyRead(serial) {
  try {
    const raw = localStorage.getItem(RECENTLY_READ_KEY);
    let arr = raw ? JSON.parse(raw) : [];
    const id = serial.id ?? serial.slug ?? serial.title;
    const entry = {
      id,
      title: serial.title || 'Untitled',
      cover: serial.cover || null,
      genre: serial.genre || null,
      description: serial.description || null,
      at: Date.now()
    };
    arr = arr.filter(x => x.id !== id);
    arr.unshift(entry);
    const limit = Number.isFinite(ALGO_CONFIG.recentlyReadLimit) ? ALGO_CONFIG.recentlyReadLimit : 50;
    if (arr.length > limit) arr = arr.slice(0, limit);
    localStorage.setItem(RECENTLY_READ_KEY, JSON.stringify(arr));
  } catch (e) {}
}
function loadRecentlyRead() {
  try {
    const raw = localStorage.getItem(RECENTLY_READ_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}

// Safe open + record
function openSerialPreviewAndRecord(serial) {
  try { recordRecentlyRead(serial); } catch (e) {}
  if (typeof openSerialPreview === 'function') {
    if (serial.id) openSerialPreview(serial.id);
    else if (serial.slug) openSerialPreview(serial.slug);
    else openSerialPreview(serial.title || '');
  } else {
    console.warn('openSerialPreview not defined');
  }
}

// ---------------- SCORING / EXPLORATION ----------------
function scoredSerialsWithNormalization(serials, rng) {
  rng = rng || Math.random;
  const popArr = serials.map(computePopularityMetric);
  const ageArr = serials.map(s => {
    const ds = daysSince(s.published || s.createdAt || s.date || s.uploadedAt);
    return Math.max(0, 365 - Math.min(ds, 365));
  });
  const popNorm = normalizeArray(popArr);
  const recNorm = normalizeArray(ageArr);

  return serials.map((s, i) => {
    const pop = popNorm[i];
    const rec = recNorm[i];
    const novelty = Math.max(0.2, 1 - pop);
    const randomEps = (rng ? rng() : Math.random()) * ALGO_CONFIG.randomWeight;
    let score = ALGO_CONFIG.popularityWeight * pop
              + ALGO_CONFIG.recencyWeight * rec
              + ALGO_CONFIG.noveltyWeight * novelty
              + randomEps;
    const ageDays = daysSince(s.published || s.createdAt || s.date || s.uploadedAt);
    if (ageDays <= ALGO_CONFIG.freshDaysBoost) score *= ALGO_CONFIG.freshBoostMultiplier;
    return Object.assign({}, s, { __score: score, __popNorm: pop, __recNorm: rec, __novelty: novelty, __ageDays: ageDays });
  });
}

function pickExploration(candidates, count, rng) {
  if (!candidates || candidates.length === 0 || count <= 0) return [];
  rng = rng || Math.random;
  const scored = candidates.map(s => {
    const novelty = s.__novelty ?? 0.5;
    const recency = s.__recNorm ?? 0.5;
    return Object.assign({}, s, { __exploreScore: novelty*0.6 + recency*0.4 + (rng ? rng() : Math.random())*0.1 });
  });
  scored.sort((a,b) => b.__exploreScore - a.__exploreScore);
  return shuffleArray(scored.slice(0, Math.min(count, scored.length)), rng);
}

// ---------------- DEMO generator ----------------
function generateDemoSerials(count = 0, rng) {
  rng = rng || rngForThisRender();
  const genres = ["Action","Romance","Comedy","Fantasy","Horror","Tragedy","Tragic","Thriller","Adventure","Crime","Historic"];
  const covers = [
    "https://picsum.photos/seed/demo1/600/900",
    "https://picsum.photos/seed/demo2/600/900",
    "https://picsum.photos/seed/demo3/600/900",
    "https://picsum.photos/seed/demo4/600/900",
    "https://picsum.photos/seed/demo5/600/900",
    "https://picsum.photos/seed/demo6/600/900"
  ];
  const serials = [];
  for (let i=0;i<count;i++){
    const genre = genres[Math.floor(rng()*genres.length)];
    const title = `${genre} Demo Serial ${i+1}`;
    const readCount = Math.floor(rng()*1000);
    const likes = Math.floor(rng()*400);
    const daysAgo = Math.floor(rng()*400);
    const date = new Date(Date.now()-daysAgo*86400000).toISOString();
    serials.push({
      id:`demo-${i+1}`,
      title, genre, description:`Demo ${genre.toLowerCase()} serial — random readCount ${readCount}.`,
      cover: covers[i % covers.length], readCount, reads: readCount, likes, createdAt: date
    });
  }
  return serials;
}

// ---------------- RENDER HELPERS (card creators) ----------------
function createSerialCard(s, imagesToWait, allSerials) {
  const card = document.createElement('div');
  card.className = 'serial-card';
  card.dataset.title = s.title || '';
  card.style.minWidth = '300px';
  card.style.height = '400px';
  card.style.flex = '0 0 auto';
  card.style.borderRadius = '16px';
  card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.15)';
  card.style.padding = '16px';
  card.style.display = 'flex';
  card.style.flexDirection = 'column';
  card.style.justifyContent = 'space-between';
  card.style.position = 'relative';
  card.style.transition = 'transform 0.25s ease, box-shadow 0.25s ease';
  card.style.overflow = 'hidden';
  card.style.cursor = 'pointer';
  card.style.scrollSnapAlign = 'center';

  if (s.cover) {
    const img = new Image();
    img.src = s.cover;
    img.alt = s.title || 'cover';
    imagesToWait.push(new Promise(resolve => {
      if (img.complete) return resolve();
      img.onload = img.onerror = () => resolve();
    }));
    card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.45),rgba(0,0,0,0.45)),url(${s.cover})`;
    card.style.backgroundSize = 'cover';
    card.style.backgroundPosition = 'center';
    card.style.color = '#fff';
  } else {
    card.style.background = '#fff';
    card.style.color = '#000';
  }

  // Hover / touch scale
  const scaleUp = () => { card.style.transform = 'scale(1.08)'; card.style.zIndex = '2'; card.style.boxShadow = '0 12px 24px rgba(0,0,0,0.3)'; };
  const scaleDown = () => { card.style.transform = 'scale(1)'; card.style.zIndex = '1'; card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.15)'; };
  card.addEventListener('mouseenter', scaleUp);
  card.addEventListener('mouseleave', scaleDown);
  card.addEventListener('touchstart', scaleUp);
  card.addEventListener('touchend', scaleDown);
  card.addEventListener('touchcancel', scaleDown);

  // Info
  const infoDiv = document.createElement('div');
  infoDiv.innerHTML = `<h4 style="margin:0;font-size:17px;text-shadow:1px 1px 3px rgba(0,0,0,0.6)">${s.title || 'Untitled Series'}</h4>
    <p style="margin:6px 0 0;font-size:13px;color:inherit;opacity:0.9;overflow:hidden;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;line-height:1.4;text-shadow:1px 1px 2px rgba(0,0,0,0.4)">${s.description || ''}</p>`;

  // readCount badge
  if (typeof s.readCount !== 'undefined' || typeof s.reads !== 'undefined') {
    const rc = document.createElement('div');
    rc.style.position = 'absolute';
    rc.style.right = '12px';
    rc.style.top = '12px';
    rc.style.background = 'rgba(255,255,255,0.85)';
    rc.style.padding = '6px 8px';
    rc.style.borderRadius = '12px';
    rc.style.fontSize = '12px';
    rc.style.color = '#222';
    rc.textContent = `reads ${Number(s.readCount ?? s.reads ?? 0).toLocaleString()}`;
    card.appendChild(rc);
  }

  // Buttons
  const bottomDiv = document.createElement('div');
  bottomDiv.style.display = 'flex';
  bottomDiv.style.justifyContent = 'flex-end';
  bottomDiv.style.gap = '8px';
  bottomDiv.style.marginTop = '10px';
  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn btn-secondary view-serial-btn';
  viewBtn.textContent = '🎬 View';
  viewBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    // prefer full object open
    openSerialPreviewAndRecord(s);
  });
  bottomDiv.appendChild(viewBtn);

  // Click on card opens preview too
  card.addEventListener('click', () => openSerialPreviewAndRecord(s));

  card.appendChild(infoDiv);
  card.appendChild(bottomDiv);
  return card;
}

function createRecentCard(r, allSerials) {
  const card = document.createElement('div');
  card.className = 'recent-card serial-card';
  card.style.minWidth = '260px';
  card.style.flex = '0 0 auto';
  card.style.borderRadius = '14px';
  card.style.padding = '14px';
  card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)';
  card.style.display = 'flex';
  card.style.flexDirection = 'column';
  card.style.justifyContent = 'space-between';
  card.style.cursor = 'pointer';
  card.style.position = 'relative';
  card.style.flexShrink = '0';
  card.style.backfaceVisibility = 'hidden';

  if (r.cover) {
    card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)),url(${r.cover})`;
    card.style.backgroundSize = 'cover';
    card.style.backgroundPosition = 'center';
    card.style.color = '#fff';
  } else {
    card.style.background = '#fff';
    card.style.color = '#000';
  }

  const titleDiv = document.createElement('h4');
  titleDiv.textContent = r.title || 'Untitled';
  titleDiv.style.margin = '0 0 6px';
  titleDiv.style.fontSize = '17px';
  titleDiv.style.fontWeight = '700';
  titleDiv.style.textShadow = r.cover ? '1px 1px 3px rgba(0,0,0,0.6)' : '';

  const genreDiv = document.createElement('div');
  genreDiv.textContent = r.genre || 'Unknown';
  genreDiv.style.margin = '0 0 6px';
  genreDiv.style.fontSize = '13px';
  genreDiv.style.fontWeight = '600';
  genreDiv.style.opacity = '0.9';

  const descDiv = document.createElement('p');
  descDiv.textContent = r.description || '';
  descDiv.style.margin = '4px 0 8px';
  descDiv.style.fontSize = '14px';
  descDiv.style.lineHeight = '1.4';
  descDiv.style.overflow = 'hidden';
  descDiv.style.display = '-webkit-box';
  descDiv.style.webkitLineClamp = '3';
  descDiv.style.webkitBoxOrient = 'vertical';

  const bottomRow = document.createElement('div');
  bottomRow.style.display = 'flex';
  bottomRow.style.justifyContent = 'flex-end';
  bottomRow.style.alignItems = 'center';
  bottomRow.style.marginTop = 'auto';

  const readBtn = document.createElement('button');
  readBtn.className = 'btn btn-primary';
  readBtn.textContent = 'Read';
  readBtn.addEventListener('click', e => {
    e.stopPropagation();
    // try find in list
    const found = allSerials.find(s => (s.id ?? s.slug ?? s.title) === r.id);
    if (found) openSerialPreviewAndRecord(found);
    else if (typeof openSerialPreview === 'function') openSerialPreview(r.title);
  });

  bottomRow.appendChild(readBtn);
  card.appendChild(titleDiv);
  card.appendChild(genreDiv);
  card.appendChild(descDiv);
  card.appendChild(bottomRow);

  card.addEventListener('click', () => {
    const found = allSerials.find(s => (s.id ?? s.slug ?? s.title) === r.id);
    if (found) openSerialPreviewAndRecord(found);
    else if (typeof openSerialPreview === 'function') openSerialPreview(r.title);
  });

  return card;
}

// ---------------- MAIN renderBrowseSerials (Full integration) ----------------

function renderBrowseSerials(list = null, opts = { includeDemo: false, demoCount: 0, mergeWithSaved: false }) {
  const rng = rngForThisRender();
  try {
    let container = document.getElementById('serialsBrowseList');
    if (!container) {
      const parent = document.getElementById('serialCategoriesPage') || document.body;
      container = document.createElement('div');
      container.id = 'serialsBrowseList';
      container.style.maxWidth = '980px';
      container.style.margin = '18px auto';
      parent.appendChild(container);
    }

    // --- Load base serials (prefer Firebase live data) ---
    let baseSerials = Array.isArray(list) ? list.slice() : null;
    if (!Array.isArray(baseSerials) || !baseSerials.length) {
      // Prefer real-time Firebase data if available
      if (Array.isArray(window.serialsData) && window.serialsData.length) {
        console.log(`📡 Using ${window.serialsData.length} serials from Firebase`);
        baseSerials = window.serialsData.slice();
      } else if (typeof loadSavedSerials === 'function') {
        try { baseSerials = loadSavedSerials() || []; } catch (e) { baseSerials = []; }
      } else {
        try { baseSerials = JSON.parse(localStorage.getItem('saved_serials_v1') || '[]') || []; } catch (e) { baseSerials = []; }
      }
    }
    if (!Array.isArray(baseSerials)) baseSerials = [];

    // --- Remove duplicates by id/title ---
    const seen = new Set();
    baseSerials = baseSerials.filter(s => {
      const key = (s.id || s.slug || s.title || '').trim().toLowerCase();
      if (!key || seen.has(key)) return false;
      seen.add(key);
      return true;
    });

    // --- Demo serials if needed ---
    const demo = (opts && opts.includeDemo) ? generateDemoSerials(opts.demoCount || 30, rng) : [];
    let serialsRaw = baseSerials.slice();
    if (demo.length > 0) {
      if (opts && opts.mergeWithSaved) serialsRaw = serialsRaw.concat(demo);
      else if (!serialsRaw.length) serialsRaw = demo.slice();
    }

    if (!serialsRaw || !serialsRaw.length) {
      container.style.display = 'none';
      console.warn('⚠️ No serials to display in Browse Serials');
      return;
    }

    container.innerHTML = '';
    container.style.display = 'block';

    // --- Group by genre ---
    const genresOrder = ['Action','Romance','Comedy','Fantasy','Horror','Tragic','Thriller','Adventure','Crime','Historic'];
    const grouped = {};
    serialsRaw.forEach(s => {
      const g = s.genre ? s.genre.trim() : 'Other';
      if (!grouped[g]) grouped[g] = [];
      grouped[g].push(s);
    });

    // --- Score serials ---
    const allScored = scoredSerialsWithNormalization(serialsRaw, rng);
    const scoredMap = new Map();
    allScored.forEach(s => {
      const key = s.id ?? s.slug ?? s.title;
      scoredMap.set(key, s);
    });

    const imagesToWait = [];

    // --- TRENDING SECTION ---
    const trendingState = updateTrendingStateForSerials(serialsRaw);
    const trendingSerials = getTrendingSerialsFromState(allScored, trendingState);
    if (trendingSerials && trendingSerials.length) {
      const trendingSection = document.createElement('div');
      trendingSection.dataset.genre = 'Trending';
      trendingSection.style.marginBottom = '28px';
      container.appendChild(trendingSection);

      const heading = document.createElement('h2');
      heading.textContent = '🔥 Trending';
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      trendingSection.appendChild(heading);

      const scrollWrap = document.createElement('div');
      scrollWrap.className = 'scroll-wrap trending-wrap';
      scrollWrap.style.display = 'flex';
      scrollWrap.style.overflowX = 'auto';
      scrollWrap.style.gap = '12px';
      scrollWrap.style.padding = '12px';
      scrollWrap.style.scrollBehavior = 'smooth';
      scrollWrap.style.scrollSnapType = 'x mandatory';
      scrollWrap.style.scrollbarWidth = 'thin';

      trendingSerials.forEach(s => {
        const card = createSerialCard(s, imagesToWait, serialsRaw);
        card.style.minWidth = '300px';
        card.style.height = '400px';
        scrollWrap.appendChild(card);
      });

      trendingSection.appendChild(scrollWrap);
      container.__trendingIds = new Set(trendingSerials.map(s => s.id ?? s.slug ?? s.title));
    } else {
      container.__trendingIds = new Set();
    }

    // --- GENRE SECTIONS ---
    genresOrder.forEach(genre => {
      const list = grouped[genre];
      if (!list || !list.length) return;

      const trendingIds = container.__trendingIds || new Set();
      const filtered = list.filter(s => !trendingIds.has(s.id ?? s.slug ?? s.title));
      if (!filtered.length) return;

      const scoredList = filtered.map(s => {
        const key = s.id ?? s.slug ?? s.title;
        return scoredMap.get(key) || Object.assign({}, s, { __score: rng() * 0.2 });
      });
      const sorted = scoredList.slice().sort((a, b) => (b.__score || 0) - (a.__score || 0));

      const section = document.createElement('div');
      section.dataset.genre = genre;
      section.style.marginBottom = '32px';

      const heading = document.createElement('h3');
      heading.textContent = genre;
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      section.appendChild(heading);

      const scrollWrap = document.createElement('div');
      scrollWrap.className = 'scroll-wrap';
      scrollWrap.style.display = 'flex';
      scrollWrap.style.overflowX = 'auto';
      scrollWrap.style.gap = '12px';
      scrollWrap.style.padding = '12px';
      scrollWrap.style.scrollBehavior = 'smooth';
      scrollWrap.style.scrollSnapType = 'x mandatory';
      scrollWrap.style.scrollbarWidth = 'thin';
      section.appendChild(scrollWrap);

      sorted.forEach(s => {
        const card = createSerialCard(s, imagesToWait, serialsRaw);
        scrollWrap.appendChild(card);
      });

      container.appendChild(section);
    });

    console.log(`✅ Rendered ${serialsRaw.length} serials in Browse Serials`);
  } catch (e) {
    console.warn('renderBrowseSerials error:', e);
  }
}
async function openSerialPreview(input) {
  try {
    const { db, ref, get, set } = window._firebase || {};
    if (!db || !ref || !get) {
      alert("Firebase not ready yet.");
      return;
    }

    // --- Resolve serial title ---
    const title = typeof input === "string"
      ? input.trim()
      : (input && (input.key || input.title || "")).trim();

    if (!title) {
      alert("Serial not found (no title).");
      return;
    }

    // --- Fetch serial data ---
    let serialData =
      typeof input === "object" && input.title ? input : null;

    if (!serialData) {
      const snap = await get(ref(db, "serials"));
      if (snap.exists()) {
        const all = snap.val();
        for (const [key, obj] of Object.entries(all)) {
          if ((obj.title || "").trim().toLowerCase() === title.toLowerCase()) {
            serialData = obj;
            break;
          }
        }
      }
    }

    if (!serialData) {
      alert(`Serial "${title}" not found in Firebase.`);
      return;
    }

    // --- Ensure fields exist ---
    serialData.likes = serialData.likes || 0;
    serialData.dislikes = serialData.dislikes || 0;

    // --- Calculate total reads ---
    const totalReads = (serialData.episodes || []).reduce(
      (sum, ep) => sum + (ep.reads || 0),
      0
    );

    // --- Load user vote state ---
    const votes = JSON.parse(localStorage.getItem("user_votes_serials") || "{}");
    let userVote = votes[serialData.title] || null;

    // --- Create container ---
    let preview = document.getElementById("previewFull");
    if (!preview) {
      preview = document.createElement("div");
      preview.id = "previewFull";
      document.body.appendChild(preview);
    }

    // --- UI Template ---
    preview.innerHTML = `
      <style>
#previewFull {
  position: fixed;
  inset: 0;
  background: #f7f8fb;
  z-index: 9999;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: opacity 0.3s ease;
  opacity: 0;
  overflow: auto;
  padding: 40px 20px;
}
#previewFull.show { opacity: 1; }
.fullscreen-panel {
  width: 100%;
  max-width: 900px;
  background: #ffffff;
  border-radius: 20px;
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  animation: fadeIn 0.4s ease both;
  margin: auto;
}
@keyframes fadeIn {
  from {opacity: 0; transform: scale(0.97);}
  to {opacity: 1; transform: scale(1);}
}
.panel-top {
  background: linear-gradient(135deg, #5b7cff, #00b4d8);
  color: white;
  padding: 22px 28px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.panel-top h2 { margin: 0; font-size: 1.8rem; }
.panel-meta {
  padding: 16px 28px;
  font-size: 14px;
  color: #444;
  border-bottom: 1px solid #eee;
  background: #fafafa;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.meta-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
}
.vote-bar {
  display: flex;
  align-items: center;
  gap: 12px;
}
.vote-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  border-radius: 999px;
  border: none;
  background: #f1f1f1;
  color: #606060;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.vote-btn:hover {
  background: #e5e5e5;
  transform: translateY(-1px);
}
.vote-btn svg {
  width: 22px;
  height: 22px;
  transition: transform 0.25s ease, color 0.25s ease;
}
.vote-btn.active.like {
  background: #e6f0ff;
  color: #1976d2;
}
.vote-btn.active.like svg path {
  fill: #1976d2;
}
.vote-btn.active.dislike {
  background: #ffebee;
  color: #d32f2f;
}
.vote-btn.active.dislike svg path {
  fill: #d32f2f;
}
.vote-btn:active {
  transform: scale(0.93);
}
.vote-count {
  font-weight: 500;
  font-size: 0.9rem;
  color: inherit;
}
.share-menu {
  position: absolute;
  z-index: 99999;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 12px;
  box-shadow: 0 5px 25px rgba(0,0,0,0.1);
  padding: 10px;
}
.share-option {
  padding: 8px 12px;
  background: none;
  border: none;
  text-align: left;
  width: 100%;
  font-size: 14px;
  cursor: pointer;
  border-radius: 8px;
  transition: background 0.2s ease;
}
.share-option:hover { background: #f5f5f5; }
.episodes-scroll {
  flex: 1;
  overflow-y: auto;
  padding: 28px;
  background: #f9fafc;
  display: flex;
  justify-content: center;
}
.episodes-list {
  width: 100%;
  max-width: 800px;
  display: flex;
  flex-direction: column;
  gap: 18px;
  align-items: center;
}
.episode-card {
  width: 100%;
  background: #ffffff;
  border: 1px solid #e6e9f2;
  border-radius: 14px;
  padding: 20px 22px;
  box-shadow: 0 5px 14px rgba(0, 0, 0, 0.05);
  transition: transform 0.25s ease, box-shadow 0.25s ease;
  display: flex;
  flex-direction: column;
  text-align: left;
}
.episode-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
}
.episode-card h3 { margin: 0 0 6px; font-size: 1.1rem; color: #2b2b2b; }
.episode-card p { font-size: 0.9rem; color: #666; margin-bottom: 14px; }
.episode-card button { align-self: flex-end; }
      </style>

      <div class="fullscreen-panel">
        <div class="panel-top">
          <h2>${serialData.title}</h2>
          <button class="btn btn-secondary" id="closePreviewBtn">✕ Close</button>
        </div>

        <div class="panel-meta">
          <div class="meta-row">
            <div>
              <b>Genre:</b> ${serialData.genre || "N/A"} &nbsp; • &nbsp;
              <b>Episodes:</b> ${(serialData.episodes || []).length} &nbsp; • &nbsp;
              <b>Reads:</b> ${totalReads}
            </div>
            <div class="vote-bar">
              <button class="vote-btn like ${userVote === "like" ? "active" : ""}" id="likeBtn">
                 <svg viewBox="0 0 24 24"><path d="M14 9V5a3 3 0 0 0-6 0v4H5v10h13l2-9h-6z" fill="currentColor"/></svg>
                <span id="likeCount">${serialData.likes}</span>
              </button>
              <button class="vote-btn dislike ${userVote === "dislike" ? "active" : ""}" id="dislikeBtn">
                   <svg viewBox="0 0 24 24"><path d="M10 15v4a3 3 0 0 0 6 0v-4h3V5H6l-2 9h6z" fill="currentColor"/></svg>
                <span id="dislikeCount">${serialData.dislikes}</span>
              </button>
              <button class="vote-btn" id="shareSerialBtn">🔗 Share</button>
            </div>
          </div>
        </div>

        <div class="episodes-scroll">
          <div class="episodes-list">
            ${(serialData.episodes || [])
              .map(
                (ep, i) => `
                <div class="episode-card">
                  <h3>${ep.title || "Untitled Episode"}</h3>
                  <p>${ep.description || "No description available."}</p>
                  <button class="btn btn-primary read-episode-btn" data-ep="${i}">
                    📖 Read Episode
                  </button>
                </div>`
              )
              .join("")}
          </div>
        </div>
      </div>
    `;

    preview.classList.remove("hidden");
    setTimeout(() => preview.classList.add("show"), 10);

    // --- Close preview ---
    document.getElementById("closePreviewBtn").onclick = () => {
      preview.classList.remove("show");
      setTimeout(() => preview.remove(), 300);
    };

    // --- Read episode ---
    preview.querySelectorAll(".read-episode-btn").forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        const epIndex = parseInt(e.currentTarget.dataset.ep, 10);
        const episode = serialData.episodes[epIndex];
        episode.reads = (episode.reads || 0) + 1;
        await set(ref(db, `serials/${encodeURIComponent(serialData.title)}`), serialData);
        preview.remove();
        if (typeof openSerialReader === "function") openSerialReader(serialData.title, epIndex);
      });
    });

    // --- Like / Dislike smart toggle ---
    const likeBtn = document.getElementById("likeBtn");
    const dislikeBtn = document.getElementById("dislikeBtn");
    const likeCount = document.getElementById("likeCount");
    const dislikeCount = document.getElementById("dislikeCount");

    async function saveVoteChange() {
      await set(ref(db, `serials/${encodeURIComponent(serialData.title)}`), serialData);
      localStorage.setItem("user_votes_serials", JSON.stringify(votes));
      likeCount.textContent = serialData.likes;
      dislikeCount.textContent = serialData.dislikes;
    }

    likeBtn.onclick = async () => {
      if (userVote === "like") {
        serialData.likes--;
        userVote = null;
        votes[serialData.title] = null;
        likeBtn.classList.remove("active");
      } else {
        if (userVote === "dislike") {
          serialData.dislikes--;
          dislikeBtn.classList.remove("active");
        }
        serialData.likes++;
        userVote = "like";
        votes[serialData.title] = "like";
        likeBtn.classList.add("active");
      }
      await saveVoteChange();
    };

    dislikeBtn.onclick = async () => {
      if (userVote === "dislike") {
        serialData.dislikes--;
        userVote = null;
        votes[serialData.title] = null;
        dislikeBtn.classList.remove("active");
      } else {
        if (userVote === "like") {
          serialData.likes--;
          likeBtn.classList.remove("active");
        }
        serialData.dislikes++;
        userVote = "dislike";
        votes[serialData.title] = "dislike";
        dislikeBtn.classList.add("active");
      }
      await saveVoteChange();
    };

    // --- SHARE BUTTON ---
    const existingMenu = document.getElementById("serial-preview-share-menu");
    if (existingMenu) existingMenu.remove();

    const shareMenu = document.createElement("div");
    shareMenu.id = "serial-preview-share-menu";
    shareMenu.className = "share-menu";
    shareMenu.style.display = "none";
    document.body.appendChild(shareMenu);

function getShareLink(platform) {
  const baseUrl = "https://meurbal.site"; // your live website
  const link = `${baseUrl}?previewSerial=${encodeURIComponent(serialData.title || "")}`;

  const message = `📖 ${serialData.title || "Untitled"}\nGenre: ${
    serialData.genre || "—"
  }\nDescription: ${
    serialData.description || "No description provided."
  }\nRead it on Meurbal: ${link}`;

  if (platform === "WhatsApp")
    return `https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`;
  if (platform === "Facebook")
    return `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(link)}`;
  if (platform === "Twitter")
    return `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
  if (platform === "Copy") return link;

  return link;
}


    [
      { name: "WhatsApp", emoji: "🟢" },
      { name: "Facebook", emoji: "🔵" },
      { name: "Twitter", emoji: "🐦" },
      { name: "Copy", emoji: "🔗" },
    ].forEach((opt) => {
      const btn = document.createElement("button");
      btn.className = "share-option";
      btn.innerHTML = `${opt.emoji} ${opt.name}`;
      btn.addEventListener("click", async (e) => {
        e.stopPropagation();
        const link = getShareLink(opt.name);
        if (opt.name === "Copy") {
          await navigator.clipboard.writeText(link);
          btn.textContent = "✅ Copied!";
          setTimeout(() => (btn.innerHTML = `${opt.emoji} ${opt.name}`), 1200);
        } else {
          window.open(link, "_blank");
        }
        shareMenu.style.display = "none";
      });
      shareMenu.appendChild(btn);
    });

    const shareBtn = document.getElementById("shareSerialBtn");
    shareBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const rect = shareBtn.getBoundingClientRect();
      shareMenu.style.top = rect.bottom + 8 + "px";
      shareMenu.style.left = rect.left + "px";
      shareMenu.style.display =
        shareMenu.style.display === "flex" ? "none" : "flex";
      shareMenu.style.flexDirection = "column";
    });

    document.addEventListener("click", (e) => {
      if (!shareMenu.contains(e.target) && e.target !== shareBtn) {
        shareMenu.style.display = "none";
      }
    });
// --- COMMENTS PANEL ---
const commentsBtn = document.createElement("button");
commentsBtn.className = "vote-btn";
commentsBtn.id = "commentsBtn";
commentsBtn.innerHTML = "💬 Comments";
document.querySelector(".vote-bar").appendChild(commentsBtn);

commentsBtn.addEventListener("click", async () => {
  // --- Create / open panel ---
  let panel = document.getElementById("commentsPanel");
  if (panel) panel.remove();

  panel = document.createElement("div");
  panel.id = "commentsPanel";
panel.innerHTML = `
  <style>
    #commentsPanel {
      position: fixed;
      inset: 0;
      background: #ffffff;
      z-index: 99999;
      display: flex;
      flex-direction: column;
      animation: fadeIn .25s ease both;
    }

    .comments-header {
      background: linear-gradient(135deg,#5b7cff,#00b4d8);
      padding: 16px 20px;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 18px;
      font-weight: 600;
    }

    #closeCommentsBtn {
      background:none;
      border:none;
      color:#fff;
      font-size:22px;
      cursor:pointer;
      padding:0;
    }

#commentsList {
  flex: 1;
  overflow-y: auto;
  padding: 10px 14px 80px;
  background: #f5f7fb;
}

/* COMMENT CARD LOOK */
.comment-item {
  background: #ffffff;
  border-radius: 14px;
  padding: 14px 16px;
  margin-bottom: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  animation: fadeUp 0.25s ease both;
}

@keyframes fadeUp {
  from { opacity: 0; transform: translateY(4px); }
  to   { opacity: 1; transform: translateY(0); }
}

.comment-user {
  font-weight: 700;
  color: #222;
  font-size: 15px;
  margin-bottom: 4px;
}

.comment-text {
  color: #333;
  font-size: 14px;
  line-height: 1.5;
  margin-bottom: 6px;
}

.comment-time {
  font-size: 12px;
  color: #8a8a8a;
}

.comment-actions {
  display: flex;
  gap: 12px;
  margin-top: 8px;
}

.comment-actions button {
  border: none;
  background: #eef2ff;
  padding: 6px 12px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: 0.2s;
}

.comment-actions button:hover {
  background: #d9e0ff;
}

.comment-actions button.active {
  background: #5b7cff;
  color: white;
}


    .comment-item b { color: #111; }
    .comment-item small { color:#888; display:block; margin-top:4px; font-size:12px; }

    .comment-input-area {
      padding: 12px 20px;
      border-top: 1px solid #ddd;
      background: #fafafa;
      display: flex;
    }

    .comment-input-area textarea {
      flex: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      resize: none;
      font-size: 14px;
    }

    .comment-input-area button {
      margin-left: 10px;
      padding: 10px 16px;
      border:none;
      background:#5b7cff;
      color:#fff;
      border-radius: 8px;
      font-weight: 600;
      cursor:pointer;
      transition: 0.2s;
    }
    .comment-input-area button:hover { background:#4967e0; }

    @keyframes fadeIn { from{opacity:0;} to{opacity:1;} }
  </style>

  <div class="comments-header">
    <span>${serialData.title} — <span id="commentsCount">0</span> Comments</span>
    <button id="closeCommentsBtn">✕</button>
  </div>

  <div id="commentsList">Loading comments...</div>

  <div class="comment-input-area">
    <textarea id="newCommentText" placeholder="Write a comment..." rows="2"></textarea>
    <button id="sendCommentBtn">Post</button>
  </div>
`;

  document.body.appendChild(panel);

  const commentsList = panel.querySelector("#commentsList");
  const closeBtn = panel.querySelector("#closeCommentsBtn");
  const sendBtn = panel.querySelector("#sendCommentBtn");
  const input = panel.querySelector("#newCommentText");

  closeBtn.onclick = () => panel.remove();

  // Firebase comment path
  const commentsRef = ref(db, `serial_comments/${encodeURIComponent(serialData.title)}/comments`);

async function loadComments() {
  try {
    const snap = await get(commentsRef);
    const countEl = document.getElementById("commentsCount");
    const username = localStorage.getItem("username") || "Guest";

    if (!snap.exists()) {
      commentsList.innerHTML = "<p>No comments yet. Be the first!</p>";
      countEl.textContent = "0";
      return;
    }

    const all = snap.val();
    const arr = Object.values(all).sort((a, b) => (a.ts || 0) - (b.ts || 0));
    countEl.textContent = arr.length;

    commentsList.innerHTML = arr.map(c => {
      const likes = c.likes ? Object.keys(c.likes).length : 0;
      const dislikes = c.dislikes ? Object.keys(c.dislikes).length : 0;

      const userLiked = c.likes && c.likes[username];
      const userDisliked = c.dislikes && c.dislikes[username];

      return `
        <div class="comment-item" data-id="${c.id}">
          <div class="comment-user">${c.user}</div>
          <div class="comment-text">${c.text}</div>
          <div class="comment-time">${new Date(c.ts).toLocaleString()}</div>

          <div class="comment-actions">
            <button class="like-btn ${userLiked ? "active" : ""}">
              <svg width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M14 9V5a3 3 0 0 0-6 0v4H5v10h13l2-9h-6z"/></svg>
              <span>${likes}</span>
            </button>

            <button class="dislike-btn ${userDisliked ? "active" : ""}">
              <svg width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M10 15v4a3 3 0 0 0 6 0v-4h3V5H6l-2 9h6z"/></svg>
              <span>${dislikes}</span>
            </button>
          </div>
        </div>
      `;
    }).join("");

    // Attach button handlers
    commentsList.querySelectorAll(".comment-item").forEach(item => {
      const id = item.dataset.id;
      item.querySelector(".like-btn").onclick = () => toggleReaction(id, "like");
      item.querySelector(".dislike-btn").onclick = () => toggleReaction(id, "dislike");
    });

  } catch (e) {
    commentsList.innerHTML = "<p>⚠️ Failed to load comments.</p>";
    console.error(e);
  }
}


// ✅ LIKE / DISLIKE TOGGLE SYSTEM
async function toggleReaction(commentId, type) {
  const user = localStorage.getItem("username") || "Guest";
  const commentRef = ref(db, `serial_comments/${encodeURIComponent(serialData.title)}/comments/${commentId}`);
  const snap = await get(commentRef);

  if (!snap.exists()) return;
  let c = snap.val();
  c.likes = c.likes || {};
  c.dislikes = c.dislikes || {};

  // ----- TOGGLE LOGIC -----
  if (type === "like") {
    if (c.likes[user]) delete c.likes[user];
    else { c.likes[user] = true; delete c.dislikes[user]; }
  }
  if (type === "dislike") {
    if (c.dislikes[user]) delete c.dislikes[user];
    else { c.dislikes[user] = true; delete c.likes[user]; }
  }

  // ----- FAST UI UPDATE (NO WAITING) -----
  const item = commentsList.querySelector(`[data-id="${commentId}"]`);
  const likeBtn = item.querySelector(".like-btn");
  const dislikeBtn = item.querySelector(".dislike-btn");

  const likeCount = Object.keys(c.likes).length;
  const dislikeCount = Object.keys(c.dislikes).length;

  // Update count numbers immediately
  likeBtn.querySelector("span").textContent = likeCount;
  dislikeBtn.querySelector("span").textContent = dislikeCount;

  // Update button active style instantly
  likeBtn.classList.toggle("active", !!c.likes[user]);
  dislikeBtn.classList.toggle("active", !!c.dislikes[user]);

  // ----- UPDATE FIREBASE IN BACKGROUND (NO UI FREEZE) -----
  set(commentRef, c);
}

  sendBtn.onclick = async () => {
    const text = input.value.trim();
    if (!text) return;
    const user = localStorage.getItem("username") || "Guest";
    const newComment = {
      id: "c_" + Date.now(),
      user,
      text,
      ts: Date.now(),
    };
    try {
      const snap = await get(commentsRef);
      let comments = snap.exists() ? snap.val() : {};
      comments[newComment.id] = newComment;
      await set(commentsRef, comments);
      input.value = "";
      await loadComments();
    } catch (e) {
      alert("Failed to post comment.");
      console.error(e);
    }
  };

  await loadComments();
});

    console.log(`✅ openSerialPreview: displayed "${serialData.title}"`);
  } catch (err) {
    console.error("❌ openSerialPreview error:", err);
    alert("Error loading serial preview.");
  }
}

// --- AUTO OPEN ON SHARE LINK ---
(function autoOpenPreviewFromUrl() {
  try {
    const params = new URLSearchParams(window.location.search);
    const t = params.get("previewSerial");
    if (!t) return;
    setTimeout(() => openSerialPreview(t), 200);
  } catch (e) {
    console.warn("Auto-open preview failed:", e);
  }
})();

// --- FIXED openSerialReader (cross-device compatible with Firebase fallback) ---
async function openSerialReader(serialTitle, episodeIndex) {
  // Load from local first
  const saved = (typeof loadSavedSerials === 'function') ? loadSavedSerials() : [];
  let serial = (saved || []).find(s => s.title === serialTitle) ||
               (window.serialsData || []).find(s => s.title === serialTitle);

  // 🔥 Fallback: Fetch from Firebase if not found locally
  if (!serial && window._firebase && window._firebase.get) {
    try {
      const { db, ref, get } = window._firebase;
      const snap = await get(ref(db, `serials/${encodeURIComponent(serialTitle)}`));
      if (snap.exists()) {
        serial = snap.val();
        console.log(`✅ Loaded serial "${serialTitle}" from Firebase`);
        // Cache locally
        const existing = JSON.parse(localStorage.getItem('savedSerials') || '[]');
        if (!existing.find(s => s.title === serialTitle)) {
          existing.push(serial);
          localStorage.setItem('savedSerials', JSON.stringify(existing));
        }
      } else {
        console.warn(`⚠️ Serial "${serialTitle}" not found in Firebase`);
      }
    } catch (err) {
      console.error('❌ Error fetching serial from Firebase:', err);
    }
  }

  if (!serial) {
    alert('Serial not found');
    return;
  }

  const ep = (serial.episodes || [])[episodeIndex];
  if (!ep) {
    alert('Episode not found');
    return;
  }

  // --- CREATE PANEL ---
  let panel = document.getElementById('serialReaderFull');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'serialReaderFull';
    panel.className = 'reader-full';
    panel.style.cssText = `
      position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1200;
      background:#f7f7fb;display:flex;flex-direction:column;overflow:hidden;
    `;
    document.body.appendChild(panel);
  }
  panel.innerHTML = '';

  // --- HEADER ---
  const header = document.createElement('div');
  header.className = 'reader-header';
  header.style.cssText = `
    display:flex;justify-content:space-between;align-items:center;
    padding:12px 18px;background:#fff;flex-shrink:0;
  `;
  header.innerHTML = `
    <div><button class="btn btn-secondary" id="backToSerialBtn">← Back</button></div>
    <div style="text-align:center;flex:1">
      <h2 style="margin:6px 0;font-size:16px">${serial.title} — ${ep.title}</h2>
      <div class="muted" style="font-size:12px">${serial.genre || '—'} • ${ep.description || ''}</div>
    </div>
    <div style="width:120px;visibility:hidden"></div>
  `;

  // --- BODY ---
  const body = document.createElement('div');
  body.className = 'reader-body';
  body.style.cssText = `
    flex:1;overflow-y:auto;padding:12px;display:flex;
    flex-direction:column;align-items:center;justify-content:flex-start;
  `;

  const sheetsArray = (ep.sheets || []).map(s =>
    typeof s === 'string' ? { content: s } : (s.content ? s : { content: s })
  );
  const totalPages = Math.max(1, sheetsArray.length || 1);
  let currentPage = 0;

  const pageWrap = document.createElement('div');
  pageWrap.style.cssText = `
    display:flex;flex-direction:column;align-items:center;width:100%;
    box-sizing:border-box;
  `;

  const pageBox = document.createElement('div');
  pageBox.className = 'reader-sheet';
  pageBox.style.cssText = `
    width:100%;max-width:880px;min-height:540px;margin:20px auto;
    padding:30px 35px;background:linear-gradient(135deg,#fffef9 0%,#fdf8e4 100%);
    border:1px solid #e5d7b7;border-radius:12px;box-shadow:0 8px 16px rgba(0,0,0,0.1);
    box-sizing:border-box;font-family:'Georgia','Times New Roman',serif;
    font-size:16px;line-height:1.7;color:#2e2b23;text-align:justify;
    letter-spacing:0.3px;white-space:pre-wrap;overflow-wrap:break-word;
    position:relative;transition:all 0.3s ease;
  `;

  const pagerRow = document.createElement('div');
  pagerRow.style.cssText = `
    display:flex;flex-wrap:wrap;align-items:center;justify-content:center;
    gap:6px;margin-top:12px;
  `;

  const prevPageBtn = document.createElement('button');
  prevPageBtn.className = 'btn btn-secondary';
  prevPageBtn.textContent = '◀ Prev Page';

  const pageIndicator = document.createElement('div');
  pageIndicator.className = 'muted';
  pageIndicator.style.cssText = `
    min-width:80px;text-align:center;font-size:14px;
  `;

  const nextPageBtn = document.createElement('button');
  nextPageBtn.className = 'btn btn-primary';
  nextPageBtn.textContent = 'Next Page ▶';

  const markLastReadBtn = document.createElement('button');
  markLastReadBtn.className = 'btn btn-warning';
  markLastReadBtn.textContent = 'Mark Last Read';

  const completeMarkBtn = document.createElement('button');
  completeMarkBtn.className = 'btn btn-success';
  completeMarkBtn.textContent = 'Complete Mark';
  completeMarkBtn.style.display = 'none';

  const removeMarkBtn = document.createElement('button');
  removeMarkBtn.className = 'btn btn-danger';
  removeMarkBtn.textContent = 'Remove Last Mark';
  removeMarkBtn.style.display = 'inline-block';

  // Small button style helper
  const styleButton = btn => {
    btn.style.padding = '6px 10px';
    btn.style.fontSize = '14px';
    btn.style.borderRadius = '6px';
    btn.style.minWidth = 'auto';
  };
  [prevPageBtn, nextPageBtn, markLastReadBtn, completeMarkBtn, removeMarkBtn].forEach(styleButton);

  pagerRow.append(prevPageBtn, pageIndicator, nextPageBtn, markLastReadBtn, completeMarkBtn, removeMarkBtn);
  pageWrap.append(pageBox, pagerRow);
  body.appendChild(pageWrap);

  // --- Drawing + Page Render ---
  const marksPerPage = {};
  let drawCanvas = null;
  let drawContext = null;

  function renderPage(idx) {
    currentPage = Math.max(0, Math.min(idx, totalPages - 1));
    const sheetObj = sheetsArray[currentPage] || { content: '(No content in this page)' };

    if (typeof sheetObj.content === 'string' && /<[a-z][\s\S]*>/i.test(sheetObj.content)) {
      pageBox.innerHTML = sheetObj.content;
    } else {
      pageBox.textContent = sheetObj.content || '(No content in this page)';
    }

    pageIndicator.textContent = `Page ${currentPage + 1} / ${totalPages}`;
    prevPageBtn.disabled = currentPage === 0;
    nextPageBtn.disabled = currentPage === totalPages - 1;
  }

  prevPageBtn.addEventListener('click', () => renderPage(currentPage - 1));
  nextPageBtn.addEventListener('click', () => renderPage(currentPage + 1));

  if (sheetsArray.length === 0) sheetsArray.push({ content: '(No content in this episode yet)' });
  renderPage(0);

  // --- FOOTER ---
  const footer = document.createElement('div');
  footer.style.cssText = `
    display:flex;justify-content:center;flex-wrap:wrap;gap:6px;
    padding:12px;background:#fff;flex-shrink:0;
  `;

  const prevBtn = document.createElement('button');
  prevBtn.className = 'btn btn-secondary';
  prevBtn.textContent = '◀ Prev Episode';

  const nextBtn = document.createElement('button');
  nextBtn.className = 'btn btn-primary';
  nextBtn.textContent = 'Next Episode ▶';

  [prevBtn, nextBtn].forEach(styleButton);
  footer.append(prevBtn, nextBtn);

  panel.append(header, body, footer);

  // --- Button Actions ---
  document.getElementById('backToSerialBtn').addEventListener('click', () => {
    panel.remove();
    if (typeof openSerialPreview === 'function') openSerialPreview(serial);
  });

  prevBtn.addEventListener('click', () => {
    if (episodeIndex > 0) openSerialReader(serial.title, episodeIndex - 1);
  });

  nextBtn.addEventListener('click', () => {
    if (episodeIndex < (serial.episodes || []).length - 1)
      openSerialReader(serial.title, episodeIndex + 1);
  });

  window.scrollTo(0, 0);
}

// --- Optional: Sync serialsData push ---
(function(){
  try{
    if(Array.prototype._origSerialPush == null){
      Array.prototype._origSerialPush = Array.prototype.push;
    }
    if(window.serialsData && window.serialsData.push){
      const orig = window.serialsData.push;
      window.serialsData.push = function(){
        const res = orig.apply(this, arguments);
        try{ syncSerialsToStorage(); }catch(e){}
        return res;
      };
    }
  }catch(e){}
})();

// Also call sync after some known buttons if they exist
setTimeout(()=>{
  if(window.serialCreateConfirmBtn){
    serialCreateConfirmBtn.addEventListener('click', ()=> setTimeout(syncSerialsToStorage, 500) );
  }
  if(window.addEpConfirmBtn){
    addEpConfirmBtn.addEventListener('click', ()=> setTimeout(syncSerialsToStorage, 500) );
  }
}, 800);

</script>
<!-- END: SERIALS EXTENSION INJECTION -->

<!-- START: Auto-Injected Serial READs & Download Augmentation -->
<script>
(function(){
  // Helper: stable key for serial (using title)
  function serialKey(title) {
    return 'serial_reads_' + (title || 'unknown').replace(/\s+/g,'_').toLowerCase();
  }

  // Persisted storage helpers
  function loadCounts(key) {
    try {
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : {};
    } catch(e){ return {}; }
  }
  function saveCounts(key, obj) {
    try { localStorage.setItem(key, JSON.stringify(obj)); } catch(e){}
  }

  // Download helper
  function downloadJSON(filename, obj) {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(obj, null, 2));
    const a = document.createElement('a');
    a.setAttribute('href', dataStr);
    a.setAttribute('download', filename);
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Try to detect serial preview containers added to DOM.
  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      for (const node of m.addedNodes) {
        if (!(node instanceof HTMLElement)) continue;
        // Detect likely serial preview by common heuristics: header with <h1>, description, and multiple episode cards/lists.
        const h1 = node.querySelector && (node.querySelector('h1') || node.querySelector('.serial-title') || node.querySelector('.title'));
        const episodes = node.querySelectorAll && (node.querySelectorAll('.episode, .ep, .story-card, .episode-card, .ep-card') || []);
        // episodes NodeList may be empty; we will further search inside for lists
        const potentialEpisodeItems = node.querySelectorAll('li, .episode, .story-card, .episode-card, .ep-card');
        const epCount = potentialEpisodeItems.length;
        if (h1 && (epCount > 0 || node.querySelectorAll('.episode').length>0)) {
          enhanceSerialPreview(node);
        } else {
          // Some previews might use a wrapper with class 'serial-preview' or id 'serialPreview'
          if (node.matches && (node.matches('.serial-preview') || node.id === 'serialPreview')) {
            enhanceSerialPreview(node);
          }
        }
      }
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });

  // Also attempt to enhance already-present preview on page load (in case it exists)
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const previews = document.querySelectorAll('.serial-preview, [data-serial-preview], #serialPreview');
      if (previews.length) previews.forEach(enhanceSerialPreview);
      // Fallback: find containers with h1 and multiple story-card children
      const nodes = Array.from(document.querySelectorAll('div, section'));
      for (const n of nodes) {
        const h1 = n.querySelector && (n.querySelector('h1') || n.querySelector('.serial-title'));
        const items = n.querySelectorAll && n.querySelectorAll('.story-card, .episode, li').length;
        if (h1 && items>0) enhanceSerialPreview(n);
      }
    }, 500);
  });

  // Main enhancer function
  function enhanceSerialPreview(container){
    try {
      // Avoid double-enhancing
      if (container.__readsEnhanced) return;
      container.__readsEnhanced = true;

      // Locate serial title, genre, description
      const titleEl = container.querySelector('h1') || container.querySelector('.serial-title') || container.querySelector('.title');
      const title = titleEl ? titleEl.textContent.trim() : 'untitled_serial';
      const key = serialKey(title);

      // Find or create the READ total label under header
      let readsLabel = container.querySelector('#serialReadsLabel');
      if (!readsLabel) {
        readsLabel = document.createElement('div');
        readsLabel.id = 'serialReadsLabel';
        readsLabel.style.fontWeight = '700';
        readsLabel.style.marginTop = '8px';
        // Prefer to insert after the title or after a header block
        if (titleEl && titleEl.parentElement) {
          titleEl.parentElement.appendChild(readsLabel);
        } else {
          container.insertBefore(readsLabel, container.firstChild);
        }
      }


      // Load counts from storage
      const counts = loadCounts(key);

      // Identify episode elements (best-effort)
      let episodeEls = Array.from(container.querySelectorAll('.episode, .episode-card, .ep-card, .story-card, li'));
      // Filter out container-level lists that are not episodes by checking for a 'Read' button inside or 'Start Reading' text
      episodeEls = episodeEls.filter(el => {
        const txt = (el.textContent||'').toLowerCase();
        const hasReadBtn = !!el.querySelector('button, a');
        return txt.length<10000 && (hasReadBtn || txt.includes('episode') || txt.includes('start reading') || txt.includes('read'));
      });

      // If nothing found, try direct children
      if (episodeEls.length === 0) {
        const list = container.querySelectorAll('ul > li, ol > li');
        episodeEls = Array.from(list);
      }

      // Add per-episode UI
      episodeEls.forEach((epEl, idx) => {
        // Avoid double-insert
        if (epEl.querySelector('.read-count-badge')) return;

        // Determine an episode title
        const epTitleEl = epEl.querySelector('h3, h4, .ep-title, .title') || epEl.querySelector('strong') || epEl;
        const epTitle = epTitleEl ? (epTitleEl.textContent || '').trim().substring(0,120) : ('Episode ' + (idx+1));

        // Ensure reads value exists
        if (typeof counts[idx] !== 'number') counts[idx] = counts[idx] || 0;

        // Create read badge
        const badge = document.createElement('span');
        badge.className = 'read-count-badge';
        badge.style.marginLeft = '8px';
        badge.style.fontWeight = '700';
        badge.style.fontSize = '13px';
        badge.textContent = 'Reads = ' + (counts[idx]||0);

        // Append badge near title or at the end
        if (epTitleEl && epTitleEl.parentElement) {
          epTitleEl.parentElement.appendChild(badge);
        } else {
          epEl.appendChild(badge);
        }

        // Wire the episode's "Read" or "Start Reading" button to increment the count
        // Search for button-like elements
        const candidateBtns = Array.from(epEl.querySelectorAll('button, a'));
        let readBtn = candidateBtns.find(b => /read|start reading|open/i.test((b.textContent||'')));
        if (!readBtn && candidateBtns.length) readBtn = candidateBtns[0];

        if (readBtn) {
          readBtn.addEventListener('click', (ev) => {
            // Increment count and save
            counts[idx] = (counts[idx] || 0) + 1;
            saveCounts(key, counts);
            // Update badge and total label
            badge.textContent = 'READ = ' + counts[idx];
            updateTotalLabel(container, counts);
            // allow other handlers to run
            setTimeout(()=>{},0);
          });
        }
      });

      // Save counts back (initial)
      saveCounts(key, counts);
      updateTotalLabel(container, counts);
    } catch(e){
      console.error('enhanceSerialPreview error', e);
    }
  }

  function updateTotalLabel(container, counts) {
    const total = (Array.isArray(counts) ? counts.reduce((a,b)=>a+(b||0),0) : Object.values(counts).reduce((a,b)=>a+(b||0),0));
    let lbl = container.querySelector('#serialReadsLabel');
    if (!lbl) {
      lbl = document.createElement('div');
      lbl.id = 'serialReadsLabel';
      lbl.style.fontWeight = '700';
      lbl.style.marginTop = '8px';
      if (container.querySelector('h1')) container.querySelector('h1').parentElement.appendChild(lbl);
      else container.appendChild(lbl);
    }
    lbl.textContent = 'Reads = ' + total;
  }

  // Build a best-effort serial JSON from the DOM preview (title, genre, description, episodes text)
  function buildSerialJSON(container) {
    const title = (container.querySelector('h1') || container.querySelector('.serial-title') || {textContent:'Untitled'}).textContent.trim();
    const genre = (container.querySelector('.genre') || container.querySelector('[data-genre]') || {textContent:''}).textContent.trim();
    const desc = (container.querySelector('.description') || container.querySelector('.serial-description') || {textContent:''}).textContent.trim();
    const episodes = [];
    const episodeEls = Array.from(container.querySelectorAll('.episode, .episode-card, .story-card, li'));
    episodeEls.forEach((el, idx) => {
      const epTitle = (el.querySelector('h3, h4, .ep-title') || el.querySelector('strong') || {textContent:('Episode '+(idx+1))}).textContent.trim();
      const body = (el.querySelector('.body, p') || el).textContent.trim();
      // load counts
      const key = 'serial_reads_' + title.replace(/\s+/g,'_').toLowerCase();
      let counts = {};
      try { counts = JSON.parse(localStorage.getItem(key) || '{}'); } catch(e){}
      const reads = counts[idx] || 0;
      episodes.push({ title: epTitle, body: body, reads: reads });
    });
    return { title, genre, description: desc, episodes };
  }

    })();

  // Additional UI tweaks:
  // 1) If both Close and Download buttons exist in a preview, swap their positions so Close is where Download was and vice versa.
  function swapPreviewButtons(container) {
    try {
      const closeBtn = container.querySelector('#closeSerialPreviewBtn') || Array.from(container.querySelectorAll('button')).find(b => /close/i.test(b.textContent||''));
      const downloadBtn = container.querySelector('#downloadSerialBtn') || Array.from(container.querySelectorAll('button')).find(b => /download serial/i.test(b.textContent||''));
      if (closeBtn && downloadBtn && closeBtn.parentElement && downloadBtn.parentElement) {
        const closeParent = closeBtn.parentElement;
        const downloadParent = downloadBtn.parentElement;
        // Swap by replacing nodes
        const closeClone = closeBtn.cloneNode(true);
        const downloadClone = downloadBtn.cloneNode(true);
        closeClone.id = closeBtn.id || 'closeSerialPreviewBtn_clone';
        downloadClone.id = downloadBtn.id || 'downloadSerialBtn_clone';
        // replace
        closeParent.replaceChild(downloadClone, closeBtn);
        downloadParent.replaceChild(closeClone, downloadBtn);
        // reattach listeners if any by clicking behaviors (best-effort: forward click to original behavior)
        downloadClone.addEventListener('click', function(e){ downloadBtn.click && downloadBtn.click(); });
        closeClone.addEventListener('click', function(e){ closeBtn.click && closeBtn.click(); });
      }
    } catch(e){console.warn('swapPreviewButtons failed', e);}
  }

 
  // Run these helpers when new previews are detected and on DOMContentLoaded
  const extraObserver = new MutationObserver(muts => {
    muts.forEach(m => {
      m.addedNodes.forEach(n => {
        if (!(n instanceof HTMLElement)) return;
        // If a preview or header added, attempt swap
        if (n.querySelector && (n.querySelector('#downloadSerialBtn') || n.querySelector('#closeSerialPreviewBtn') || n.querySelector('h1'))) {
          swapPreviewButtons(n);
        }
      });
    });
    // Also attempt to ensure Back button on any mutation
    ensureBrowseBackButton();
  });
  extraObserver.observe(document.body, { childList: true, subtree: true });

  document.addEventListener('DOMContentLoaded', () => {
    // Try swapping in already-present previews
    const previews = document.querySelectorAll('.serial-preview, #serialPreview, .preview-modal, .story-preview');
    previews.forEach(p => swapPreviewButtons(p));
    ensureBrowseBackButton();
    // Also attempt a second pass after a short delay
    setTimeout(()=>{ previews.forEach(p => swapPreviewButtons(p)); ensureBrowseBackButton(); }, 800);
  });

</script>
<!-- END: Auto-Injected Serial READs & Download Augmentation -->
  <!-- existing app scripts -->
  <script>
// ---------- Tags helpers (insert near other helpers) ----------

// create a tag "chip" element
function makeTagChip(tagText) {
  const chip = document.createElement('div');
  chip.className = 'tag-chip';
  chip.style.cssText = 'display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#f3f4f6;border:1px solid #e5e7eb;font-weight:600';
  chip.innerHTML = `<span class="tag-label">${tagText}</span><button type="button" class="tag-remove" title="Remove tag" style="background:transparent;border:0;cursor:pointer;font-weight:700">✕</button>`;
  chip.querySelector('.tag-remove').addEventListener('click', () => chip.remove());
  return chip;
}

// add one tag from an input to a container (prevents duplicates, trims)
function addTagFromInput(inputEl, containerEl) {
  if (!inputEl || !containerEl) return;
  const raw = (inputEl.value || '').trim();
  if (!raw) return inputEl.value = '';

  // support comma-separated tags (e.g. "apple, banana")
  const parts = raw.split(',').map(s => s.trim()).filter(Boolean);

  parts.forEach(v => {
    // prevent duplicates (case-insensitive)
    const exist = Array.from(containerEl.querySelectorAll('.tag-label'))
      .some(n => n.textContent.toLowerCase() === v.toLowerCase());
    if (exist) return;
    const chip = makeTagChip(v);
    containerEl.appendChild(chip);
  });

  inputEl.value = '';
  inputEl.focus();
}

// return array of tag texts from a container
function getTagsFromContainer(containerEl) {
  if (!containerEl) return [];
  return Array.from(containerEl.querySelectorAll('.tag-label')).map(n => n.textContent.trim()).filter(Boolean);
}

// clear container and set tags (useful when loading an existing story/serial)
function setTagsToContainer(containerEl, tagsArray) {
  if (!containerEl) return;
  containerEl.innerHTML = '';
  (Array.isArray(tagsArray) ? tagsArray : []).forEach(t => {
    if (!t) return;
    const chip = makeTagChip(t);
    containerEl.appendChild(chip);
  });
}

// wire inputs/buttons: inputEl = <input>, btnEl = add button, containerEl = tags container
function wireTagInput(inputEl, btnEl, containerEl) {
  if (!inputEl || !btnEl || !containerEl) return;

  // add click handler
  btnEl.addEventListener('click', () => addTagFromInput(inputEl, containerEl));

  // add Enter handler on input
  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addTagFromInput(inputEl, containerEl);
    } else if (e.key === ',' && e.ctrlKey) {
      // optional: ctrl+, to quickly add current value
      e.preventDefault();
      addTagFromInput(inputEl, containerEl);
    }
  });

  // handle paste of multiple tags (comma-separated)
  inputEl.addEventListener('paste', (ev) => {
    const text = (ev.clipboardData || window.clipboardData).getData('text');
    if (text && text.includes(',')) {
      ev.preventDefault();
      inputEl.value = text;
      addTagFromInput(inputEl, containerEl);
    }
  });
}

// convenience initialiser — automatically finds the elements you added earlier
function initTagsUI() {
  try {
    const storyInput = document.getElementById('storyTagInput');
    const storyBtn = document.getElementById('addStoryTagBtn');
    const storyCont = document.getElementById('storyTagsContainer');

    const seriesInput = document.getElementById('seriesTagInput');
    const seriesBtn = document.getElementById('addSeriesTagBtn');
    const seriesCont = document.getElementById('seriesTagsContainer');

    if (storyInput && storyBtn && storyCont) wireTagInput(storyInput, storyBtn, storyCont);
    if (seriesInput && seriesBtn && seriesCont) wireTagInput(seriesInput, seriesBtn, seriesCont);

    // If you want to pre-load tags when editing, call setTagsToContainer(container, tagsArray)
    // Example:
    // setTagsToContainer(storyCont, existingStory.tags || []);

  } catch (err) {
    console.warn('initTagsUI error', err);
  }
}

// call init on DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initTagsUI);
} else {
  initTagsUI();
}

// ---- Helpers to attach tags to your payloads before save/publish ----

// Usage: before saving/publishing a story, do:
// const story = { title: ..., content: ... };
// attachStoryTagsToPayload(story);
// then save story object
function attachStoryTagsToPayload(payload) {
  const c = document.getElementById('storyTagsContainer');
  if (!payload) payload = {};
  payload.tags = getTagsFromContainer(c);
  return payload;
}

// Usage for series/serial create flow:
// const series = { title: ..., desc: ... };
// attachSeriesTagsToPayload(series);
function attachSeriesTagsToPayload(payload) {
  const c = document.getElementById('seriesTagsContainer');
  if (!payload) payload = {};
  payload.tags = getTagsFromContainer(c);
  return payload;
}

// ---- Small CSS helper (optional) ----
// If you prefer to add styles inside a <style> tag, here's a compact rule you can paste into your CSS:
const tagChipStyle = `
.tag-chip { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background:#f3f4f6; border:1px solid #e5e7eb; font-weight:600; margin:2px; }
.tag-chip .tag-remove { cursor:pointer; font-weight:700; padding-left:6px; }
`;
// inject style once (non-destructive)
if (!document.getElementById('meurbal-tagchip-styles')) {
  const s = document.createElement('style');
  s.id = 'meurbal-tagchip-styles';
  s.textContent = tagChipStyle;
  document.head.appendChild(s);
}

    // your main app code ...
  </script>

  <!-- ✅ Add this line for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js">
// ---- Inject cover background in browse stories ----
function applyCoverToStoryCards() {
  document.querySelectorAll('#storiesCards .story-card').forEach(card => {
    const title = card.querySelector('h2')?.innerText?.trim();
    if (!title) return;
    const story = (window.storiesData || []).find(s => s.title === title);
    if (story && story.cover) {
      card.style.backgroundImage = `url(${story.cover})`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';
      card.style.color = '#fff';
    }
  });
}



// ---- Enhanced cover display for Browse Stories ----
function renderStoryCardsWithCovers(storiesArray) {
  const container = document.getElementById('storiesCards');
  if (!container) return;
  container.innerHTML = '';
  (storiesArray || []).forEach(story => {
    const storyCard = document.createElement('div');
    storyCard.className = 'story-card';
    storyCard.innerHTML = `<h2>${story.title}</h2><p>${story.genre || ''}</p>`;

    if (story.cover) {
      storyCard.style.backgroundImage = `url(${story.cover})`;
      storyCard.style.backgroundSize = 'cover';
      storyCard.style.backgroundPosition = 'center';
      storyCard.style.color = '#fff';
    }

    container.appendChild(storyCard);
  });
}

// Automatically override story browsing behavior
window._oldRenderStories = window.renderStories;
window.renderStories = function() {
  if (typeof window._oldRenderStories === 'function') window._oldRenderStories();
  try {
    renderStoryCardsWithCovers(window.storiesData || []);
  } catch (e) { console.warn('Cover apply failed:', e); }
};

// Run once on page load in case stories are already shown
document.addEventListener('DOMContentLoaded', () => renderStoryCardsWithCovers(window.storiesData || []));


// Apply covers to serial cards in browse serials (runs after serials rendered)
function applySerialCovers() {
  // serialCategoriesGrid might contain cat cards; serial listing rendering may be elsewhere.
  // We'll scan serialsData and update any card elements that have data-title attribute matching serial title.
  document.querySelectorAll('.serial-card').forEach(card => {
    const title = card.dataset.title;
    if (!title) return;
    const ser = (window.serialsData || []).find(s => s.title === title);
    if (ser && ser.cover) {
      card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.35), rgba(0,0,0,0.35)), url(${ser.cover})`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';
      card.style.color = '#fff';
    }
  });
}
document.addEventListener('DOMContentLoaded', () => setTimeout(applySerialCovers, 300));
// === TESTING ONLY ===
// Generates 100 random serials with varying popularity, genres, and recency
function generateFakeSerials(count = 100) {
  const genres = ["Action", "Romance", "Comedy", "Fantasy", "Horror", "Tragic", "Thriller","Adventure","Crime","Historic"];
  const covers = [
    "https://picsum.photos/seed/serial1/500/700",
    "https://picsum.photos/seed/serial2/500/700",
    "https://picsum.photos/seed/serial3/500/700",
    "https://picsum.photos/seed/serial4/500/700",
    "https://picsum.photos/seed/serial5/500/700"
  ];

  const randomDate = () => {
    const daysAgo = Math.floor(Math.random() * 365); // up to 1 year old
    const date = new Date(Date.now() - daysAgo * 86400000);
    return date.toISOString();
  };

  const serials = [];
  for (let i = 0; i < count; i++) {
    const genre = genres[Math.floor(Math.random() * genres.length)];
    const title = `${genre} Serial #${i + 1}`;
    const views = Math.floor(Math.random() * 10000);
    const likes = Math.floor(Math.random() * 500);
    const votes = Math.floor(Math.random() * 200);
    const cover = covers[Math.floor(Math.random() * covers.length)];
    const description = `A ${genre.toLowerCase()} story full of twists, heroes, and heart. Random ID ${i}.`;

    serials.push({
      id: i + 1,
      title,
      genre,
      description,
      views,
      likes,
      votes,
      cover,
      createdAt: randomDate()
    });
  }

  return serials;
}

// === CALL THIS TO TEST ===
function testSerialAlgorithm() {
  const fakeList = generateFakeSerials(100);
  renderBrowseSerials(fakeList);
  console.log("✅ Generated 100 fake serials and rendered using new algorithm.");
}

// Run automatically for quick testing (you can remove this after testing)
document.addEventListener('DOMContentLoaded', () => {
  testSerialAlgorithm();
});

</script>

<script>
// --- Real Search (no demo/fake stories) ---
function initRealSearch(){
  // helper
  function escapeHtml(str){return String(str??'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
  function debounce(fn,wait=220){let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),wait)};}

  // -------- STORIES SEARCH ----------
  const storiesInput=document.getElementById('storiesSearchInput');
  const storiesClear=document.getElementById('storiesClearSearchBtn');
  const storiesCards=document.getElementById('storiesCards');
  function searchStories(q){
    const query=(q||'').trim().toLowerCase();
    if(!storiesCards)return;
    let pool=[];
    try{pool=(window.storiesData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedStories_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!query){
      storiesCards.innerHTML='';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    storiesCards.innerHTML='';
    matches.forEach(story=>{
      const card=document.createElement('div');
      card.className='story-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(story.title||'Untitled')}</h3><p>${escapeHtml(story.genre||'')}</p>`;
      if(story.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${story.cover})`;
      card.addEventListener('click',()=>{try{openPreviewFullScreen(story);}catch(e){}});
      storiesCards.appendChild(card);
    });
  }
  if(storiesInput)storiesInput.addEventListener('input',debounce(e=>searchStories(e.target.value),200));
  if(storiesClear)storiesClear.addEventListener('click',()=>{storiesInput.value='';searchStories('');});

  // -------- SERIALS SEARCH ----------
  const serialsInput=document.getElementById('serialsSearchInput');
  const serialsClear=document.getElementById('serialsClearSearchBtn');
  const serialsWrap=document.getElementById('serialSearchResults');
  const serialsCards=document.getElementById('serialsCards');
  function searchSerials(q){
    const query=(q||'').trim().toLowerCase();
    let pool=[];
    try{pool=(window.serialsData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedSerials_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!serialsCards)return;
    if(!query){
      serialsCards.innerHTML='';
      if(serialsWrap)serialsWrap.style.display='none';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    serialsCards.innerHTML='';
    matches.forEach(s=>{
      const card=document.createElement('div');
      card.className='story-card serial-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(s.title||'Untitled')}</h3><p>${escapeHtml(s.genre||'')}</p>`;
      if(s.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${s.cover})`;
      card.addEventListener('click',()=>{try{openSerialPreview(s.id||s.title);}catch(e){}});
      serialsCards.appendChild(card);
    });
    if(serialsWrap)serialsWrap.style.display=matches.length?'block':'none';
  }
  if(serialsInput)serialsInput.addEventListener('input',debounce(e=>searchSerials(e.target.value),200));
  if(serialsClear)serialsClear.addEventListener('click',()=>{serialsInput.value='';searchSerials('');});
}
if(document.readyState==='loading')document.addEventListener('DOMContentLoaded',initRealSearch);
else initRealSearch();
</script>


<script>
document.addEventListener('DOMContentLoaded', async ()=>{
  // load from firebase if available
  try{
    if(window._firebase && window._firebase.get){
      const { db, ref, get, child } = window._firebase;
      // load stories
      try{
        const snap = await get(child(ref(db), 'stories'));
        if(snap && snap.exists && snap.exists()){
          const val = snap.val();
          // val may be an object of keyed stories; map to array
          window.storiesData = Object.values(val || {});
          console.log('Loaded stories from Firebase:', window.storiesData.length);
        } else { console.log('No stories in Firebase'); }
      }catch(e){ console.warn('Failed to load stories from Firebase', e); }

      // load serials
      try{
        const snap2 = await get(child(ref(db), 'serials'));
        if(snap2 && snap2.exists && snap2.exists()){
          const val2 = snap2.val();
          window.serialsData = Object.values(val2 || {});
          console.log('Loaded serials from Firebase:', window.serialsData.length);
        } else { console.log('No serials in Firebase'); }
      }catch(e){ console.warn('Failed to load serials from Firebase', e); }
    }
  }catch(e){ console.warn('Firebase loader error', e); }
});
</script>


<script>
// --- Ensure browse buttons always show updated Firebase data ---
document.addEventListener("DOMContentLoaded", () => {
  const browseStoriesBtn = document.getElementById("browseStoriesBtn");
  const browseSerialsBtn = document.getElementById("browseSerialsBtn");

  if (browseStoriesBtn) {
    browseStoriesBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "stories"));
        if (snap.exists()) {
          window.storiesData = Object.values(snap.val());
        }
        renderStoriesList(window.storiesData || []);
      } catch (e) {
        console.warn("Failed to load stories for browse:", e);
        renderStoriesList(window.storiesData || []);
      }
    });
  }

  if (browseSerialsBtn) {
    browseSerialsBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "serials"));
        if (snap.exists()) {
          window.serialsData = Object.values(snap.val());
        }
        renderSerialsList(window.serialsData || []);
      } catch (e) {
        console.warn("Failed to load serials for browse:", e);
        renderSerialsList(window.serialsData || []);
      }
    });
  }
});
</script>


<!-- CLEAN SERIALS VIEW INJECTION: replaces broken browse serials behavior -->
<style>
  /* clean serials view styles (keeps existing theme) */
  #cleanSerialsPage { padding:20px; min-height:100vh; background:var(--bg); display:none; }
  #cleanSerialsHeader{display:flex;align-items:center;justify-content:space-between;max-width:980px;margin:0 auto 12px;gap:12px}
  #cleanSerialsGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;max-width:980px;margin:12px auto;padding:12px}
  .clean-serial-card{background:#fff;border-radius:12px;padding:18px;box-shadow:var(--shadow);min-height:140px;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;transition:transform .18s}
  .clean-serial-card:hover{transform:translateY(-6px)}
  .serial-meta{color:var(--muted);font-size:13px}
  #cleanSerialsTop{display:flex;gap:12px;align-items:center;width:100%;max-width:980px;margin:0 auto}
  #cleanSerialsCount{font-weight:700}
  #cleanSerialsSearch{flex:1;padding:10px;border:1px solid var(--border);border-radius:8px}
  #cleanSerialsBack{position:fixed;left:14px;bottom:14px}
</style>

<div id="cleanSerialsPage" aria-hidden="true">
  <div id="cleanSerialsHeader">
    <div>
      <h2 style="margin:0">Browse Serials</h2>
      <div class="muted" id="cleanSerialsCount">Loading...</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <input id="cleanSerialsSearch" placeholder="Search serials..." />
      <button id="cleanSerialsRefreshBtn" class="btn btn-secondary">Refresh</button>
    </div>
  </div>

  <div id="cleanSerialsGrid" aria-live="polite" role="list"></div>
  <button class="back-btn" id="cleanSerialsBack">← Back</button>
</div>

<script>

(function(){
  function waitForFirebaseInit() {
    if (window._firebase && window._firebase.db && window._firebase.onValue && window._firebase.ref) {
      console.log('🟢 Firebase ready — initializing clean serials view');
      try{
        // Execute the original serials script now that Firebase is ready
        (async function(){
          // ensure helper functions exist globally for legacy callers
            window.renderSerialsList = function(serials){
              // maintain compatibility - forward to clean renderer if available
              if(window._renderCleanSerials) return window._renderCleanSerials(serials);
              const list = document.getElementById('serialsCards');
              if(!list) return;
              list.innerHTML = '';
              (serials||[]).forEach(s=>{
                const c=document.createElement('div');
                c.className='story-card';
                c.innerHTML=`<h2>${s.title}</h2><p>${s.genre||''}</p>`;
                list.appendChild(c);
              });
            };
          
            // internal render for clean view
            window._renderCleanSerials = function(serials){
              const grid = document.getElementById('cleanSerialsGrid');
              const count = document.getElementById('cleanSerialsCount');
              if(!grid) return;
              grid.innerHTML = '';
              serials = serials || [];
              count.textContent = `${serials.length} serial${serials.length===1?'':'s'} loaded`;
              serials.forEach(s=>{
                const card = document.createElement('div');
                card.className='clean-serial-card';
                const desc = s.description ? `<div class="muted" style="margin-top:6px">${s.description.slice(0,140)}</div>` : '';
                card.innerHTML = `<div><h4 style="margin:0">${s.title}</h4><div class="serial-meta">${s.genre||''}</div>${desc}</div><div style="display:flex;gap:8px;align-items:center"><button class="btn btn-primary btn-small">Open</button></div>`;
                card.addEventListener('click', ()=>{
                  // open editor or reader if exists - try to find serial by title in window.serialsData
                  const idx = (window.serialsData||[]).findIndex(x=> (x.title||'').trim() === (s.title||'').trim());
                  if(idx>=0){
                    // open the first episode if present using existing createEditorPage if available
                    try{
                      if(typeof createEditorPage === 'function'){
                        const ser = window.serialsData[idx];
                        const epIndex = ser.episodes && ser.episodes.length ? 0 : null;
                        createEditorPage(epIndex!=null? ser.episodes[epIndex].title : ser.title, ser.genre, epIndex!=null? ser.episodes[epIndex].description : ser.description, { isEdit:true, editType:'serial', index: idx, episodeIndex: epIndex });
                        return;
                      }
                    }catch(e){ console.warn('Open serial: editor open failed', e); }
                  }
                  alert('Open serial: editor not available in this context.');
                });
                grid.appendChild(card);
              });
            };
          
            // show/hide helpers
            function openCleanSerialsPage(){
              // hide other main pages (same logic as your app)
              const pages = ['welcomePage','categoriesPage','serialCategoriesPage','dashboardPage','slidesPage','storyFormPage','profileFormPage'];
              pages.forEach(id=>{
                const el = document.getElementById(id);
                if(el) el.classList.add('hidden');
              });
              // show our clean view
              const clean = document.getElementById('cleanSerialsPage');
              if(clean){ clean.classList.remove('hidden'); clean.setAttribute('aria-hidden','false'); }
              // attempt to render cached data immediately
              if(window.serialsData && window.serialsData.length){
                window._renderCleanSerials(window.serialsData);
                console.log(`ℹ️ Showing ${window.serialsData.length} cached serials from localStorage`);
              }
            }
          
            function closeCleanSerialsPage(){
              const clean = document.getElementById('cleanSerialsPage');
              if(clean){ clean.classList.add('hidden'); clean.setAttribute('aria-hidden','true'); }
              // show welcome page as fallback
              const welcome = document.getElementById('welcomePage');
              if(welcome) welcome.classList.remove('hidden');
            }
          
            // wire up buttons (override old handlers safely)
            const browseBtn = document.getElementById('browseSerialsBtn');
            if(browseBtn){
              browseBtn.removeEventListener && browseBtn.removeEventListener('click', ()=>{});
              browseBtn.addEventListener('click', (e)=>{
                e.preventDefault();
                openCleanSerialsPage();
              });
            }
            const backBtn = document.getElementById('cleanSerialsBack');
            if(backBtn) backBtn.addEventListener('click', ()=>{ closeCleanSerialsPage(); });
          
            const refreshBtn = document.getElementById('cleanSerialsRefreshBtn');
            if(refreshBtn) refreshBtn.addEventListener('click', ()=>{ fetchAndRenderSerials(true); });
          
            // search filtering
            const searchInput = document.getElementById('cleanSerialsSearch');
            if(searchInput) searchInput.addEventListener('input', (e)=>{
              const q = (e.target.value||'').toLowerCase().trim();
              const filtered = (window.serialsData||[]).filter(s=>{
                return (s.title||'').toLowerCase().includes(q) || (s.genre||'').toLowerCase().includes(q) || (s.description||'').toLowerCase().includes(q);
              });
              window._renderCleanSerials(filtered);
            });
          
            // Firebase real-time listener & initial fetch
            async function fetchAndRenderSerials(forceReload) {
    try {
      // Use Firebase SDK directly (no window._firebase dependency)
      import("https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js").then(({ getDatabase, ref, onValue }) => {
        const db = getDatabase();
        // attach live listener
        if (window._cleanSerialsListenerAttached && !forceReload) return;
        window._cleanSerialsListenerAttached = true;

        onValue(ref(db, 'serials'), snap => {
          if (snap.exists()) {
            const obj = snap.val();
            window.serialsData = Object.values(obj);
            try { localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); } catch (e) {}
            window._renderCleanSerials(window.serialsData);
            console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
          } else {
            window.serialsData = [];
            try { localStorage.setItem('serialsData', JSON.stringify([])); } catch (e) {}
            window._renderCleanSerials([]);
            console.log('⚠️ No serials found in Firebase');
          }
        });
      }).catch(err => console.error('Firebase import failed:', err));
    } catch (err) {
      console.error('Failed to load serials for browse:', err);
    }
    
                // attach live listener (debounce multiple attachments)
                if(window._cleanSerialsListenerAttached && !forceReload) return;
                window._cleanSerialsListenerAttached = true;
          
                onValue(ref(db, 'serials'), snap => {
                  if(snap.exists()){
                    const obj = snap.val();
                    window.serialsData = Object.values(obj);
                    try{ localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); }catch(e){}
                    window._renderCleanSerials(window.serialsData);
                    console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
                  } else {
                    window.serialsData = [];
                    try{ localStorage.setItem('serialsData', JSON.stringify([])); }catch(e){}
                    window._renderCleanSerials([]);
                    console.log('⚠️ No serials found in Firebase');
                  }
                });
              }catch(err){
                console.error('Failed to load serials for browse:', err);
              }
            }
          
            // attempt to initialize listener on DOMContentLoaded (or immediately if already)
            if(document.readyState === 'complete' || document.readyState === 'interactive'){
              fetchAndRenderSerials(false);
            } else {
              document.addEventListener('DOMContentLoaded', ()=> fetchAndRenderSerials(false));
            }
          
            // show cached data on load (fallback)
            try{
              const cached = JSON.parse(localStorage.getItem('serialsData') || 'null');
              if(cached && Array.isArray(cached) && cached.length){
                window.serialsData = cached;
                console.log('ℹ️ Loaded serials from localStorage cache:', window.serialsData.length);
              }
            }catch(e){}
          
          })();
        })();
      }catch(e){
        console.error('Error running serials initializer after Firebase ready', e);
      }
      return;
    }
    // still not ready, wait and retry
    console.log('⏳ Waiting for Firebase initialization...');
    setTimeout(waitForFirebaseInit, 300);
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    waitForFirebaseInit();
  } else {
    document.addEventListener('DOMContentLoaded', waitForFirebaseInit);
  }
})();
</script>
<!-- END INJECTION -->


<!-- Global fullscreen preview containers (moved outside hidden pages) -->
<div id="previewFull" class="hidden"></div>
<div id="readerFull" class="hidden"></div>
</body>

</html>


<script>
// --- Real Search (no demo/fake stories) ---
function initRealSearch(){
  // helper
  function escapeHtml(str){return String(str??'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
  function debounce(fn,wait=220){let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),wait)};}

  // -------- STORIES SEARCH ----------
  const storiesInput=document.getElementById('storiesSearchInput');
  const storiesClear=document.getElementById('storiesClearSearchBtn');
  const storiesCards=document.getElementById('storiesCards');
  function searchStories(q){
    const query=(q||'').trim().toLowerCase();
    if(!storiesCards)return;
    let pool=[];
    try{pool=(window.storiesData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedStories_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!query){
      storiesCards.innerHTML='';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    storiesCards.innerHTML='';
    matches.forEach(story=>{
      const card=document.createElement('div');
      card.className='story-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(story.title||'Untitled')}</h3><p>${escapeHtml(story.genre||'')}</p>`;
      if(story.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${story.cover})`;
      card.addEventListener('click',()=>{try{openPreviewFullScreen(story);}catch(e){}});
      storiesCards.appendChild(card);
    });
  }
  if(storiesInput)storiesInput.addEventListener('input',debounce(e=>searchStories(e.target.value),200));
  if(storiesClear)storiesClear.addEventListener('click',()=>{storiesInput.value='';searchStories('');});

  // -------- SERIALS SEARCH ----------
  const serialsInput=document.getElementById('serialsSearchInput');
  const serialsClear=document.getElementById('serialsClearSearchBtn');
  const serialsWrap=document.getElementById('serialSearchResults');
  const serialsCards=document.getElementById('serialsCards');
  function searchSerials(q){
    const query=(q||'').trim().toLowerCase();
    let pool=[];
    try{pool=(window.serialsData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedSerials_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!serialsCards)return;
    if(!query){
      serialsCards.innerHTML='';
      if(serialsWrap)serialsWrap.style.display='none';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    serialsCards.innerHTML='';
    matches.forEach(s=>{
      const card=document.createElement('div');
      card.className='story-card serial-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(s.title||'Untitled')}</h3><p>${escapeHtml(s.genre||'')}</p>`;
      if(s.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${s.cover})`;
      card.addEventListener('click',()=>{try{openSerialPreview(s.id||s.title);}catch(e){}});
      serialsCards.appendChild(card);
    });
    if(serialsWrap)serialsWrap.style.display=matches.length?'block':'none';
  }
  if(serialsInput)serialsInput.addEventListener('input',debounce(e=>searchSerials(e.target.value),200));
  if(serialsClear)serialsClear.addEventListener('click',()=>{serialsInput.value='';searchSerials('');});
}
if(document.readyState==='loading')document.addEventListener('DOMContentLoaded',initRealSearch);
else initRealSearch();
</script>
<!-- ===== START: Firebase sync + bottom status box (paste before 
<script>
// --- Ensure browse buttons always show updated Firebase data ---
document.addEventListener("DOMContentLoaded", () => {
  const browseStoriesBtn = document.getElementById("browseStoriesBtn");
  const browseSerialsBtn = document.getElementById("browseSerialsBtn");

  if (browseStoriesBtn) {
    browseStoriesBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "stories"));
        if (snap.exists()) {
          window.storiesData = Object.values(snap.val());
        }
        renderStoriesList(window.storiesData || []);
      } catch (e) {
        console.warn("Failed to load stories for browse:", e);
        renderStoriesList(window.storiesData || []);
      }
    });
  }

  if (browseSerialsBtn) {
    browseSerialsBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "serials"));
        if (snap.exists()) {
          window.serialsData = Object.values(snap.val());
        }
        renderSerialsList(window.serialsData || []);
      } catch (e) {
        console.warn("Failed to load serials for browse:", e);
        renderSerialsList(window.serialsData || []);
      }
    });
  }
});
</script>


<!-- CLEAN SERIALS VIEW INJECTION: replaces broken browse serials behavior -->
<style>
  /* clean serials view styles (keeps existing theme) */
  #cleanSerialsPage { padding:20px; min-height:100vh; background:var(--bg); display:none; }
  #cleanSerialsHeader{display:flex;align-items:center;justify-content:space-between;max-width:980px;margin:0 auto 12px;gap:12px}
  #cleanSerialsGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;max-width:980px;margin:12px auto;padding:12px}
  .clean-serial-card{background:#fff;border-radius:12px;padding:18px;box-shadow:var(--shadow);min-height:140px;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;transition:transform .18s}
  .clean-serial-card:hover{transform:translateY(-6px)}
  .serial-meta{color:var(--muted);font-size:13px}
  #cleanSerialsTop{display:flex;gap:12px;align-items:center;width:100%;max-width:980px;margin:0 auto}
  #cleanSerialsCount{font-weight:700}
  #cleanSerialsSearch{flex:1;padding:10px;border:1px solid var(--border);border-radius:8px}
  #cleanSerialsBack{position:fixed;left:14px;bottom:14px}
</style>

<div id="cleanSerialsPage" aria-hidden="true">
  <div id="cleanSerialsHeader">
    <div>
      <h2 style="margin:0">Browse Serials</h2>
      <div class="muted" id="cleanSerialsCount">Loading...</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <input id="cleanSerialsSearch" placeholder="Search serials..." />
      <button id="cleanSerialsRefreshBtn" class="btn btn-secondary">Refresh</button>
    </div>
  </div>

  <div id="cleanSerialsGrid" aria-live="polite" role="list"></div>
  <button class="back-btn" id="cleanSerialsBack">← Back</button>
</div>

<script>
(function(){
  // ensure helper functions exist globally for legacy callers
  window.renderSerialsList = function(serials){
    // maintain compatibility - forward to clean renderer if available
    if(window._renderCleanSerials) return window._renderCleanSerials(serials);
    const list = document.getElementById('serialsCards');
    if(!list) return;
    list.innerHTML = '';
    (serials||[]).forEach(s=>{
      const c=document.createElement('div');
      c.className='story-card';
      c.innerHTML=`<h2>${s.title}</h2><p>${s.genre||''}</p>`;
      list.appendChild(c);
    });
  };

  // internal render for clean view
  window._renderCleanSerials = function(serials){
    const grid = document.getElementById('cleanSerialsGrid');
    const count = document.getElementById('cleanSerialsCount');
    if(!grid) return;
    grid.innerHTML = '';
    serials = serials || [];
    count.textContent = `${serials.length} serial${serials.length===1?'':'s'} loaded`;
    serials.forEach(s=>{
      const card = document.createElement('div');
      card.className='clean-serial-card';
      const desc = s.description ? `<div class="muted" style="margin-top:6px">${s.description.slice(0,140)}</div>` : '';
      card.innerHTML = `<div><h4 style="margin:0">${s.title}</h4><div class="serial-meta">${s.genre||''}</div>${desc}</div><div style="display:flex;gap:8px;align-items:center"><button class="btn btn-primary btn-small">Open</button></div>`;
      card.addEventListener('click', ()=>{
        // open editor or reader if exists - try to find serial by title in window.serialsData
        const idx = (window.serialsData||[]).findIndex(x=> (x.title||'').trim() === (s.title||'').trim());
        if(idx>=0){
          // open the first episode if present using existing createEditorPage if available
          try{
            if(typeof createEditorPage === 'function'){
              const ser = window.serialsData[idx];
              const epIndex = ser.episodes && ser.episodes.length ? 0 : null;
              createEditorPage(epIndex!=null? ser.episodes[epIndex].title : ser.title, ser.genre, epIndex!=null? ser.episodes[epIndex].description : ser.description, { isEdit:true, editType:'serial', index: idx, episodeIndex: epIndex });
              return;
            }
          }catch(e){ console.warn('Open serial: editor open failed', e); }
        }
        alert('Open serial: editor not available in this context.');
      });
      grid.appendChild(card);
    });
  };

  // show/hide helpers
  function openCleanSerialsPage(){
    // hide other main pages (same logic as your app)
    const pages = ['welcomePage','categoriesPage','serialCategoriesPage','dashboardPage','slidesPage','storyFormPage','profileFormPage'];
    pages.forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.classList.add('hidden');
    });
    // show our clean view
    const clean = document.getElementById('cleanSerialsPage');
    if(clean){ clean.classList.remove('hidden'); clean.setAttribute('aria-hidden','false'); }
    // attempt to render cached data immediately
    if(window.serialsData && window.serialsData.length){
      window._renderCleanSerials(window.serialsData);
      console.log(`ℹ️ Showing ${window.serialsData.length} cached serials from localStorage`);
    }
  }

  function closeCleanSerialsPage(){
    const clean = document.getElementById('cleanSerialsPage');
    if(clean){ clean.classList.add('hidden'); clean.setAttribute('aria-hidden','true'); }
    // show welcome page as fallback
    const welcome = document.getElementById('welcomePage');
    if(welcome) welcome.classList.remove('hidden');
  }

  // wire up buttons (override old handlers safely)
  const browseBtn = document.getElementById('browseSerialsBtn');
  if(browseBtn){
    browseBtn.removeEventListener && browseBtn.removeEventListener('click', ()=>{});
    browseBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      openCleanSerialsPage();
    });
  }
  const backBtn = document.getElementById('cleanSerialsBack');
  if(backBtn) backBtn.addEventListener('click', ()=>{ closeCleanSerialsPage(); });

  const refreshBtn = document.getElementById('cleanSerialsRefreshBtn');
  if(refreshBtn) refreshBtn.addEventListener('click', ()=>{ fetchAndRenderSerials(true); });

  // search filtering
  const searchInput = document.getElementById('cleanSerialsSearch');
  if(searchInput) searchInput.addEventListener('input', (e)=>{
    const q = (e.target.value||'').toLowerCase().trim();
    const filtered = (window.serialsData||[]).filter(s=>{
      return (s.title||'').toLowerCase().includes(q) || (s.genre||'').toLowerCase().includes(q) || (s.description||'').toLowerCase().includes(q);
    });
    window._renderCleanSerials(filtered);
  });

  // Firebase real-time listener & initial fetch
  async function fetchAndRenderSerials(forceReload) {
    try {
      // Use Firebase SDK directly (no window._firebase dependency)
      import("https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js").then(({ getDatabase, ref, onValue }) => {
        const db = getDatabase();
        // attach live listener
        if (window._cleanSerialsListenerAttached && !forceReload) return;
        window._cleanSerialsListenerAttached = true;

        onValue(ref(db, 'serials'), snap => {
          if (snap.exists()) {
            const obj = snap.val();
            window.serialsData = Object.values(obj);
            try { localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); } catch (e) {}
            window._renderCleanSerials(window.serialsData);
            console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
          } else {
            window.serialsData = [];
            try { localStorage.setItem('serialsData', JSON.stringify([])); } catch (e) {}
            window._renderCleanSerials([]);
            console.log('⚠️ No serials found in Firebase');
          }
        });
      }).catch(err => console.error('Firebase import failed:', err));
    } catch (err) {
      console.error('Failed to load serials for browse:', err);
    }
    
      // attach live listener (debounce multiple attachments)
      if(window._cleanSerialsListenerAttached && !forceReload) return;
      window._cleanSerialsListenerAttached = true;

      onValue(ref(db, 'serials'), snap => {
        if(snap.exists()){
          const obj = snap.val();
          window.serialsData = Object.values(obj);
          try{ localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); }catch(e){}
          window._renderCleanSerials(window.serialsData);
          console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
        } else {
          window.serialsData = [];
          try{ localStorage.setItem('serialsData', JSON.stringify([])); }catch(e){}
          window._renderCleanSerials([]);
          console.log('⚠️ No serials found in Firebase');
        }
      });
    }catch(err){
      console.error('Failed to load serials for browse:', err);
    }
  }

  // attempt to initialize listener on DOMContentLoaded (or immediately if already)
  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    fetchAndRenderSerials(false);
  } else {
    document.addEventListener('DOMContentLoaded', ()=> fetchAndRenderSerials(false));
  }

  // show cached data on load (fallback)
  try{
    const cached = JSON.parse(localStorage.getItem('serialsData') || 'null');
    if(cached && Array.isArray(cached) && cached.length){
      window.serialsData = cached;
      console.log('ℹ️ Loaded serials from localStorage cache:', window.serialsData.length);
    }
  }catch(e){}

})();
</script>
<!-- END INJECTION -->


<!-- Global fullscreen preview containers (moved outside hidden pages) -->
<div id="previewFull" class="hidden"></div>
<div id="readerFull" class="hidden"></div>
</body>
) ===== -->
<script>
/* FIREBASE SYNC INTEGRATION
   - Paste this just before 
<script>
// --- Ensure browse buttons always show updated Firebase data ---
document.addEventListener("DOMContentLoaded", () => {
  const browseStoriesBtn = document.getElementById("browseStoriesBtn");
  const browseSerialsBtn = document.getElementById("browseSerialsBtn");

  if (browseStoriesBtn) {
    browseStoriesBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "stories"));
        if (snap.exists()) {
          window.storiesData = Object.values(snap.val());
        }
        renderStoriesList(window.storiesData || []);
      } catch (e) {
        console.warn("Failed to load stories for browse:", e);
        renderStoriesList(window.storiesData || []);
      }
    });
  }

  if (browseSerialsBtn) {
    browseSerialsBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "serials"));
        if (snap.exists()) {
          window.serialsData = Object.values(snap.val());
        }
        renderSerialsList(window.serialsData || []);
      } catch (e) {
        console.warn("Failed to load serials for browse:", e);
        renderSerialsList(window.serialsData || []);
      }
    });
  }
});
</script>


<!-- CLEAN SERIALS VIEW INJECTION: replaces broken browse serials behavior -->
<style>
  /* clean serials view styles (keeps existing theme) */
  #cleanSerialsPage { padding:20px; min-height:100vh; background:var(--bg); display:none; }
  #cleanSerialsHeader{display:flex;align-items:center;justify-content:space-between;max-width:980px;margin:0 auto 12px;gap:12px}
  #cleanSerialsGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;max-width:980px;margin:12px auto;padding:12px}
  .clean-serial-card{background:#fff;border-radius:12px;padding:18px;box-shadow:var(--shadow);min-height:140px;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;transition:transform .18s}
  .clean-serial-card:hover{transform:translateY(-6px)}
  .serial-meta{color:var(--muted);font-size:13px}
  #cleanSerialsTop{display:flex;gap:12px;align-items:center;width:100%;max-width:980px;margin:0 auto}
  #cleanSerialsCount{font-weight:700}
  #cleanSerialsSearch{flex:1;padding:10px;border:1px solid var(--border);border-radius:8px}
  #cleanSerialsBack{position:fixed;left:14px;bottom:14px}
</style>

<div id="cleanSerialsPage" aria-hidden="true">
  <div id="cleanSerialsHeader">
    <div>
      <h2 style="margin:0">Browse Serials</h2>
      <div class="muted" id="cleanSerialsCount">Loading...</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <input id="cleanSerialsSearch" placeholder="Search serials..." />
      <button id="cleanSerialsRefreshBtn" class="btn btn-secondary">Refresh</button>
    </div>
  </div>

  <div id="cleanSerialsGrid" aria-live="polite" role="list"></div>
  <button class="back-btn" id="cleanSerialsBack">← Back</button>
</div>

<script>
(function(){
  // ensure helper functions exist globally for legacy callers
  window.renderSerialsList = function(serials){
    // maintain compatibility - forward to clean renderer if available
    if(window._renderCleanSerials) return window._renderCleanSerials(serials);
    const list = document.getElementById('serialsCards');
    if(!list) return;
    list.innerHTML = '';
    (serials||[]).forEach(s=>{
      const c=document.createElement('div');
      c.className='story-card';
      c.innerHTML=`<h2>${s.title}</h2><p>${s.genre||''}</p>`;
      list.appendChild(c);
    });
  };

  // internal render for clean view
  window._renderCleanSerials = function(serials){
    const grid = document.getElementById('cleanSerialsGrid');
    const count = document.getElementById('cleanSerialsCount');
    if(!grid) return;
    grid.innerHTML = '';
    serials = serials || [];
    count.textContent = `${serials.length} serial${serials.length===1?'':'s'} loaded`;
    serials.forEach(s=>{
      const card = document.createElement('div');
      card.className='clean-serial-card';
      const desc = s.description ? `<div class="muted" style="margin-top:6px">${s.description.slice(0,140)}</div>` : '';
      card.innerHTML = `<div><h4 style="margin:0">${s.title}</h4><div class="serial-meta">${s.genre||''}</div>${desc}</div><div style="display:flex;gap:8px;align-items:center"><button class="btn btn-primary btn-small">Open</button></div>`;
      card.addEventListener('click', ()=>{
        // open editor or reader if exists - try to find serial by title in window.serialsData
        const idx = (window.serialsData||[]).findIndex(x=> (x.title||'').trim() === (s.title||'').trim());
        if(idx>=0){
          // open the first episode if present using existing createEditorPage if available
          try{
            if(typeof createEditorPage === 'function'){
              const ser = window.serialsData[idx];
              const epIndex = ser.episodes && ser.episodes.length ? 0 : null;
              createEditorPage(epIndex!=null? ser.episodes[epIndex].title : ser.title, ser.genre, epIndex!=null? ser.episodes[epIndex].description : ser.description, { isEdit:true, editType:'serial', index: idx, episodeIndex: epIndex });
              return;
            }
          }catch(e){ console.warn('Open serial: editor open failed', e); }
        }
        alert('Open serial: editor not available in this context.');
      });
      grid.appendChild(card);
    });
  };

  // show/hide helpers
  function openCleanSerialsPage(){
    // hide other main pages (same logic as your app)
    const pages = ['welcomePage','categoriesPage','serialCategoriesPage','dashboardPage','slidesPage','storyFormPage','profileFormPage'];
    pages.forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.classList.add('hidden');
    });
    // show our clean view
    const clean = document.getElementById('cleanSerialsPage');
    if(clean){ clean.classList.remove('hidden'); clean.setAttribute('aria-hidden','false'); }
    // attempt to render cached data immediately
    if(window.serialsData && window.serialsData.length){
      window._renderCleanSerials(window.serialsData);
      console.log(`ℹ️ Showing ${window.serialsData.length} cached serials from localStorage`);
    }
  }

  function closeCleanSerialsPage(){
    const clean = document.getElementById('cleanSerialsPage');
    if(clean){ clean.classList.add('hidden'); clean.setAttribute('aria-hidden','true'); }
    // show welcome page as fallback
    const welcome = document.getElementById('welcomePage');
    if(welcome) welcome.classList.remove('hidden');
  }

  // wire up buttons (override old handlers safely)
  const browseBtn = document.getElementById('browseSerialsBtn');
  if(browseBtn){
    browseBtn.removeEventListener && browseBtn.removeEventListener('click', ()=>{});
    browseBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      openCleanSerialsPage();
    });
  }
  const backBtn = document.getElementById('cleanSerialsBack');
  if(backBtn) backBtn.addEventListener('click', ()=>{ closeCleanSerialsPage(); });

  const refreshBtn = document.getElementById('cleanSerialsRefreshBtn');
  if(refreshBtn) refreshBtn.addEventListener('click', ()=>{ fetchAndRenderSerials(true); });

  // search filtering
  const searchInput = document.getElementById('cleanSerialsSearch');
  if(searchInput) searchInput.addEventListener('input', (e)=>{
    const q = (e.target.value||'').toLowerCase().trim();
    const filtered = (window.serialsData||[]).filter(s=>{
      return (s.title||'').toLowerCase().includes(q) || (s.genre||'').toLowerCase().includes(q) || (s.description||'').toLowerCase().includes(q);
    });
    window._renderCleanSerials(filtered);
  });

  // Firebase real-time listener & initial fetch
  async function fetchAndRenderSerials(forceReload) {
    try {
      // Use Firebase SDK directly (no window._firebase dependency)
      import("https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js").then(({ getDatabase, ref, onValue }) => {
        const db = getDatabase();
        // attach live listener
        if (window._cleanSerialsListenerAttached && !forceReload) return;
        window._cleanSerialsListenerAttached = true;

        onValue(ref(db, 'serials'), snap => {
          if (snap.exists()) {
            const obj = snap.val();
            window.serialsData = Object.values(obj);
            try { localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); } catch (e) {}
            window._renderCleanSerials(window.serialsData);
            console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
          } else {
            window.serialsData = [];
            try { localStorage.setItem('serialsData', JSON.stringify([])); } catch (e) {}
            window._renderCleanSerials([]);
            console.log('⚠️ No serials found in Firebase');
          }
        });
      }).catch(err => console.error('Firebase import failed:', err));
    } catch (err) {
      console.error('Failed to load serials for browse:', err);
    }
    
      // attach live listener (debounce multiple attachments)
      if(window._cleanSerialsListenerAttached && !forceReload) return;
      window._cleanSerialsListenerAttached = true;

      onValue(ref(db, 'serials'), snap => {
        if(snap.exists()){
          const obj = snap.val();
          window.serialsData = Object.values(obj);
          try{ localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); }catch(e){}
          window._renderCleanSerials(window.serialsData);
          console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
        } else {
          window.serialsData = [];
          try{ localStorage.setItem('serialsData', JSON.stringify([])); }catch(e){}
          window._renderCleanSerials([]);
          console.log('⚠️ No serials found in Firebase');
        }
      });
    }catch(err){
      console.error('Failed to load serials for browse:', err);
    }
  }

  // attempt to initialize listener on DOMContentLoaded (or immediately if already)
  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    fetchAndRenderSerials(false);
  } else {
    document.addEventListener('DOMContentLoaded', ()=> fetchAndRenderSerials(false));
  }

  // show cached data on load (fallback)
  try{
    const cached = JSON.parse(localStorage.getItem('serialsData') || 'null');
    if(cached && Array.isArray(cached) && cached.length){
      window.serialsData = cached;
      console.log('ℹ️ Loaded serials from localStorage cache:', window.serialsData.length);
    }
  }catch(e){}

})();
</script>
<!-- END INJECTION -->


<!-- Global fullscreen preview containers (moved outside hidden pages) -->
<div id="previewFull" class="hidden"></div>
<div id="readerFull" class="hidden"></div>
</body>

   - Uses your provided firebaseConfig (Realtime Database)
   - Will: init Firebase, load on start, sync periodically and on key events,
     and show a black status box at bottom with saving/loading states.
*/

/* ======= 1) Firebase config (use exactly what you provided) ======= */
<!-- ===== FULL FIXED FIREBASE SYNC BLOCK ===== -->
<script>
const firebaseConfig = {
  apiKey: "AIzaSyCgTh6FzKWYCGyRgBmeclvGKxuuFL3L81Y",
  authDomain: "meurbal.firebaseapp.com",
  databaseURL: "https://meurbal-default-rtdb.firebaseio.com",
  projectId: "meurbal",
  storageBucket: "meurbal.firebasestorage.app",
  messagingSenderId: "917148598257",
  appId: "1:917148598257:web:dd42e5d690b56d2ac08e50",
  measurementId: "G-EHJVB3XC90"
};

// ---- Create status box ----
(function(){
  if(document.getElementById('firebaseStatusBox')) return;
  const box=document.createElement('div');
  box.id='firebaseStatusBox';
  box.style='position:fixed;bottom:10px;left:10px;right:10px;padding:8px 12px;background:#000;color:#fff;font:13px/1.4 sans-serif;border-radius:10px;z-index:99999;display:flex;justify-content:space-between;align-items:center';
  box.innerHTML=`<div id="fbStatusText">Connecting…</div>
  <div>
    <button id="fbLoadBtn" style="background:#111;color:#fff;border:none;padding:4px 10px;border-radius:8px;cursor:pointer">Load</button>
  </div>`;
  document.body.appendChild(box);
  document.getElementById('fbLoadBtn').onclick=()=>{ if(window.loadFromFirebase) loadFromFirebase(true); };
})();
function fbSetStatus(t){ const el=document.getElementById('fbStatusText'); if(el) el.textContent=t; }

function ensureFirebase(cb){
  if(window.firebase && window.firebase.database) return cb();
  const s1=document.createElement('script'); s1.src='https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js';
  s1.onload=()=>{ const s2=document.createElement('script'); s2.src='https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js'; s2.onload=cb; document.head.appendChild(s2); };
  document.head.appendChild(s1);
}

ensureFirebase(async ()=>{
  try{
    if(!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  }catch(e){ fbSetStatus('Firebase init error'); console.error(e); return; }
  const db=firebase.database();
  fbSetStatus('Connected');

  async function saveToFirebase(){
    try{
      fbSetStatus('Saving…');
      await db.ref('meurbal_v1/stories').set(window.storiesData||[]);
      await db.ref('meurbal_v1/serials').set(window.serialsData||[]);
      fbSetStatus('Saved ✓');
    }catch(e){ console.error(e); fbSetStatus('Save error'); }
  }

  async function loadFromFirebase(force){
    try{
      fbSetStatus('Loading…');
      const [stSnap,seSnap]=await Promise.all([
        db.ref('meurbal_v1/stories').once('value'),
        db.ref('meurbal_v1/serials').once('value')
      ]);
      const stories=stSnap.val()||[], serials=seSnap.val()||[];
      if(force || !(window.storiesData&&window.storiesData.length)){
        window.storiesData=stories;
      }
      if(force || !(window.serialsData&&window.serialsData.length)){
        window.serialsData=serials;
      }
      fbSetStatus('Loaded ✓');
      if(typeof renderBrowseStories==='function') renderBrowseStories('All');
      if(typeof renderBrowseSerials==='function')
  renderBrowseSerials(serials, { mergeWithSaved: false });

    }catch(e){ console.error(e); fbSetStatus('Load error'); }
  }
  window.loadFromFirebase=loadFromFirebase;

  // ---- Auto load when app ready ----
  const wait=setInterval(()=>{
    if(window.storiesData&&window.serialsData){
      clearInterval(wait);
      loadFromFirebase();
    }
  },700);

  // ---- Auto save triggers ----
  document.addEventListener('click',e=>{
    const id=e.target&&e.target.id;
    if(['publishStoryBtn','saveDraftBtn','serialCreateConfirmBtn','addEpConfirmBtn'].includes(id)){
      setTimeout(saveToFirebase,600);
    }
  });

  // periodic auto save
  setInterval(saveToFirebase,20000);
});
</script>
<!-- ===== END FIXED BLOCK ===== -->

<!-- ===== END: Firebase sync + bottom status box ===== -->


<script>
// --- Ensure browse buttons always show updated Firebase data ---
document.addEventListener("DOMContentLoaded", () => {
  const browseStoriesBtn = document.getElementById("browseStoriesBtn");
  const browseSerialsBtn = document.getElementById("browseSerialsBtn");

  if (browseStoriesBtn) {
    browseStoriesBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "stories"));
        if (snap.exists()) {
          window.storiesData = Object.values(snap.val());
        }
        renderStoriesList(window.storiesData || []);
      } catch (e) {
        console.warn("Failed to load stories for browse:", e);
        renderStoriesList(window.storiesData || []);
      }
    });
  }

  if (browseSerialsBtn) {
    browseSerialsBtn.addEventListener("click", async () => {
      try {
        const { db, ref, get, child } = window._firebase;
        const snap = await get(child(ref(db), "serials"));
        if (snap.exists()) {
          window.serialsData = Object.values(snap.val());
        }
        renderSerialsList(window.serialsData || []);
      } catch (e) {
        console.warn("Failed to load serials for browse:", e);
        renderSerialsList(window.serialsData || []);
      }
    });
  }
});
</script>


<!-- CLEAN SERIALS VIEW INJECTION: replaces broken browse serials behavior -->
<style>
  /* clean serials view styles (keeps existing theme) */
  #cleanSerialsPage { padding:20px; min-height:100vh; background:var(--bg); display:none; }
  #cleanSerialsHeader{display:flex;align-items:center;justify-content:space-between;max-width:980px;margin:0 auto 12px;gap:12px}
  #cleanSerialsGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;max-width:980px;margin:12px auto;padding:12px}
  .clean-serial-card{background:#fff;border-radius:12px;padding:18px;box-shadow:var(--shadow);min-height:140px;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;transition:transform .18s}
  .clean-serial-card:hover{transform:translateY(-6px)}
  .serial-meta{color:var(--muted);font-size:13px}
  #cleanSerialsTop{display:flex;gap:12px;align-items:center;width:100%;max-width:980px;margin:0 auto}
  #cleanSerialsCount{font-weight:700}
  #cleanSerialsSearch{flex:1;padding:10px;border:1px solid var(--border);border-radius:8px}
  #cleanSerialsBack{position:fixed;left:14px;bottom:14px}
</style>

<div id="cleanSerialsPage" aria-hidden="true">
  <div id="cleanSerialsHeader">
    <div>
      <h2 style="margin:0">Browse Serials</h2>
      <div class="muted" id="cleanSerialsCount">Loading...</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <input id="cleanSerialsSearch" placeholder="Search serials..." />
      <button id="cleanSerialsRefreshBtn" class="btn btn-secondary">Refresh</button>
    </div>
  </div>

  <div id="cleanSerialsGrid" aria-live="polite" role="list"></div>
  <button class="back-btn" id="cleanSerialsBack">← Back</button>
</div>

<script>
(function(){
  // ensure helper functions exist globally for legacy callers
  window.renderSerialsList = function(serials){
    // maintain compatibility - forward to clean renderer if available
    if(window._renderCleanSerials) return window._renderCleanSerials(serials);
    const list = document.getElementById('serialsCards');
    if(!list) return;
    list.innerHTML = '';
    (serials||[]).forEach(s=>{
      const c=document.createElement('div');
      c.className='story-card';
      c.innerHTML=`<h2>${s.title}</h2><p>${s.genre||''}</p>`;
      list.appendChild(c);
    });
  };

  // internal render for clean view
  window._renderCleanSerials = function(serials){
    const grid = document.getElementById('cleanSerialsGrid');
    const count = document.getElementById('cleanSerialsCount');
    if(!grid) return;
    grid.innerHTML = '';
    serials = serials || [];
    count.textContent = `${serials.length} serial${serials.length===1?'':'s'} loaded`;
    serials.forEach(s=>{
      const card = document.createElement('div');
      card.className='clean-serial-card';
      const desc = s.description ? `<div class="muted" style="margin-top:6px">${s.description.slice(0,140)}</div>` : '';
      card.innerHTML = `<div><h4 style="margin:0">${s.title}</h4><div class="serial-meta">${s.genre||''}</div>${desc}</div><div style="display:flex;gap:8px;align-items:center"><button class="btn btn-primary btn-small">Open</button></div>`;
      card.addEventListener('click', ()=>{
        // open editor or reader if exists - try to find serial by title in window.serialsData
        const idx = (window.serialsData||[]).findIndex(x=> (x.title||'').trim() === (s.title||'').trim());
        if(idx>=0){
          // open the first episode if present using existing createEditorPage if available
          try{
            if(typeof createEditorPage === 'function'){
              const ser = window.serialsData[idx];
              const epIndex = ser.episodes && ser.episodes.length ? 0 : null;
              createEditorPage(epIndex!=null? ser.episodes[epIndex].title : ser.title, ser.genre, epIndex!=null? ser.episodes[epIndex].description : ser.description, { isEdit:true, editType:'serial', index: idx, episodeIndex: epIndex });
              return;
            }
          }catch(e){ console.warn('Open serial: editor open failed', e); }
        }
        alert('Open serial: editor not available in this context.');
      });
      grid.appendChild(card);
    });
  };

  // show/hide helpers
  function openCleanSerialsPage(){
    // hide other main pages (same logic as your app)
    const pages = ['welcomePage','categoriesPage','serialCategoriesPage','dashboardPage','slidesPage','storyFormPage','profileFormPage'];
    pages.forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.classList.add('hidden');
    });
    // show our clean view
    const clean = document.getElementById('cleanSerialsPage');
    if(clean){ clean.classList.remove('hidden'); clean.setAttribute('aria-hidden','false'); }
    // attempt to render cached data immediately
    if(window.serialsData && window.serialsData.length){
      window._renderCleanSerials(window.serialsData);
      console.log(`ℹ️ Showing ${window.serialsData.length} cached serials from localStorage`);
    }
  }

  function closeCleanSerialsPage(){
    const clean = document.getElementById('cleanSerialsPage');
    if(clean){ clean.classList.add('hidden'); clean.setAttribute('aria-hidden','true'); }
    // show welcome page as fallback
    const welcome = document.getElementById('welcomePage');
    if(welcome) welcome.classList.remove('hidden');
  }

  // wire up buttons (override old handlers safely)
  const browseBtn = document.getElementById('browseSerialsBtn');
  if(browseBtn){
    browseBtn.removeEventListener && browseBtn.removeEventListener('click', ()=>{});
    browseBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      openCleanSerialsPage();
    });
  }
  const backBtn = document.getElementById('cleanSerialsBack');
  if(backBtn) backBtn.addEventListener('click', ()=>{ closeCleanSerialsPage(); });

  const refreshBtn = document.getElementById('cleanSerialsRefreshBtn');
  if(refreshBtn) refreshBtn.addEventListener('click', ()=>{ fetchAndRenderSerials(true); });

  // search filtering
  const searchInput = document.getElementById('cleanSerialsSearch');
  if(searchInput) searchInput.addEventListener('input', (e)=>{
    const q = (e.target.value||'').toLowerCase().trim();
    const filtered = (window.serialsData||[]).filter(s=>{
      return (s.title||'').toLowerCase().includes(q) || (s.genre||'').toLowerCase().includes(q) || (s.description||'').toLowerCase().includes(q);
    });
    window._renderCleanSerials(filtered);
  });

  // Firebase real-time listener & initial fetch
  async function fetchAndRenderSerials(forceReload) {
    try {
      // Use Firebase SDK directly (no window._firebase dependency)
      import("https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js").then(({ getDatabase, ref, onValue }) => {
        const db = getDatabase();
        // attach live listener
        if (window._cleanSerialsListenerAttached && !forceReload) return;
        window._cleanSerialsListenerAttached = true;

        onValue(ref(db, 'serials'), snap => {
          if (snap.exists()) {
            const obj = snap.val();
            window.serialsData = Object.values(obj);
            try { localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); } catch (e) {}
            window._renderCleanSerials(window.serialsData);
            console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
          } else {
            window.serialsData = [];
            try { localStorage.setItem('serialsData', JSON.stringify([])); } catch (e) {}
            window._renderCleanSerials([]);
            console.log('⚠️ No serials found in Firebase');
          }
        });
      }).catch(err => console.error('Firebase import failed:', err));
    } catch (err) {
      console.error('Failed to load serials for browse:', err);
    }
    
      // attach live listener (debounce multiple attachments)
      if(window._cleanSerialsListenerAttached && !forceReload) return;
      window._cleanSerialsListenerAttached = true;

      onValue(ref(db, 'serials'), snap => {
        if(snap.exists()){
          const obj = snap.val();
          window.serialsData = Object.values(obj);
          try{ localStorage.setItem('serialsData', JSON.stringify(window.serialsData)); }catch(e){}
          window._renderCleanSerials(window.serialsData);
          console.log(`✅ Loaded ${window.serialsData.length} serials from Firebase`);
        } else {
          window.serialsData = [];
          try{ localStorage.setItem('serialsData', JSON.stringify([])); }catch(e){}
          window._renderCleanSerials([]);
          console.log('⚠️ No serials found in Firebase');
        }
      });
    }catch(err){
      console.error('Failed to load serials for browse:', err);
    }
  }

  // attempt to initialize listener on DOMContentLoaded (or immediately if already)
  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    fetchAndRenderSerials(false);
  } else {
    document.addEventListener('DOMContentLoaded', ()=> fetchAndRenderSerials(false));
  }

  // show cached data on load (fallback)
  try{
    const cached = JSON.parse(localStorage.getItem('serialsData') || 'null');
    if(cached && Array.isArray(cached) && cached.length){
      window.serialsData = cached;
      console.log('ℹ️ Loaded serials from localStorage cache:', window.serialsData.length);
    }
  }catch(e){}

})();
</script>
<!-- END INJECTION -->


<!-- Global fullscreen preview containers (moved outside hidden pages) -->
<div id="previewFull" class="hidden"></div>
<div id="readerFull" class="hidden"></div>
</body>

</html>
