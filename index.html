
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Writer App — Slots UI Improved (fixed v2)</title>
  <style>
    :root{ --bg:#f9fafb;--accent:#4f46e5;--muted:#6b7280; --shadow:0 4px 14px rgba(0,0,0,0.08);--border:#e5e7eb; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter, system-ui, -apple-system, Arial,sans-serif;background:var(--bg);color:#111827;font-size:16px;line-height:1.45;}
    h1,h2{margin:16px 0;text-align:center}
    button,input,select,textarea{font-family:inherit;font-size:14px}
    .btn{padding:14px 20px;border:none;border-radius:14px;cursor:pointer;font-weight:700;transition:0.18s;box-shadow:0 8px 24px rgba(79,70,229,0.12)}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-secondary{background:#e5e7eb;color:#111;border:1px solid #d1d5db}
    .btn:hover{opacity:0.95;transform:translateY(-1px)}
    .hidden{display:none!important}

.story-analytics-modal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.45);
  z-index: 9999;
  padding: 20px;
  box-sizing: border-box;
}
.story-analytics-card {
  width: min(980px, 96%);
  max-height: 90vh;
  overflow: auto;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.25);
  padding: 18px;
  box-sizing: border-box;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}
.analytics-header {
  display:flex;
  gap:12px;
  align-items:center;
  justify-content:space-between;
  margin-bottom:12px;
  flex-wrap:wrap;
}
.analytics-title { font-size:20px; font-weight:700; }
.analytics-summary {
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}
.summary-pill {
  padding:8px 12px;
  border-radius:10px;
  background:#f3f4f6;
  font-weight:600;
}
.status-pill {
  padding:8px 12px;
  border-radius:10px;
  font-weight:700;
  display:inline-block;
}
.analytics-body { margin-top:8px; }
.canvas-wrap { width:100%; height:360px; background:#fff; border-radius:8px; padding:10px; box-sizing:border-box; }
.legend { margin-top:8px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
.legend-item { display:flex; gap:6px; align-items:center; font-size:13px; }
.legend-swatch { width:14px; height:6px; border-radius:2px; display:inline-block; }
.close-analytics {
  background:transparent;
  border:0;
  font-size:18px;
  cursor:pointer;
}
.small-note { color:#6b7280; font-size:13px; margin-top:8px; }

    /* Header */
    header{position:fixed;top:12px;left:12px;z-index:60}
    .profile-btn{width:56px;height:56px;border-radius:50%;background:white; box-shadow:0 10px 30px rgba(0,0,0,0.12); display:flex;align-items:center;justify-content:center; border:none;cursor:pointer;overflow:hidden;font-size:16px}
    .profile-initials{font-weight:700;color:var(--accent);font-size:16px}
    .dropdown{position:absolute;background:white;border:1px solid var(--border);border-radius:10px; box-shadow:0 4px 14px rgba(0,0,0,0.08);padding:8px;display:none;flex-direction:column; min-width:220px;z-index:55}
    .dropdown button{background:transparent;border:none;padding:10px;border-radius:8px;text-align:left;cursor:pointer;font-size:15px}
    .dropdown button:hover{background:#f3f4f6}

    /* Main */
    main{display:flex;flex-direction:column;align-items:center;justify-content:center; height:100vh;text-align:center;padding:20px}
    .buttons{display:flex;flex-direction:column;gap:12px;align-items:center}
    .btn-small{padding:10px 16px;font-size:16px;border-radius:12px}

.jelly-btn {
  background-color: white;
  color: #333; /* dark text */
  font-weight: bold;
  padding: 10px 25px;
  border: 2px solid #ccc;
  border-radius: 50px;
  cursor: pointer;
  font-size: 16px;
  position: relative;
  overflow: hidden;
  outline: none;
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
}

.jelly-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 8px 15px rgba(0,0,0,0.2);
  border-color: #888;
}

.jelly-btn:active {
  animation: jelly 0.6s;
}

/* Wobble animation */
@keyframes jelly {
  0% { transform: scale(1, 1); }
  25% { transform: scale(1.2, 0.8); }
  50% { transform: scale(0.8, 1.2); }
  75% { transform: scale(1.1, 0.9); }
  100% { transform: scale(1, 1); }
}

    /* Form */
    .form-container{max-width:680px;margin:40px auto;padding:24px;background:#fff;border-radius:12px;box-shadow:var(--shadow)}
    label{display:block;margin:8px 0 4px;font-weight:600;color:var(--muted)}
    input,select,textarea{width:100%;padding:10px;border:1px solid var(--border);border-radius:8px;margin-bottom:12px}
    .genres-container{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;margin-bottom:16px}
    .genre-option{padding:8px 14px;border:1px solid var(--border);border-radius:20px;cursor:pointer; background:#f9fafb;transition:0.2s}
    .genre-option.active{background:var(--accent);color:#fff;border-color:var(--accent)}

    /* Dashboard */
    #dashboardPage{padding:24px;min-height:100vh}
    .dashboard-header{display:flex;flex-direction:column;align-items:center;margin-bottom:20px;gap:12px;text-align:center}
    .dashboard-card{padding:16px;background:#fff;margin-bottom:12px;border-radius:12px;box-shadow:var(--shadow);display:flex;justify-content:space-between;gap:8px;align-items:center}
    .dashboard-card .meta{color:var(--muted);font-size:13px;margin-top:6px}
    .dashboard-card h3{margin:0;font-size:18px}
    .dashboard-card p{margin:6px 0;color:#111827}
    .dashboard-card .desc{color:#374151}
    .status-public{color:green;font-weight:700}
    .status-draft{color:#b45309;font-weight:700}
    .card-actions{display:flex;gap:8px;align-items:center}
    .small-btn{padding:6px 10px;border-radius:8px;font-weight:600}

    /* Editor Page */
    #editorPage{position:fixed;inset:0;background:var(--bg);z-index:100;display:flex;flex-direction:column;padding:18px;gap:12px}
    .sheets-bar{display:flex;gap:8px;overflow-x:auto;padding-bottom:8px}
    .sheet-thumb{position:relative;min-width:180px;min-height:80px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:12px;font-size:14px;box-shadow:0 6px 18px rgba(0,0,0,0.08);cursor:pointer;white-space:pre-wrap;overflow:hidden;text-overflow:ellipsis}
    .sheet-thumb.active{border:2px solid var(--accent)}
    .sheet-thumb .del{position:absolute;top:6px;right:6px;background:transparent;border:none;font-size:12px;cursor:pointer;padding:4px;border-radius:4px}
    .add-sheet-btn{min-width:40px;min-height:60px;border:1px dashed var(--accent);border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:bold;color:var(--accent);cursor:pointer;flex-shrink:0}
    .sheet-textarea{flex:1;padding:18px;border:1px solid var(--border);border-radius:12px;font-size:16px;resize:none;min-height:320px}
    .editor-actions{display:flex;gap:12px;justify-content:flex-end;margin-top:8px}

    /* Slots Page */
    #slotsContainer{display:flex;gap:24px;flex-wrap:wrap;justify-content:center;padding:16px}
    .slot-card{width:260px;height:220px;background:#fff;border-radius:20px;display:flex;align-items:center;justify-content:center;flex-direction:column;cursor:pointer;position:relative;box-shadow:0 14px 40px rgba(0,0,0,0.14);font-size:18px;text-align:center;transition:all 0.22s;padding:16px}
    .slot-card:hover{transform:translateY(-4px);box-shadow:0 10px 24px rgba(0,0,0,0.15)}
    .slot-card.locked{background:#f3f4f6;color:#111827;font-weight:600}
    .slot-card.locked::before{content:"🔒";font-size:24px;position:absolute;top:8px;right:8px}
    .slot-card .slot-title{font-weight:700;margin-bottom:6px}
    .slot-card .slot-meta{font-size:13px;color:var(--muted)}

    /* Popups */
    .popup { position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);z-index:300}
    .popup .popup-content{background:#fff;padding:20px;border-radius:12px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.15);max-width:520px;width:92%}
    .popup input{width:100%;padding:10px;margin-bottom:12px;border:1px solid var(--border);border-radius:8px;font-size:16px}

    /* Back button (left bottom) */
    .back-btn{position:fixed;left:18px;bottom:18px;background:#fff;color:#111;padding:10px 14px;border-radius:12px;border:1px solid var(--border);cursor:pointer;font-weight:700;box-shadow:0 8px 30px rgba(0,0,0,0.12)}
    .back-btn .icon{margin-right:8px}

    /* small helpers */
    .row{display:flex;gap:12px;align-items:center;justify-content:center}
    .muted{color:var(--muted)}
  
    
    /* Smaller and mobile-friendly categories */
    #categoriesPage, #serialCategoriesPage {padding:20px;min-height:100vh;display:flex;flex-direction:column;align-items:center;gap:14px;background:var(--bg)}
    .categories-header{max-width:800px;width:100%;text-align:center}
    .categories-grid{display:flex;gap:10px;flex-wrap:nowrap;overflow-x:auto;padding:8px 4px;width:100%;justify-content:center}
    .cat-card{flex:0 0 auto;padding:12px 18px;border-radius:14px;background:#fff;box-shadow:var(--shadow);min-width:110px;text-align:center;cursor:pointer;border:1px solid var(--border);transition:transform .15s, box-shadow .15s}
    .cat-card .cat-title{font-weight:700;margin-bottom:4px;font-size:14px}
    .cat-card .cat-sub{font-size:12px;color:var(--muted)}
    .cat-card:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,0.08)}
    .cat-card.active{background:linear-gradient(135deg,var(--accent),#7c3aed);color:#fff;border-color:transparent;box-shadow:0 14px 35px rgba(79,70,229,0.18)}
    .categories-grid::-webkit-scrollbar{height:6px}
    .categories-grid::-webkit-scrollbar-thumb{background:#d1d5db;border-radius:6px}
    #categoriesBackBtn, #serialCategoriesBackBtn{position:fixed;left:14px;bottom:14px}



    /* full-width story cards */
   #storiesCards {
  display: flex;
  flex-direction: column;
  gap: 32px;
  width: 100%;
  align-items: center;
}

.story-card {
  width: 280px;
  height: 420px;
  background: linear-gradient(180deg, #fdf6f0, #e0d8c0);
  border-radius: 14px;
  padding: 24px;
  color: #0f172a;
  box-shadow: 0 10px 25px rgba(0,0,0,0.25);
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  position: relative;
  font-family: 'Georgia', serif;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.story-card:hover {
  transform: translateY(-5px) scale(1.02);
  box-shadow: 0 15px 30px rgba(0,0,0,0.3);
}

.story-card::before {
  content: "";
  position: absolute;
  inset: 0;
  background: url('your-cover-image.jpg') center/cover no-repeat;
  opacity: 0.15;
  pointer-events: none;
}

.story-card h2 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.story-card p {
  margin: 4px 0 0;
  font-size: 1rem;
  font-style: italic;
  text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
}

.story-card .read-btn,
.story-card .view-serial-btn {
  margin-top: 12px;
  padding: 8px 16px;
  border: none;
  background: #1e40af;
  color: #fff;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.2s ease;
}

.story-card .read-btn:hover,
.story-card .view-serial-btn:hover {
  background: #1e3a8a;
}
.scroll-wrap {
  display: flex;
  overflow-x: auto;
  gap: 12px;
  padding: 12px;
  scroll-behavior: smooth;
  flex-wrap: nowrap;
  position: relative; /* important for overlay effect */
}

    /* Fullscreen preview */
    .fullscreen-panel{position:fixed;inset:0;background:var(--bg);z-index:800;display:flex;flex-direction:column;padding:22px;overflow:auto}
    .fullscreen-panel .panel-inner{max-width:1100px;margin:12px auto;display:flex;flex-direction:column;gap:12px}
    .panel-top{display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
    .panel-meta{color:var(--muted)}
    /* Fullscreen reader */
    .reader-full{position:fixed;inset:0;background:#ffffff;z-index:900;display:flex;flex-direction:column;padding:18px;overflow:auto}
    .reader-header{display:flex;justify-content:space-between;align-items:center}
    .reader-body{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center;padding:12px}
    .reader-sheet{width:100%;max-width:980px;border-radius:10px;padding:18px;min-height:240px;font-size:18px;line-height:1.6;background:linear-gradient(180deg,#fff,#fbfbff);box-shadow:0 12px 40px rgba(0,0,0,0.06)}


/* Added tweaks for murbal: ensure story cards use full-color gradient and fixed height */
.story-card{ color:#0f172a; border-radius:12px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,0.08); min-height:180px; display:flex; flex-direction:column; justify-content:space-between; }
.story-card h4{ margin:0; font-size:18px; font-weight:700; }
.story-card p{ margin:0; }

</style>
</head>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { getDatabase, ref, set, get, child } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCgTh6FzKWYCGyRgBmeclvGKxuuFL3L81Y",
    authDomain: "meurbal.firebaseapp.com",
    databaseURL: "https://meurbal-default-rtdb.firebaseio.com",
    projectId: "meurbal",
    storageBucket: "meurbal.firebasestorage.app",
    messagingSenderId: "917148598257",
    appId: "1:917148598257:web:dd42e5d690b56d2ac08e50",
    measurementId: "G-EHJVB3XC90"
  };

  // initialize
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // Status box
  const statusBox = document.createElement('div');
  statusBox.id = '__firebase_status_box';
  statusBox.textContent = "🟡 Firebase: Connecting...";
  statusBox.style.cssText = "position:fixed;right:12px;bottom:12px;padding:8px 12px;border-radius:10px;background:#fff;font-weight:700;box-shadow:0 8px 30px rgba(0,0,0,0.12);z-index:99999";
  document.addEventListener('DOMContentLoaded', ()=> document.body.appendChild(statusBox));

  // small helper to set status
  function setStatus(text, colorBg){
    try{ statusBox.textContent = text; if(colorBg) statusBox.style.background = colorBg; }catch(e){}
  }

  // test connectivity by reading root once
  get(ref(db, '/')).then(()=>{
    setStatus('🟢 Firebase: Connected', '#dcfce7');
  }).catch(()=>{
    setStatus('🔴 Firebase: Offline', '#fee2e2');
  });

  // expose minimal API for the page to use
  window._firebase = {
    app, db, ref, set, get, child
  };
</script>


<body>
  <header>
    <button class="profile-btn" id="profileBtn"><span class="profile-initials">??</span></button>
    <div class="dropdown" id="profileDropdown"></div>
  </header>

  <main id="welcomePage">
    <h1>Welcome!</h1>
    <div class="buttons">
      <button id="browseStoriesBtn" class="btn btn-primary btn-small">📖 Browse Stories</button>
      <button id="browseSerialsBtn" class="btn btn-secondary btn-small">🎬 Browse Serials</button>
      <button id="createContentBtn" class="btn btn-primary btn-small">✍️ Create Story / Serial</button>
    </div>
  </main>


  <!-- Categories Page (opened from Browse Stories) -->
  <div id="categoriesPage" class="hidden">
    <button class="back-btn" id="categoriesBackBtn">← Back</button>
    <div class="categories-header">
      <h2>Browse Stories</h2>
    </div>
    <div style="max-width:980px;margin:8px auto 0;display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div style="flex:1">
        <input id="storiesSearchInput" placeholder="Search your stories..." style="width:100%;padding:10px;border:1px solid var(--border);border-radius:8px" />
      </div>
      <div style="min-width:140px;text-align:right">
        <button id="storiesClearSearchBtn" class="btn btn-secondary" style="padding:8px 10px">Clear</button>
      </div>
    </div>

    <div class="categories-grid" id="categoriesGrid" aria-label="story categories">
      <!-- Stories list shown after selecting a category -->
      </div>
      <div id="storiesBrowseList" style="max-width:980px;margin:18px auto;display:none">
        <h3 style="text-align:left;margin:6px 12px">Stories</h3>
        <div id="storiesCards" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:12px"></div>
      </div>
      <!-- Fullscreen Preview & Reader Containers -->
  <div id="previewFull" class="hidden"></div>

  <div id="readerFull" class="hidden"></div>


      <div id="readerModal" class="hidden popup">
        <div class="popup-content" style="width:90%;max-width:900px;padding:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <h3 id="readerTitle">Story</h3>
              <div class="muted" id="readerMeta"></div>
            </div>
            <div style="display:flex;gap:8px">
              <button id="readerDownloadBtn" class="btn btn-secondary">Download Story</button>
              <button id="readerLikeBtn" class="btn btn-secondary">👍 Like <span id="readerLikeCount">0</span></button>
              <button id="readerDislikeBtn" class="btn btn-secondary">👎 Dislike <span id="readerDislikeCount">0</span></button>
              <button id="readerCloseBtn" class="btn btn-secondary">Close</button>
            </div>
          </div>
          <div id="readerContent" style="min-height:260px;padding:12px;margin-top:12px;border-radius:8px;background:#fff;overflow:hidden;position:relative">
            <div id="readerSheet" style="min-height:200px"></div>
          </div>
          <div style="display:flex;justify-content:center;gap:12px;margin-top:12px">
            <button id="readerPrevBtn" class="btn btn-secondary">◀ Prev</button>
            <span id="readerPager" class="muted"></span>
            <button id="readerNextBtn" class="btn btn-primary">Next ▶</button>
          </div>
        </div>
      </div>

      <!-- cards injected by JS -->
    </div>
  </div>

  
  <!-- Serials Categories Page -->
  <div id="serialCategoriesPage" class="hidden">
    <button class="back-btn" id="serialCategoriesBackBtn">← Back</button>
    <div class="categories-header">
      <h2>Browse Serial Categories</h2>
      <div style="max-width:980px;margin:8px auto 0;display:flex;gap:8px;align-items:center;justify-content:space-between">
        <div style="flex:1">
          <input id="serialsSearchInput" placeholder="Search your serials..." style="width:100%;padding:10px;border:1px solid var(--border);border-radius:8px" />
        </div>
        <div style="min-width:140px;text-align:right">
          <button id="serialsClearSearchBtn" class="btn btn-secondary" style="padding:8px 10px">Clear</button>
        </div>
      </div>
      <div id="serialSearchResults" style="max-width:980px;margin:12px auto;display:none">
        <div id="serialsCards" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:12px"></div>
      </div>

      <p class="muted" style="margin:6px 0 12px">Choose a genre to explore serials. Swipe or scroll horizontally to see all categories.</p>
    </div>
    <div class="categories-grid" id="serialCategoriesGrid" aria-label="serial categories">
      <!-- serial cards injected by JS -->
    </div>
  </div>

  <!-- Profile Form -->
  <div id="profileFormPage" class="form-container hidden">
    <h2>Create Writer Profile</h2>
    <label>Name</label><input type="text" id="profileName">
    <label>Age</label><input type="number" id="profileAge">
    <label>Country</label><input type="text" id="profileCountry">
    <label>Favourite Genres</label>
    <div class="genres-container" id="genresContainer">
      <label class="genre-option"><input type="checkbox" value="Horror">Horror</label>
      <label class="genre-option"><input type="checkbox" value="Comedy">Comedy</label>
      <label class="genre-option"><input type="checkbox" value="Action">Action</label>
      <label class="genre-option"><input type="checkbox" value="Tragic">Tragic</label>
      <label class="genre-option"><input type="checkbox" value="Romance">Romance</label>
      <label class="genre-option"><input type="checkbox" value="Fantasy">Fantasy</label>
      <label class="genre-option"><input type="checkbox" value="Thriller">Thriller</label>
         <label class="genre-option"><input type="checkbox" value="Adventure">Adventure</label>
      <label class="genre-option"><input type="checkbox" value="Crime">Crime</label>
      <label class="genre-option"><input type="checkbox" value="Historic">Historic</label>
    </div>
    <button class="btn btn-primary" id="saveProfileBtn">Create Profile</button>
  </div>

  <!-- Choose Type Popup -->
  <div id="chooseTypePopup" class="hidden popup">
    <div class="popup-content">
      <h2>What do you want to create?</h2>
      <div style="display:flex;gap:12px;justify-content:center;margin-top:12px">
        <button id="createStoryBtn" class="btn btn-primary">Story</button>
        <button id="createSerialBtn" class="btn btn-secondary">Serial</button>
      </div>
    </div>
  </div>

  <!-- Slot Name / Unlock Popup -->
  <div id="slotNamePopup" class="hidden popup">
    <div class="popup-content">
      <h3>Name this slot</h3>
      <input id="slotNameInput" placeholder='Slot name (e.g. "My Fantasy Series")'>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
        <button id="slotNameCancelBtn" class="btn btn-secondary">Cancel</button>
        <button id="slotNameUnlockBtn" class="btn btn-primary">Unlock Slot</button>
      </div>
    </div>
  </div>

  <!-- Serial Create Popup (series + episode1) -->
 <div id="serialCreatePopup" class="hidden popup">
  <div class="popup-content" style="max-width:480px;padding:16px;">
    <h3 style="margin-bottom:8px;">Create / Edit Serial</h3>

    <!-- Series Section -->
    <div style="margin-bottom:8px;">
      <label style="font-weight:600;">Series Title</label>
      <input id="seriesTitleInput" placeholder="e.g. The Lost Scrolls" style="margin-bottom:6px;">
      <label>Genre</label>
      <select id="seriesGenreInput" style="margin-bottom:6px;">
        <option value="">Select genre</option>
        <option>Comedy</option>
        <option>Fantasy</option>
        <option>Horror</option>
        <option>Romance</option>
        <option>Action</option>
        <option>Tragic</option>
        <option>Thriller</option>
        <option>Adventure</option>
        <option>Crime</option>
        <option>Historic</option>
      </select>
      <label>Description (optional)</label>
      <textarea id="seriesDescInput" rows="2" placeholder="Short series description" style="margin-bottom:6px;"></textarea>
    </div>

    <!-- Tags -->
    <div style="margin-bottom:10px;">
      <label>Tags</label>
      <div style="display:flex;gap:6px;align-items:center;margin-top:4px;margin-bottom:6px;">
        <input id="seriesTagInput" placeholder="type a tag" style="flex:1;padding:8px;border-radius:6px;border:1px solid var(--border)">
        <button id="addSeriesTagBtn" class="btn btn-secondary" type="button" style="padding:6px 10px;">Add</button>
      </div>
      <div id="seriesTagsContainer" style="display:flex;flex-wrap:wrap;gap:6px;"></div>
    </div>

    <hr style="margin:10px 0;opacity:0.5;">

    <!-- Episode Section -->
    <div style="margin-bottom:8px;">
      <label style="font-weight:600;">Episode 1</label>
      <input id="ep1TitleInput" placeholder="Episode 1 title" style="margin-bottom:6px;">
      <textarea id="ep1DescInput" rows="2" placeholder="Short episode description" style="margin-bottom:6px;"></textarea>

      <!-- Cover -->
      <label>Series Cover</label>
      <input type="file" id="serialCoverInput" accept="image/*">
      <div id="serialCoverPreview" style="margin-top:6px;text-align:center;">
        <img id="serialCoverImg" src="" alt="Cover Preview"
          style="max-width:100px;height:180px;object-fit:cover;border-radius:8px;display:none;">
      </div>
    </div>

    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
      <button id="serialCreateCancelBtn" class="btn btn-secondary" style="padding:6px 12px;">Cancel</button>
      <button id="serialCreateConfirmBtn" class="btn btn-primary" style="padding:6px 12px;">Create / Update</button>
    </div>
  </div>
</div>


  <!-- Add Episode Popup -->
  <div id="addEpisodePopup" class="hidden popup">
    <div class="popup-content">
      <h3>Add Episode</h3>
      <label>Episode Title</label>
      <input id="addEpTitleInput" placeholder="Episode title">
      <label>Episode Description (optional)</label>
      <textarea id="addEpDescInput" rows="2" placeholder="Episode description"></textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="addEpCancelBtn" class="btn btn-secondary">Cancel</button>
        <button id="addEpConfirmBtn" class="btn btn-primary">Add Episode</button>
      </div>
    </div>
  </div>

  <!-- Slots Page -->
  <div id="slidesPage" class="hidden">
    <button class="back-btn" id="slotsBackBtn">← Back</button>
    <h2 style="text-align:center;margin-top:30px">Select a Slot</h2>
    <div id="slotsContainer"></div>
  </div>

  <!-- Story Form -->
  <div id="storyFormPage" class="form-container hidden">
    <h2>Create Story / Serial</h2>
    <label>Title</label><input type="text" id="storyTitle">
    <label>Genre</label>
    <select id="storyGenre">
      <option value="">Select genre</option>
      <option>Horror</option><option>Comedy</option><option>Action</option>
      <option>Romance</option><option>Tragic</option><option>Fantasy</option>
      <option>Thriller</option><option>Adventure</option><option>Crime</option>
       <option>Historic</option>
    </select>
    <label>Description</label>
    <textarea id="storyDesc" rows="3"></textarea>
    <label>Cover Image</label>
<input type="file" id="storyCoverInput" accept="image/*">

    <div id="storyCoverPreview" style="margin-top:10px;text-align:center;">
      <img id="storyCoverImg" src="" alt="Cover Preview" style="max-width:120px;height:220px;object-fit:cover;border-radius:12px;display:none;">
    </div>
    <!-- Story Tags UI (paste after storyDesc) -->
<label>Tags (press Add)</label>
<div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
  <input id="storyTagInput" placeholder="type a tag and press Add" style="flex:1;padding:10px;border-radius:8px;border:1px solid var(--border)" />
  <button id="addStoryTagBtn" class="btn btn-secondary" type="button">Add</button>
</div>
<div id="storyTagsContainer" style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px"></div>

    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button class="btn btn-secondary" id="cancelCreateBtn">Cancel</button>
      <button class="btn btn-primary" id="startCreatingBtn">Start Creating</button>
    </div>
  </div>

  <!-- Dashboard -->
<div id="dashboardPage" class="hidden">
  <div class="dashboard-header">
    <h2>Your Content</h2>
    <div class="row">
      <button class="btn btn-primary" id="showStoriesBtn">Your Stories</button>
      <button class="btn btn-secondary" id="showSerialsBtn">Your Serials</button>
    </div>
  </div>

  <div id="dashboardList"></div>
  <button class="back-btn hidden" id="dashboardBackBtn">← Back</button>
</div>


  <script>
    // ---------- Variables ----------
    const STORAGE_KEY = "writerProfile_v1";

    // palette for random card colors (bright)
    const CARD_COLOR_PALETTE = ['#FF6B6B','#FF8A65','#FFB86B','#FFD166','#6EE7B7','#4FD1FF','#60A5FA','#A78BFA','#FF7AB6','#2DD4BF'];
    function pickCardColor(){ return CARD_COLOR_PALETTE[Math.floor(Math.random()*CARD_COLOR_PALETTE.length)]; }

    let profileExists = false, storiesData = [], serialsData = [];
    let storySlots = [], serialSlots = [];
    let currentType = 'story', selectedSlot = null;

    // Elements
    const profileBtn = document.getElementById('profileBtn');
    const profileDropdown = document.getElementById('profileDropdown');
    const profileFormPage = document.getElementById('profileFormPage');
    const saveProfileBtn = document.getElementById('saveProfileBtn');
    const profileName = document.getElementById('profileName');
    const profileAge = document.getElementById('profileAge');
    const profileCountry = document.getElementById('profileCountry');
    const welcomePage = document.getElementById('welcomePage');
    const createContentBtn = document.getElementById('createContentBtn');
    const storyFormPage = document.getElementById('storyFormPage');
    const storyTitleInput = document.getElementById('storyTitle');
    const storyGenreSelect = document.getElementById('storyGenre');
    const storyDescInput = document.getElementById('storyDesc');
    const startCreatingBtn = document.getElementById('startCreatingBtn');
    const dashboardPage = document.getElementById('dashboardPage');
    const dashboardList = document.getElementById('dashboardList');
    const slidesPage = document.getElementById('slidesPage');
    const slotsContainer = document.getElementById('slotsContainer');
    const chooseTypePopup = document.getElementById('chooseTypePopup');
    const createStoryBtn = document.getElementById('createStoryBtn');
    const createSerialBtn = document.getElementById('createSerialBtn');
    const showStoriesBtn = document.getElementById('showStoriesBtn');
    const showSerialsBtn = document.getElementById('showSerialsBtn');
    const slotsBackBtn = document.getElementById('slotsBackBtn');
    const dashboardBackBtn = document.getElementById('dashboardBackBtn');
    const cancelCreateBtn = document.getElementById('cancelCreateBtn');

    // new popups
    const slotNamePopup = document.getElementById('slotNamePopup');
    const slotNameInput = document.getElementById('slotNameInput');
    const slotNameUnlockBtn = document.getElementById('slotNameUnlockBtn');
    const slotNameCancelBtn = document.getElementById('slotNameCancelBtn');

    const serialCreatePopup = document.getElementById('serialCreatePopup');
    const seriesTitleInput = document.getElementById('seriesTitleInput');
    const seriesGenreInput = document.getElementById('seriesGenreInput');
    const seriesDescInput = document.getElementById('seriesDescInput');
    const ep1TitleInput = document.getElementById('ep1TitleInput');
    const ep1DescInput = document.getElementById('ep1DescInput');
    const serialCreateConfirmBtn = document.getElementById('serialCreateConfirmBtn');
    const serialCreateCancelBtn = document.getElementById('serialCreateCancelBtn');

    const addEpisodePopup = document.getElementById('addEpisodePopup');
    const addEpTitleInput = document.getElementById('addEpTitleInput');
    const addEpDescInput = document.getElementById('addEpDescInput');
    const addEpConfirmBtn = document.getElementById('addEpConfirmBtn');
    const addEpCancelBtn = document.getElementById('addEpCancelBtn');
    let addEpisodeSerialIndex = null; // which serial we're adding to

    
// ---- Cover Image Handling ----
const coverInput = document.getElementById('storyCoverInput');
const coverImg = document.getElementById('storyCoverImg');
if (coverInput) {
  coverInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        coverImg.src = ev.target.result;
        coverImg.style.display = 'block';
        window._currentStoryCover = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });
}

// ---- Serial cover handling ----
const serialCoverInput = document.getElementById('serialCoverInput');
const serialCoverImg = document.getElementById('serialCoverImg');
if (serialCoverInput) {
  serialCoverInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        if (serialCoverImg) {
          serialCoverImg.src = ev.target.result;
          serialCoverImg.style.display = 'block';
        }
        window._currentSerialCover = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });
} else {
  // create placeholders if elements aren't present yet
  window._serialCoverPending = true;
}

// Ensure current cover vars exist
window._currentStoryCover = window._currentStoryCover || '';
window._currentSerialCover = window._currentSerialCover || '';

// ---------- Profile ----------
    function loadProfile(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(raw){
          const profile = JSON.parse(raw);
          profileExists = true;
          updateProfileUI(profile);
        }
      }catch(e){console.warn(e)}
    }
    
    // show profile button only on home (welcomePage) — hide everywhere else
function updateHeaderVisibility() {
  const welcomePage = document.getElementById('welcomePage');
  const categoriesPage = document.getElementById('categoriesPage');
  const serialCategoriesPage = document.getElementById('serialCategoriesPage');
  const profileDropdown = document.getElementById('profileDropdown');
  const profileBtn = document.getElementById('profileBtn'); // your reference

  if (!welcomePage || !categoriesPage || !serialCategoriesPage || !profileBtn) return;

  const onHome = !welcomePage.classList.contains('hidden');
  const onBrowseStories = !categoriesPage.classList.contains('hidden');
  const onBrowseSerials = !serialCategoriesPage.classList.contains('hidden');

  if (onHome) {
    profileBtn.classList.remove('hidden');
    profileDropdown?.classList.remove('hidden');
  } else if (onBrowseStories || onBrowseSerials) {
    profileBtn.classList.add('hidden');
    profileDropdown?.classList.add('hidden');
  } else {
    profileBtn.classList.remove('hidden');
    profileDropdown?.classList.remove('hidden');
  }

  console.log('Header updated:', { onHome, onBrowseStories, onBrowseSerials });
}

function updateProfileUI(profile){
      const initials = (profile.name||'??').slice(0,2).toUpperCase();
      profileBtn.innerHTML = `<span class="profile-initials">${initials}</span>`;
    }
   profileBtn.addEventListener('click', () => {
  // prevent dropdown opening on browse pages
  const onBrowseStories = !document.getElementById('categoriesPage').classList.contains('hidden');
  const onBrowseSerials = !document.getElementById('serialCategoriesPage').classList.contains('hidden');
  if (onBrowseStories || onBrowseSerials) return;

  profileDropdown.style.display = (profileDropdown.style.display === 'flex' ? 'none' : 'flex');
  renderDropdown();
});

    function renderDropdown(){
      profileDropdown.innerHTML = '';
      if(!profileExists){
        const btn = document.createElement('button');
        btn.textContent = '✍️ Create Profile';
        btn.addEventListener('click', ()=>{ profileFormPage.classList.remove('hidden'); welcomePage.classList.add('hidden'); profileDropdown.style.display='none'; });
        profileDropdown.appendChild(btn);
      } else {
        const btn = document.createElement('button');
        btn.textContent = '🧭 Writer Dashboard';
        btn.addEventListener('click', ()=>{ showDashboard('stories'); });
        profileDropdown.appendChild(btn);
      }
    }
    saveProfileBtn.addEventListener('click', ()=>{
      const genres = Array.from(document.querySelectorAll('#genresContainer input:checked')).map(c=>c.value);
      const profile = {name:profileName.value,age:profileAge.value,country:profileCountry.value,genres};
      localStorage.setItem(STORAGE_KEY, JSON.stringify(profile));
      profileExists = true; updateProfileUI(profile);
      profileFormPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); updateHeaderVisibility();
    });
    document.querySelectorAll('.genre-option').forEach(opt=>{
      opt.addEventListener('click', ()=>{ const input=opt.querySelector('input'); input.checked=!input.checked; opt.classList.toggle('active', input.checked); });
    });

    // ---------- Browse ----------
document.getElementById('browseStoriesBtn').addEventListener('click', () => {
  openCategoriesPage();
  updateHeaderVisibility(); // ✅ update header after page change
});

document.getElementById('browseSerialsBtn').addEventListener('click', () => {
  openSerialCategoriesPage();
  updateHeaderVisibility(); // ✅ update header after page change
});

    
    
  // ---------- Categories Page ----------
document.addEventListener('DOMContentLoaded', function() {
  // Elements
  const _browseStoriesBtn = document.getElementById('browseStoriesBtn');
  const _browseSerialsBtn = document.getElementById('browseSerialsBtn');
  const _categoriesBackBtn = document.getElementById('categoriesBackBtn');
  const _serialCategoriesBackBtn = document.getElementById('serialCategoriesBackBtn');

  const _welcomePage = document.getElementById('welcomePage');
  const _categoriesPage = document.getElementById('categoriesPage');
  const _categoriesGrid = document.getElementById('categoriesGrid');
  const _serialCategoriesPage = document.getElementById('serialCategoriesPage');
  const _serialCategoriesGrid = document.getElementById('serialCategoriesGrid');

  // Safe header updater
  function safeUpdateHeader() {
    if (typeof updateHeaderVisibility === 'function') {
      updateHeaderVisibility();
    }
  }

  // Render categories
  function renderCategories(targetGrid){
    if(!targetGrid) return;
    targetGrid.innerHTML = '';
    CATEGORIES.forEach(cat=>{
      const card = document.createElement('div');
      card.className = 'cat-card';
      card.innerHTML = '<div class="cat-title">'+cat+'</div><div class="cat-sub">'+(cat==='All' ? 'All genres' : (cat + ' stories'))+'</div>';
      card.addEventListener('click', ()=>{
        targetGrid.querySelectorAll('.cat-card').forEach(c=>c.classList.remove('active'));
        card.classList.add('active');
      });
      targetGrid.appendChild(card);
    });
  }

  // Event listeners
  _browseStoriesBtn?.addEventListener('click', () => {
    _welcomePage?.classList.add('hidden');
    _categoriesPage?.classList.remove('hidden');
    if (_categoriesGrid) {
      renderCategories(_categoriesGrid);
      _categoriesGrid.scrollLeft = 0;
    }
   updateHeaderVisibility();
  });

  _browseSerialsBtn?.addEventListener('click', () => {
    _welcomePage?.classList.add('hidden');
    _serialCategoriesPage?.classList.remove('hidden');
    if (_serialCategoriesGrid) {
      renderCategories(_serialCategoriesGrid);
      _serialCategoriesGrid.scrollLeft = 0;
    }
   updateHeaderVisibility();
  });

  _categoriesBackBtn?.addEventListener('click', () => {
    _categoriesPage?.classList.add('hidden');
    _welcomePage?.classList.remove('hidden');
    updateHeaderVisibility();
  });

  _serialCategoriesBackBtn?.addEventListener('click', () => {
    _serialCategoriesPage?.classList.add('hidden');
    _welcomePage?.classList.remove('hidden');
    updateHeaderVisibility();
  });
});



    // ---------- End Categories Page ----------
    
    // ---------- Create ----------
    createContentBtn.addEventListener('click', ()=>{ if(!profileExists){ alert('Create a writer profile first!'); return; } chooseTypePopup.classList.remove('hidden'); });
    createStoryBtn.addEventListener('click', ()=>{ currentType='story'; chooseTypePopup.classList.add('hidden'); showSlotsPage(); });
    createSerialBtn.addEventListener('click', ()=>{ currentType='serial'; chooseTypePopup.classList.add('hidden'); showSlotsPage(); });

    // ---------- Slots Page ----------
    function showSlotsPage(){ welcomePage.classList.add('hidden'); slidesPage.classList.remove('hidden'); renderSlots(); updateHeaderVisibility(); }
    function renderSlots(){
      slotsContainer.innerHTML='';
      let slots = currentType==='story'? storySlots : serialSlots;
      if(slots.length===0) slots = [{id:0,unlocked:false,name:''}];
      slots.forEach((slot,index)=>{
        const div = document.createElement('div');
        div.className = 'slot-card ' + (slot.unlocked ? 'unlocked' : 'locked');
        const meta = slot.unlocked ? (`Episodes: ${ (slot.episodes || []).length }`) : 'Unlock to start';
        div.innerHTML = `<div class="slot-title">${slot.unlocked? (slot.name || ('Slot '+(slot.id+1))) : 'Locked Slot'}</div>
                         <div class="slot-meta">${meta}</div>`;
        
div.addEventListener('click', ()=> {
  selectedSlot = slot;
  if (!slot.unlocked) {
    // first click: ask to name & unlock (do not auto-open editor)
    slotNameInput.value = slot.name || '';
    slotNamePopup.dataset.slotIndex = index;
    // clear any temporary cover selection so new slots don't inherit previous cover
    window._currentStoryCover = '';
    window._currentSerialCover = '';
    if (document.getElementById('storyCoverImg')) { document.getElementById('storyCoverImg').style.display='none'; document.getElementById('storyCoverImg').src=''; }
    if (document.getElementById('serialCoverImg')) { document.getElementById('serialCoverImg').style.display='none'; document.getElementById('serialCoverImg').src=''; }
    slotNamePopup.dataset.slotIndex = index;
    slotNamePopup.classList.remove('hidden');
  } else {
    // already unlocked
    if (currentType === 'story') {
      // ----- NEW: If a story matching this slot name exists, open the editor in edit mode -----
      const existingStoryIndex = storiesData.findIndex(s => (s.title || '').trim() === (slot.name || '').trim());
      if (existingStoryIndex >= 0) {
        // open editor with isEdit=true so sheets/pages are loaded
        createEditorPage(storiesData[existingStoryIndex].title, storiesData[existingStoryIndex].genre || '', storiesData[existingStoryIndex].description || '', {
          isEdit: true,
          editType: 'story',
          index: existingStoryIndex
        });
      } else {
        // no saved story for this slot yet — open story creation form prefilled with slot name
        showStoryForm(slot.name || '');
      }
    } else {
  // SERIALS: If serial exists in this slot, open it directly in edit mode
  const existingIndex = serialsData.findIndex(s => (s.title || '').trim() === (slot.name || '').trim());
  if (existingIndex >= 0) {
    // open editor for first episode if it exists
    const ser = serialsData[existingIndex];
    const epIndex = ser.episodes && ser.episodes.length ? 0 : null;
    createEditorPage(
      epIndex != null ? ser.episodes[epIndex].title : ser.title,
      ser.genre,
      epIndex != null ? ser.episodes[epIndex].description : ser.description,
      { isEdit: true, editType: 'serial', index: existingIndex, episodeIndex: epIndex }
    );
  } else {
    // if no existing serial, show create form
    serialCreatePopup.dataset.slotIndex = index;
    seriesTitleInput.value = slot.name || '';
    seriesGenreInput.value = '';
    seriesDescInput.value = '';
    ep1TitleInput.value = '';
    ep1DescInput.value = '';
    window._currentSerialCover = '';
    if (document.getElementById('serialCoverImg')) {
      document.getElementById('serialCoverImg').style.display = 'none';
      document.getElementById('serialCoverImg').src = '';
    }
    serialCreatePopup.classList.remove('hidden');
  }
}
  }
});

        slotsContainer.appendChild(div);
      });
      if(currentType==='story') storySlots = slots; else serialSlots = slots;
    }
    slotsBackBtn.addEventListener('click', ()=>{ slidesPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); updateHeaderVisibility(); });

    // ---------- Slot Name Popup handlers ----------
    slotNameCancelBtn.addEventListener('click', ()=>{ slotNamePopup.classList.add('hidden'); });
    slotNameUnlockBtn.addEventListener('click', ()=>{
      const idx = parseInt(slotNamePopup.dataset.slotIndex || '0', 10);
      const name = slotNameInput.value.trim();
      let slotsArr = currentType==='story' ? storySlots : serialSlots;
      if(slotsArr.length === 0) slotsArr = [{id:0,unlocked:false,name:''}];
      if(!slotsArr[idx]){ slotsArr[idx] = { id: idx, unlocked: false, name: '' }; }
      // set name and unlock, but DO NOT open the create form immediately
      slotsArr[idx].name = name || ('Slot ' + (idx+1));
      slotsArr[idx].unlocked = true;
      // ensure there is always an empty locked slot at the end
      if(slotsArr[slotsArr.length-1] === slotsArr[idx]) slotsArr.push({id: slotsArr.length, unlocked: false, name: ''});
      if(currentType==='story') storySlots = slotsArr; else serialSlots = slotsArr;
      slotNamePopup.classList.add('hidden');
      renderSlots();
    });

    // ---------- Serial Create Popup handlers ----------
    serialCreateCancelBtn.addEventListener('click', ()=>{ serialCreatePopup.classList.add('hidden'); });
    serialCreateConfirmBtn.addEventListener('click', ()=>{
      const title = seriesTitleInput.value.trim();
      const genre = seriesGenreInput.value.trim();
      const sdesc = seriesDescInput.value.trim();
      const epTitle = ep1TitleInput.value.trim();
      const epDesc = ep1DescInput.value.trim();
      if(!title){ alert('Series title is required'); return; }

      // If a serial with same title exists, update it; otherwise create new
      let serIndex = serialsData.findIndex(s=> s.title === title);
      let ser;
      if(serIndex >= 0){
        ser = serialsData[serIndex];
        ser.genre = genre; ser.description = sdesc;
      } else {
        ser = { title, genre, description: sdesc, episodes: [], cover: (window._currentSerialCover || '') };
        serialsData.push(ser);
        serIndex = serialsData.indexOf(ser);
      }
      // always update cover from current selection
      ser.cover = window._currentSerialCover || '';


      // If episode1 fields were provided, create episode 1 and open editor for it
      if(epTitle){
        ser.episodes = ser.episodes || [];
        // Only add episode if none exist or the last episode title differs
        const lastEp = ser.episodes[ser.episodes.length - 1];
        if(!lastEp || lastEp.title !== epTitle){
          ser.episodes.push({ title: epTitle, description: epDesc || '', sheets: [], status: 'Draft' });
        }
      }

      // update slot that matches this title (or slot index passed)
      const idx = parseInt(serialCreatePopup.dataset.slotIndex || '-1', 10);
      let slotsArr = serialSlots.length? serialSlots : [{id:0,unlocked:false,name:''}];
      // find slot with same name, else use idx
      let slotToUpdate = slotsArr.find(s=> s.name === title) || (slotsArr[idx] || slotsArr[0]);
      slotToUpdate.unlocked = true; slotToUpdate.name = title; slotToUpdate.episodes = ser.episodes.slice(); slotToUpdate.cover = ser.cover || '';
      if(slotsArr[slotsArr.length-1] === slotToUpdate) slotsArr.push({id: slotsArr.length, unlocked: false, name: ''});
      serialSlots = slotsArr;

      serialCreatePopup.classList.add('hidden');
      renderSlots();

      // open editor for the newly created episode if we added one (choose last created episode index)
      if(epTitle){
        const epIndex = ser.episodes.length - 1;
        createEditorPage(ser.episodes[epIndex].title, ser.genre, ser.episodes[epIndex].description, { isEdit:true, editType:'serial', index: serIndex, episodeIndex: epIndex });
      }
    });

    // ---------- Add Episode Popup handlers ----------
    addEpCancelBtn.addEventListener('click', ()=>{ addEpisodePopup.classList.add('hidden'); addEpisodeSerialIndex = null; });
    addEpConfirmBtn.addEventListener('click', ()=>{
      const title = addEpTitleInput.value.trim(); const desc = addEpDescInput.value.trim();
      if(!title){ alert('Episode title is required'); return; }
      if(addEpisodeSerialIndex == null){ alert('Serial not selected'); addEpisodePopup.classList.add('hidden'); return; }
      const ser = serialsData[addEpisodeSerialIndex]; if(!ser){ alert('Serial not found'); addEpisodePopup.classList.add('hidden'); return; }
      addEpisodePopup.classList.add('hidden');
      createEditorPage(title, ser.genre, desc, { isEdit:false, editType:'serial', index: addEpisodeSerialIndex, isNewEpisode:true });
      addEpisodeSerialIndex = null;
    });

    // ---------- Story Form & Editor ----------
    function showStoryForm(title=''){ slidesPage.classList.add('hidden'); storyFormPage.classList.remove('hidden'); storyTitleInput.value = title; storyGenreSelect.value=''; storyDescInput.value=''; updateHeaderVisibility(); }
    cancelCreateBtn.addEventListener('click', ()=>{ storyFormPage.classList.add('hidden'); slidesPage.classList.remove('hidden'); updateHeaderVisibility(); });

    startCreatingBtn.addEventListener('click', ()=>{
      // carry-over any tags entered in the story form into pending tags map
      try{
        const t = (document.getElementById('storyTitle') && document.getElementById('storyTitle').value && document.getElementById('storyTitle').value.trim()) ? document.getElementById('storyTitle').value.trim() : 'temp_story';
        const tagsFromForm = getTagsFromContainer(document.getElementById('storyTagsContainer')) || [];
        window._pendingTags = window._pendingTags || {};
        if (tagsFromForm.length) window._pendingTags[t] = Array.from(new Set([...(window._pendingTags[t]||[]), ...tagsFromForm]));
      }catch(e){ console.warn('carry tags into pending failed', e); }

      if(!storyTitleInput.value || !storyGenreSelect.value){ alert('Fill Title & Genre'); return; }
      storyFormPage.classList.add('hidden'); createEditorPage(storyTitleInput.value, storyGenreSelect.value, storyDescInput.value, {isEdit:false, editType:'story'});
    });

    function createEditorPage(title, genre, desc, opts={}){
      // opts: {isEdit, editType:'story'|'serial', index, episodeIndex, isNewEpisode}
      const editType = opts.editType || 'story';
      const isEdit = !!opts.isEdit;
      const isNewEpisode = !!opts.isNewEpisode;

      const editorDiv = document.createElement('div'); editorDiv.id='editorPage';
      editorDiv.innerHTML = `
  ${(editType==='serial' && opts.isEdit && opts.episodeIndex===0) ? `
    <div style="background:#fff8e1;border:1px solid #facc15; border-radius:10px;padding:10px;margin-bottom:8px; text-align:center;font-weight:600;color:#92400e;"> ⚠️ Please create a new sheet before writing your Episode 1 by clicking the + button. </div>` : ''}

        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
          <div>
            <h2 style="margin:0">${editType==='serial' ? (isEdit && opts.episodeIndex!=null ? 'Edit Episode' : (isNewEpisode ? 'New Episode' : 'Edit Serial')) : (isEdit? 'Edit Story' : 'New Story')}</h2>
            <div class="muted">${genre || ''} ${desc? (' • '+desc) : ''}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="btn btn-secondary" id="closeEditorBtn">Close</button>
          </div>
        </div>
        <div class="sheets-bar" id="sheetsBar"><div class="add-sheet-btn" id="addSheetBtn">+</div></div>
        <textarea id="sheetTextarea" class="sheet-textarea" placeholder="Type your story..."></textarea>
        <div style="display:flex;justify-content:flex-start;gap:8px;margin-top:6px"><button id="deleteSheetBtn" class="btn btn-secondary">Delete Active Sheet</button></div>
        <div class="editor-actions">
          <button class="btn btn-secondary" id="saveDraftBtn">Save Draft</button>
          <button class="btn btn-primary" id="publishStoryBtn">${isEdit && editType==='story' ? 'Update' : (isEdit && editType==='serial' && opts.episodeIndex!=null ? 'Update' : (editType==='story' ? 'Publish' : 'Publish Episode'))}</button>
        </div>
      `;
      document.body.appendChild(editorDiv); updateHeaderVisibility();

      const sheetsBar = editorDiv.querySelector('#sheetsBar');
      const addSheetBtn = editorDiv.querySelector('#addSheetBtn');
      const sheetTextarea = editorDiv.querySelector('#sheetTextarea');
      const publishStoryBtn = editorDiv.querySelector('#publishStoryBtn');
      const saveDraftBtnLocal = editorDiv.querySelector('#saveDraftBtn');
      const closeEditorBtn = editorDiv.querySelector('#closeEditorBtn');
      const deleteSheetBtn = editorDiv.querySelector('#deleteSheetBtn');

      let sheets = [], activeSheetId = 0;
      function addNewSheet(content=''){ saveActiveSheet(); const id = sheets.length; sheets.push({id,content}); activeSheetId=id; renderSheetsBar(); sheetTextarea.value = content; sheetTextarea.focus(); }
      function renderSheetsBar(){
        sheetsBar.querySelectorAll('.sheet-thumb').forEach(e=>e.remove());
        sheets.forEach(sheet=>{
          const thumb = document.createElement('div'); thumb.className = 'sheet-thumb' + (sheet.id===activeSheetId ? ' active' : '');
          thumb.innerHTML = `<div class="thumb-text">${(sheet.content||'').slice(0,60) || 'Empty'}</div>`;
          // delete button on the thumb
          const del = document.createElement('button'); del.className = 'del'; del.innerHTML = '✖';
          del.title = 'Delete this sheet';
          del.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(!confirm('Delete this sheet? This cannot be undone.')) return; deleteSheetById(sheet.id); });
          thumb.appendChild(del);
          thumb.addEventListener('click', ()=>{ saveActiveSheet(); activeSheetId = sheet.id; sheetTextarea.value = sheet.content || ''; renderSheetsBar(); });
          sheetsBar.insertBefore(thumb, addSheetBtn);
        });
      }
      function saveActiveSheet(){ const s = sheets.find(s=>s.id===activeSheetId); if(s) s.content = sheetTextarea.value; }
      function deleteSheetById(id){ const idx = sheets.findIndex(s=> s.id === id); if(idx === -1) return; sheets.splice(idx,1); // reassign ids
        sheets = sheets.map((s,i)=> ({id:i, content: s.content}));
        // adjust activeSheetId
        if(sheets.length===0){ addNewSheet(''); return; }
        activeSheetId = Math.min(activeSheetId, sheets.length-1);
        sheetTextarea.value = sheets[activeSheetId].content || '';
        renderSheetsBar();
      }

      addSheetBtn.addEventListener('click', ()=> addNewSheet(''));

      // Delete active sheet button
      deleteSheetBtn.addEventListener('click', ()=>{
        if(!confirm('Delete the active sheet? This cannot be undone.')) return;
        deleteSheetById(activeSheetId);
      });

      // initialize: load existing when editing
      if(isEdit){
        if(editType==='story'){
          const obj = storiesData[opts.index] || {sheets:[]};
          sheets = (obj.sheets||[]).map((s,i)=>({id:i,content:s.content||s})); activeSheetId=0; renderSheetsBar(); sheetTextarea.value = sheets[0] ? sheets[0].content : '';
        } else if(editType==='serial'){
          const ser = serialsData[opts.index] || {episodes:[]};
          if(opts.episodeIndex!=null){
            const ep = (ser.episodes||[])[opts.episodeIndex] || {sheets:[]};
            sheets = (ep.sheets||[]).map((s,i)=>({id:i,content:s.content||s})); activeSheetId=0; renderSheetsBar(); sheetTextarea.value = sheets[0] ? sheets[0].content : '';
          } else {
            sheets = []; addNewSheet('');
          }
        }
      } else {
        // new story or new episode
        addNewSheet('');
      }

      publishStoryBtn.addEventListener('click', async ()=>{
        saveActiveSheet(); const payloadSheets = sheets.map(s=>({content: s.content || ''}));
        if(editType === 'story'){
          const payload = { title: title, genre: genre, description: desc, sheets: payloadSheets, status: 'Public', cover: window._currentStoryCover || '' };
          // Save locally first
          if(isEdit){ storiesData[opts.index] = Object.assign({}, storiesData[opts.index], payload); }
          else { storiesData.push(payload); }
          // Attempt to save to Firebase (overwrite same title key)
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `stories/${encodeURIComponent(title)}`), payload);
              console.log('Saved story to Firebase:', title);
            }
          }catch(err){ console.warn('Firebase save failed for story', err); }
          editorDiv.remove(); showDashboard('stories');
          return;
        }
        // serial path
        if(editType === 'serial'){
          const ser = serialsData[opts.index]; if(!ser){ alert('Serial not found'); return; }
          if(isEdit && opts.episodeIndex!=null){
            ser.episodes[opts.episodeIndex] = Object.assign({}, ser.episodes[opts.episodeIndex], { title: title, description: desc, sheets: payloadSheets, status: 'Public' });
            serialsData[opts.index] = ser;
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title)}`), ser);
              console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else if(isNewEpisode){
            ser.episodes = ser.episodes || [];
            ser.episodes.push({ title: title || 'Episode', description: desc || '', sheets: payloadSheets, status: 'Public' });
            serialsData[opts.index] = ser;
            try{
              if(window._firebase && window._firebase.set){
                const { db, ref, set } = window._firebase;
                await set(ref(db, `serials/${encodeURIComponent(ser.title)}`), ser);
                console.log('Saved new episode (serial) to Firebase:', ser.title);
              }
            }catch(err){ console.warn('Firebase save failed for new episode', err); }

          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title)}`), ser);
              console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else {
            serialsData[opts.index] = Object.assign({}, ser, { title: title, genre: genre, description: desc });
          }
          const slot = serialSlots.find(s=> s.name === ser.title);
          if(slot) slot.episodes = ser.episodes.slice();
          editorDiv.remove(); showDashboard('serials');
          return;
        }
      });

      saveDraftBtnLocal.addEventListener('click', async ()=>{
        saveActiveSheet(); const payloadSheets = sheets.map(s=>({content: s.content || ''}));
        if(editType === 'story'){
          const payload = { title: title, genre: genre, description: desc, sheets: payloadSheets, status: 'Draft', cover: window._currentStoryCover || '' };
          if(isEdit){ storiesData[opts.index] = Object.assign({}, storiesData[opts.index], payload); }
          else { storiesData.push(payload); }
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `stories/${encodeURIComponent(title)}`), payload);
              console.log('Saved story draft to Firebase:', title);
            }
          }catch(err){ console.warn('Firebase draft save failed', err); }
          editorDiv.remove(); showDashboard('stories');
          return;
        }
        if(editType === 'serial'){
          const ser = serialsData[opts.index]; if(!ser){ alert('Serial not found'); return; }
          if(isEdit && opts.episodeIndex!=null){
            ser.episodes[opts.episodeIndex] = Object.assign({}, ser.episodes[opts.episodeIndex], { title: title, description: desc, sheets: payloadSheets, status: 'Draft' });
            serialsData[opts.index] = ser;
          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title)}`), ser);
              console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else if(isNewEpisode){
            ser.episodes = ser.episodes || [];
            ser.episodes.push({ title: title || 'Episode', description: desc || '', sheets: payloadSheets, status: 'Draft' });
            serialsData[opts.index] = ser;
            try{
              if(window._firebase && window._firebase.set){
                const { db, ref, set } = window._firebase;
                await set(ref(db, `serials/${encodeURIComponent(ser.title)}`), ser);
                console.log('Saved serial draft to Firebase:', ser.title);
              }
            }catch(err){ console.warn('Firebase draft save failed for serial', err); }

          try{
            if(window._firebase && window._firebase.set){
              const { db, ref, set } = window._firebase;
              await set(ref(db, `serials/${encodeURIComponent(ser.title)}`), ser);
              console.log('Saved serial to Firebase:', ser.title);
            }
          }catch(err){ console.warn('Firebase save failed for serial', err); }

          } else {
            serialsData[opts.index] = Object.assign({}, ser, { title: title, genre: genre, description: desc });
          }
          const slot = serialSlots.find(s=> s.name === ser.title);
          if(slot) slot.episodes = ser.episodes.slice();
          editorDiv.remove(); showDashboard('serials');
          return;
        }
      });

      closeEditorBtn.addEventListener('click', ()=>{ if(confirm('Close editor? Unsaved changes will be lost.')) editorDiv.remove(); });
    }

    // ---------- Dashboard ----------
      function showDashboard(type='stories', genreFilter='All'){
      welcomePage.classList.add('hidden'); profileFormPage.classList.add('hidden'); storyFormPage.classList.add('hidden'); slidesPage.classList.add('hidden'); dashboardPage.classList.remove('hidden'); dashboardBackBtn.classList.remove('hidden');
      dashboardList.innerHTML='';
      updateHeaderVisibility();
      if(type==='stories'){
        const published = storiesData.filter(s=>s.status==='Public');
        const drafts = storiesData.filter(s=>s.status!=='Public');
        const ordered = [...published, ...drafts];
        // apply genre filter if requested
        const filtered = (genreFilter && genreFilter !== 'All') ? ordered.filter(s=> (s.genre||'').toLowerCase() === genreFilter.toLowerCase()) : ordered;
        const finalList = filtered;
        finalList.forEach((s, idx)=>{
          const card = document.createElement('div'); card.className='dashboard-card';
          const left = document.createElement('div'); left.className='left';
          left.innerHTML = `<div style="max-width:65%"><h3>${s.title}</h3>
                            <div class="meta">Genre: ${s.genre || '—'}</div>
                            <p class="desc">${s.description || ''}</p>
                            <p>Status: <span class="${s.status==='Public'?'status-public':'status-draft'}">${s.status}</span></p></div>`;
          const actions = document.createElement('div'); actions.className='card-actions';
          const editBtn = document.createElement('button');
editBtn.className = 'small-btn btn btn-secondary';
editBtn.textContent = s.status === 'Public' ? 'Update' : 'Edit';
editBtn.addEventListener('click', () => {
  createEditorPage(s.title, s.genre, s.description, {
    isEdit: true,
    editType: 'story',
    index: storiesData.indexOf(s)
  });
});
actions.appendChild(editBtn);

// Add Analytics button only for published stories
if (s.status === 'Public') {
  const analyticsBtn = document.createElement('button');
  analyticsBtn.className = 'small-btn btn btn-primary';
  analyticsBtn.textContent = 'Analytics';
  analyticsBtn.addEventListener('click', () => {
    showStoryAnalytics(s);
  });
  actions.appendChild(analyticsBtn);
}


          card.appendChild(left); card.appendChild(actions); dashboardList.appendChild(card);
        });
      } else {
        const ordered = [...serialsData];
        ordered.forEach((s, idx)=>{
          const card = document.createElement('div'); card.className='dashboard-card';
          const left = document.createElement('div'); left.className='left';
          left.innerHTML = `<div style="max-width:65%"><h3>${s.title}</h3>
                            <div class="meta">${s.genre || '—'} ${s.description? ('• ' + s.description) : ''}</div>
                            <p class="desc">Episodes: ${(s.episodes||[]).length}</p></div>`;
const actions = document.createElement('div');
actions.className = 'card-actions';

// --- Edit Episodes button ---
const editEpisodesBtn = document.createElement('button');
editEpisodesBtn.className = 'small-btn btn btn-secondary';
editEpisodesBtn.textContent = 'Edit Episodes';
editEpisodesBtn.addEventListener('click', () => {
  showSerialEpisodesEditor(serialsData.indexOf(s));
});

const addEpisodeBtn = document.createElement('button');
addEpisodeBtn.className = 'small-btn btn btn-primary';
addEpisodeBtn.textContent = 'Add Episode';

addEpisodeBtn.addEventListener('click', () => {
  addEpisodeSerialIndex = serialsData.indexOf(s);
  addEpTitleInput.value = '';
  addEpDescInput.value = '';
  addEpisodePopup.classList.remove('hidden');
});
const AnalyticBtn = document.createElement('button');
AnalyticBtn.className = 'small-btn btn btn-primary';
AnalyticBtn.textContent = 'Analytics';

AnalyticBtn.addEventListener('click', () => {
    // Get index of the current serial
    const serialIndex = serialsData.indexOf(s);

    // Call a function to show Serial Analytics
    showSerialAnalytics(s, serialIndex);
});



actions.appendChild(editEpisodesBtn);
actions.appendChild(addEpisodeBtn);
actions.appendChild(AnalyticBtn);
card.appendChild(left);
card.appendChild(actions);

dashboardList.appendChild(card);
});
}
}






// ---------- Reader Like/Dislike handlers (persisted in localStorage) ----------
function initReaderLikeButtons(){
  const likeBtn = document.getElementById('readerLikeBtn');
  const dislikeBtn = document.getElementById('readerDislikeBtn');
  const likeCountEl = document.getElementById('readerLikeCount');
  const dislikeCountEl = document.getElementById('readerDislikeCount');
  if(!likeBtn || !dislikeBtn) return;

  // keying based on readerTitle and (if present) episode marker in readerMeta.
  function getKey(){
    const title = (document.getElementById('readerTitle') && document.getElementById('readerTitle').textContent) || 'untitled';
    const meta = (document.getElementById('readerMeta') && document.getElementById('readerMeta').textContent) || '';
    // Try to detect "Episode X" in meta; if present, include it in key
    const epMatch = meta.match(/Episode\s*(\d+)/i);
    const key = epMatch ? `${title}::episode${epMatch[1]}` : title;
    return key;
  }

  function loadCounts(){
    const store = JSON.parse(localStorage.getItem('global_votes_v1') || '{}');
    const key = getKey();
    const data = store[key] || {likes:0, dislikes:0};
    likeCountEl.textContent = data.likes || 0;
    dislikeCountEl.textContent = data.dislikes || 0;
  }

  function saveVote(deltaLike, deltaDislike){
    const store = JSON.parse(localStorage.getItem('global_votes_v1') || '{}');
    const key = getKey();
    store[key] = store[key] || {likes:0, dislikes:0};
    store[key].likes = (store[key].likes || 0) + (deltaLike||0);
    store[key].dislikes = (store[key].dislikes || 0) + (deltaDislike||0);
    localStorage.setItem('global_votes_v1', JSON.stringify(store));
    loadCounts();
  }

  likeBtn.addEventListener('click', ()=> saveVote(1,0));
  dislikeBtn.addEventListener('click', ()=> saveVote(0,1));

  // observe title/meta changes to update counts when reader opens different items
  const titleNode = document.getElementById('readerTitle');
  const metaNode = document.getElementById('readerMeta');
  const obs = new MutationObserver(()=> loadCounts());
  if(titleNode) obs.observe(titleNode, {childList:true, characterData:true, subtree:true});
  if(metaNode) obs.observe(metaNode, {childList:true, characterData:true, subtree:true});

  // initial load
  setTimeout(loadCounts, 120);
}
document.addEventListener('DOMContentLoaded', initReaderLikeButtons);
function showStoryAnalytics(s) {
  // Remove existing analytics page
  const existing = document.getElementById("analyticsPage");
  if (existing) existing.remove();

  // Main container
  const page = document.createElement("div");
  page.id = "analyticsPage";
  Object.assign(page.style, {
    position: "fixed",
    inset: "0",
    background: "#f9fafb",
    color: "#111",
    zIndex: 9999,
    overflowY: "auto",
    padding: "40px 20px",
    fontFamily: "Poppins, system-ui, sans-serif",
  });

  // Back button
  const backBtn = document.createElement("button");
  backBtn.textContent = "← Back";
  Object.assign(backBtn.style, {
    position: "fixed",
    top: "20px",
    left: "20px",
    padding: "10px 18px",
    background: "#fff",
    border: "1px solid #ddd",
    borderRadius: "12px",
    fontWeight: "600",
    cursor: "pointer",
    boxShadow: "0 4px 14px rgba(0,0,0,0.08)",
  });
  backBtn.addEventListener("click", () => page.remove());
  page.appendChild(backBtn);

  // Title
  const title = document.createElement("h2");
  title.textContent = `${s.title || "Story"} Analytics`;
  Object.assign(title.style, { textAlign: "center", fontSize: "30px", marginBottom: "18px", fontWeight: "800" });
  page.appendChild(title);

  // Top stats cards
  const globalVotes = JSON.parse(localStorage.getItem("global_votes_v1") || "{}");
  const votes = globalVotes[s.title] || { likes: 0, dislikes: 0 };
  const reads = Number(s.reads || 0);

  let statusText = "ON GOING", statusColor = "#3b82f6";
  if (reads <= 10) { statusText = "ON GOING"; statusColor = "#3b82f6"; }
  else if (reads <= 40) { statusText = "REACHING WELL"; statusColor = "#10b981"; }
  else if (reads <= 75) { statusText = "TRENDING"; statusColor = "#f59e0b"; }
  else { statusText = "POPULAR"; statusColor = "#ef4444"; }

  const statsWrap = document.createElement("div");
  Object.assign(statsWrap.style, {
    display: "flex",
    justifyContent: "space-between",
    gap: "20px",
    marginBottom: "22px",
    maxWidth: "1000px",
    marginLeft: "auto",
    marginRight: "auto",
  });

  const makeBox = (label, value, color) => {
    const box = document.createElement("div");
    Object.assign(box.style, {
      flex: "1",
      background: "#fff",
      borderRadius: "16px",
      padding: "18px",
      boxShadow: "0 6px 20px rgba(0,0,0,0.06)",
      fontWeight: "700",
      textAlign: "center",
      transition: "transform 0.15s",
    });
    box.addEventListener("mouseover", ()=> box.style.transform="translateY(-2px)");
    box.addEventListener("mouseout", ()=> box.style.transform="translateY(0)");
    box.innerHTML = `<div style="font-size:13px;color:#6b7280">${label}</div>
                     <div style="font-size:24px;color:${color || "#111"}">${value}</div>`;
    return box;
  };

  statsWrap.appendChild(makeBox("👁️ Reads", reads, "#3b82f6"));
  statsWrap.appendChild(makeBox("👍 Likes", votes.likes || 0, "#10b981"));
  statsWrap.appendChild(makeBox("📊 Status", statusText, statusColor));
  page.appendChild(statsWrap);

  // --- Chart area (replaces history) ---

  // Helpers
  const getDateKey = (d) => {
    const dt = new Date(d);
    const y = dt.getFullYear();
    const m = String(dt.getMonth() + 1).padStart(2, "0");
    const day = String(dt.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  };

  // Try to build timeseries from several sources:
  // 1) If story has a history array like [{date:'2025-10-16', reads:10, likes:2}, ...] use that
  // 2) Otherwise, use snapshot store in localStorage ('story_daily_snapshots_v1') keyed by story title
  // 3) Always add current snapshot (today) with current reads/likes so chart is up-to-date.

  const snapshotStoreKey = "story_daily_snapshots_v1";
  const store = JSON.parse(localStorage.getItem(snapshotStoreKey) || "{}");

  // If s.history exists and looks usable, normalize it
  let series = {};
  if (Array.isArray(s.history) && s.history.length > 0) {
    s.history.forEach(h => {
      // Expect h to have date (or publishedAt) and reads/likes
      const dateKey = getDateKey(h.date || h.publishedAt || h.day || new Date());
      series[dateKey] = series[dateKey] || { reads: 0, likes: 0 };
      series[dateKey].reads = Math.max(series[dateKey].reads, Number(h.reads || h.r || 0));
      series[dateKey].likes = Math.max(series[dateKey].likes, Number(h.likes || h.l || 0));
    });
  }

  // Merge snapshots from store (for this story)
  const storyKey = s.title || (s.id ? `id_${s.id}` : "untitled");
  const storedForStory = store[storyKey] || {};
  Object.keys(storedForStory).forEach(dateKey => {
    series[dateKey] = series[dateKey] || { reads: 0, likes: 0 };
    // stored snapshot expected shape: { reads: N, likes: M }
    series[dateKey].reads = Math.max(series[dateKey].reads, Number(storedForStory[dateKey].reads || 0));
    series[dateKey].likes = Math.max(series[dateKey].likes, Number(storedForStory[dateKey].likes || 0));
  });

  // Add today's snapshot (so chart shows current)
  const todayKey = getDateKey(new Date());
  series[todayKey] = series[todayKey] || { reads: 0, likes: 0 };
  series[todayKey].reads = Math.max(series[todayKey].reads, reads);
  series[todayKey].likes = Math.max(series[todayKey].likes, votes.likes || 0);

  // Persist today's snapshot into localStorage for future charts
  store[storyKey] = store[storyKey] || {};
  store[storyKey][todayKey] = {
    reads: series[todayKey].reads,
    likes: series[todayKey].likes,
    ts: Date.now()
  };
  localStorage.setItem(snapshotStoreKey, JSON.stringify(store));

  // Build sorted dataPoints
  const dateKeys = Object.keys(series).sort((a,b) => new Date(a) - new Date(b));
  // If nothing meaningful, show a friendly message
  if (dateKeys.length === 0) {
    const noData = document.createElement("div");
    noData.textContent = "No analytics data yet — publish and come back after some reads.";
    Object.assign(noData.style, { textAlign: "center", marginTop: "40px", color: "#6b7280" });
    page.appendChild(noData);
    document.body.appendChild(page);
    return;
  }

  const dataPoints = dateKeys.map(dk => ({ date: dk, reads: Number(series[dk].reads || 0), likes: Number(series[dk].likes || 0) }));

  // Chart container
  const chartWrap = document.createElement("div");
  Object.assign(chartWrap.style, {
    maxWidth: "1000px",
    margin: "0 auto 60px",
    background: "#fff",
    padding: "20px",
    borderRadius: "14px",
    boxShadow: "0 6px 20px rgba(0,0,0,0.04)"
  });

  // Legend and controls
  const legend = document.createElement("div");
  legend.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px;">
      <div style="display:flex;gap:12px;align-items:center;">
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:12px;height:12px;border-radius:2px;background:#3b82f6"></div><div style="font-size:13px;color:#374151">Reads</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:12px;height:12px;border-radius:2px;background:#10b981"></div><div style="font-size:13px;color:#374151">Likes</div>
        </div>
      </div>
      <div style="font-size:13px;color:#6b7280">Grouped by date</div>
    </div>
  `;
  chartWrap.appendChild(legend);

  // Build SVG chart
  const svgWidth = Math.min(960, Math.max(600, dataPoints.length * 70));
  const svgHeight = 300;
  const padding = { top: 20, right: 20, bottom: 60, left: 48 };
  const innerW = svgWidth - padding.left - padding.right;
  const innerH = svgHeight - padding.top - padding.bottom;

  // Compute max value to scale bars
  const maxVal = Math.max(...dataPoints.flatMap(d => [d.reads, d.likes]), 1);
  // nice round max
  const niceMax = (() => {
    const exp = Math.floor(Math.log10(maxVal));
    const base = Math.pow(10, exp);
    return Math.ceil(maxVal / base) * base;
  })();

  // Create SVG element
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.style.display = "block";
  svg.style.margin = "0 auto";

  // Axes group
  const g = document.createElementNS(svgNS, "g");
  g.setAttribute("transform", `translate(${padding.left},${padding.top})`);
  svg.appendChild(g);

  // Y grid lines and labels
  const ticks = 4;
  for (let i = 0; i <= ticks; i++) {
    const y = innerH - (i / ticks) * innerH;
    const val = Math.round((i / ticks) * niceMax);
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", 0);
    line.setAttribute("y1", y);
    line.setAttribute("x2", innerW);
    line.setAttribute("y2", y);
    line.setAttribute("stroke", "#e6e9ee");
    line.setAttribute("stroke-width", "1");
    g.appendChild(line);

    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", -10);
    label.setAttribute("y", y + 4);
    label.setAttribute("text-anchor", "end");
    label.setAttribute("font-size", "11");
    label.setAttribute("fill", "#6b7280");
    label.textContent = val;
    g.appendChild(label);
  }

  // Bars: grouped per date (reads + likes)
  const groupGap = 14;
  const groupWidth = innerW / dataPoints.length;
  const barWidth = Math.min(24, (groupWidth - groupGap) / 2);

  // Tooltip element (HTML overlay)
  const tooltip = document.createElement("div");
  Object.assign(tooltip.style, {
    position: "fixed",
    padding: "8px 10px",
    background: "#111",
    color: "#fff",
    fontSize: "12px",
    borderRadius: "6px",
    pointerEvents: "none",
    opacity: 0,
    transition: "opacity 0.12s",
    zIndex: 10000
  });
  document.body.appendChild(tooltip);

  dataPoints.forEach((d, i) => {
    const groupX = i * groupWidth + groupWidth / 2 - (barWidth + 6) / 2 - 6; // center groups

    // Reads bar (left)
    const readsH = (d.reads / niceMax) * innerH;
    const readsRect = document.createElementNS(svgNS, "rect");
    readsRect.setAttribute("x", groupX);
    readsRect.setAttribute("y", innerH - readsH);
    readsRect.setAttribute("width", barWidth);
    readsRect.setAttribute("height", Math.max(1, readsH));
    readsRect.setAttribute("fill", "#3b82f6");
    readsRect.style.cursor = "pointer";
    g.appendChild(readsRect);

    // Likes bar (right)
    const likesH = (d.likes / niceMax) * innerH;
    const likesRect = document.createElementNS(svgNS, "rect");
    likesRect.setAttribute("x", groupX + barWidth + 6);
    likesRect.setAttribute("y", innerH - likesH);
    likesRect.setAttribute("width", barWidth);
    likesRect.setAttribute("height", Math.max(1, likesH));
    likesRect.setAttribute("fill", "#10b981");
    likesRect.style.cursor = "pointer";
    g.appendChild(likesRect);

    // X label (date)
    const lbl = document.createElementNS(svgNS, "text");
    lbl.setAttribute("x", i * groupWidth + groupWidth / 2);
    lbl.setAttribute("y", innerH + 18);
    lbl.setAttribute("text-anchor", "middle");
    lbl.setAttribute("font-size", "11");
    lbl.setAttribute("fill", "#374151");
    lbl.textContent = d.date.slice(5); // show MM-DD for compactness
    g.appendChild(lbl);

    // Hover events for reads
    const attachHover = (elem, type) => {
      elem.addEventListener("mousemove", (ev) => {
        tooltip.style.left = (ev.pageX + 12) + "px";
        tooltip.style.top = (ev.pageY + 12) + "px";
        tooltip.innerHTML = `<strong style="display:block">${type}</strong><div style="font-size:13px">${d[type.toLowerCase()]}</div><div style="font-size:11px;color:#cbd5e1">${d.date}</div>`;
        tooltip.style.opacity = "1";
      });
      elem.addEventListener("mouseleave", () => tooltip.style.opacity = "0");
    };
    attachHover(readsRect, "Reads");
    attachHover(likesRect, "Likes");
  });

  // Y-axis label
  const yAxisLabel = document.createElementNS(svgNS, "text");
  yAxisLabel.setAttribute("x", -padding.left + 6);
  yAxisLabel.setAttribute("y", -6);
  yAxisLabel.setAttribute("font-size", "12");
  yAxisLabel.setAttribute("fill", "#6b7280");
  yAxisLabel.textContent = "Count";
  g.appendChild(yAxisLabel);

  chartWrap.appendChild(svg);

  // Small footnote and export CSV
  const footer = document.createElement("div");
  footer.style.display = "flex";
  footer.style.justifyContent = "space-between";
  footer.style.alignItems = "center";
  footer.style.marginTop = "12px";

  const note = document.createElement("div");
note.style.color = "#6b7280";
note.style.fontSize = "13px";
note.textContent = "Data shown per date (reads vs likes).";

const exportBtn = document.createElement("button");
exportBtn.textContent = "";
Object.assign(exportBtn.style, {
  display: "none", // ✅ this hides the button completely
  fontSize: "13px"
});

footer.appendChild(note);
// exportBtn is hidden but harmless
footer.appendChild(exportBtn);

  exportBtn.addEventListener("click", () => {
    // Build CSV
    const rows = [["date","reads","likes"], ...dataPoints.map(d => [d.date, d.reads, d.likes])];
    const csv = rows.map(r => r.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${(s.title || "story").replace(/\s+/g,'_')}_analytics.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  footer.appendChild(note);
  footer.appendChild(exportBtn);
  chartWrap.appendChild(footer);

  page.appendChild(chartWrap);

  // Basic story meta card
  const storyCard = document.createElement("div");
  Object.assign(storyCard.style, {
    background: "#fff",
    padding: "14px",
    borderRadius: "12px",
    boxShadow: "0 6px 20px rgba(0,0,0,0.04)",
    maxWidth: "1000px",
    margin: "0 auto 40px",
  });

  const createdAt = new Date(s.publishedAt || s.published || s.publishDate || Date.now());
  const getCharCount = (story) => {
    if (story.content) return story.content.length;
    if (story.body) return story.body.length;
    if (story.text) return story.text.length;
    if (story.serial && Array.isArray(story.serial)) {
      return story.serial.reduce((sum, part) => sum + (part.text?.length || 0), 0);
    }
    return 0;
  };
  const charCount = getCharCount(s);

  storyCard.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
    <div>
      <div style="font-size:16px;font-weight:600;color:#111">${s.title || "Untitled Story"}</div>
      <div style="font-size:13px;color:#6b7280;margin-top:4px">Created: ${createdAt.toLocaleString()}</div>
    <div style="text-align:right">
      <div style="font-size:13px;color:#6b7280">Total reads</div>
      <div style="font-size:20px;font-weight:700;color:#3b82f6">${reads}</div>
    </div>
  </div>`;

  page.appendChild(storyCard);

  document.body.appendChild(page);
}


function showSerialAnalytics(serialOrTitle) {
  const VOTES_STORE_KEY = 'global_votes_v1';
  const SNAPSHOT_KEY = 'story_daily_snapshots_v1';
  const READS_KEY = 'serial_reads_v1'; // 🆕 added

  // Safe loader
  function loadSaved() {
    try {
      return typeof loadSavedSerials === 'function'
        ? loadSavedSerials()
        : JSON.parse(localStorage.getItem('saved_serials_v1') || '[]');
    } catch (e) {
      return (serialsData || []).slice();
    }
  }

  const serial =
    typeof serialOrTitle === 'string'
      ? (loadSaved().find(s => s.title === serialOrTitle) ||
         (serialsData || []).find(s => s.title === serialOrTitle))
      : serialOrTitle;

  if (!serial) {
    alert('Serial not found');
    return;
  }

  // Remove old analytics
  const existing = document.getElementById('serialAnalyticsPage');
  if (existing) existing.remove();

  // Main page
  const page = document.createElement('div');
  page.id = 'serialAnalyticsPage';
  Object.assign(page.style, {
    position: 'fixed',
    inset: 0,
    background: '#f9fafb',
    color: '#111',
    zIndex: 9999,
    overflowY: 'auto',
    padding: '36px 20px',
    boxSizing: 'border-box',
    fontFamily: 'Poppins, system-ui, sans-serif'
  });

  // Back button
  const backBtn = document.createElement('button');
  backBtn.textContent = '← Back';
  Object.assign(backBtn.style, {
    position: 'fixed',
    top: '20px',
    left: '20px',
    padding: '10px 18px',
    background: '#fff',
    border: '1px solid #ddd',
    borderRadius: '12px',
    fontWeight: 600,
    cursor: 'pointer',
    boxShadow: '0 4px 14px rgba(0,0,0,0.08)'
  });
  backBtn.addEventListener('click', () => page.remove());
  page.appendChild(backBtn);

  // Title
  const title = document.createElement('h2');
  title.textContent = `${serial.title || 'Untitled Serial'} Analytics`;
  Object.assign(title.style, {
    textAlign: 'center',
    fontSize: '28px',
    margin: '8px 0 20px',
    fontWeight: 800
  });
  page.appendChild(title);

  // Votes
  const votesStore = JSON.parse(localStorage.getItem(VOTES_STORE_KEY) || '{}');
  const voteKey = `serial::${serial.title || 'untitled'}`;
  const votes = votesStore[voteKey] || { likes: Number(serial.likes || 0), dislikes: Number(serial.dislikes || 0) };

  // 🆕 Load reads from the read tracking store
  const readsStore = JSON.parse(localStorage.getItem(READS_KEY) || '{}');
  const readKey = `serial::${serial.title || 'untitled'}`;
  const readData = readsStore[readKey] || { total: 0, episodes: {} };

  const totalReads = Number(readData.total || 0);
  const episodeCount = Array.isArray(serial.episodes) ? serial.episodes.length : 0;

  // --- Top Stats ---
  const statsWrap = document.createElement('div');
  Object.assign(statsWrap.style, {
    display: 'flex',
    gap: '18px',
    justifyContent: 'space-between',
    maxWidth: '980px',
    margin: '0 auto 18px',
    flexWrap: 'wrap'
  });

  const makeBox = (label, value, color) => {
    const b = document.createElement('div');
    Object.assign(b.style, {
      flex: '1',
      minWidth: '180px',
      background: '#fff',
      borderRadius: '12px',
      padding: '14px',
      boxShadow: '0 8px 28px rgba(0,0,0,0.06)',
      textAlign: 'center',
      fontWeight: 700
    });
    b.innerHTML = `<div style="font-size:13px;color:#6b7280">${label}</div><div style="font-size:22px;color:${color ||
      '#111'}">${value}</div>`;
    return b;
  };

  statsWrap.appendChild(makeBox('Episodes', episodeCount, '#7c3aed'));
  statsWrap.appendChild(makeBox('Total Reads', totalReads, '#3b82f6'));
  statsWrap.appendChild(makeBox('👍 Likes', votes.likes || 0, '#10b981'));
  page.appendChild(statsWrap);

  // --- Per Episode Reads Table ---
  if (episodeCount > 0) {
    const table = document.createElement('table');
    Object.assign(table.style, {
      width: '100%',
      maxWidth: '980px',
      margin: '0 auto 30px',
      borderCollapse: 'collapse',
      background: '#fff',
      borderRadius: '12px',
      overflow: 'hidden',
      boxShadow: '0 8px 28px rgba(0,0,0,0.04)'
    });

    table.innerHTML = `
      <thead style="background:#f3f4f6">
        <tr>
          <th style="text-align:left;padding:10px 14px;font-size:14px;">Episode</th>
          <th style="text-align:center;padding:10px 14px;font-size:14px;">Reads</th>
        </tr>
      </thead>
      <tbody>
        ${serial.episodes
          .map((ep, i) => {
            const r = readData.episodes && readData.episodes[i] ? readData.episodes[i] : 0;
            return `<tr>
              <td style="padding:8px 14px;border-top:1px solid #eee;">${i + 1}. ${ep.title || 'Untitled'}</td>
              <td style="padding:8px 14px;border-top:1px solid #eee;text-align:center;color:#3b82f6;font-weight:600">${r}</td>
            </tr>`;
          })
          .join('')}
      </tbody>
    `;
    page.appendChild(table);
  }

  // --- Chart (reads vs likes per day) ---
  // (same as before, unchanged for brevity)
  // you can keep your existing chart + CSV export code here

  document.body.appendChild(page);
}


  
    dashboardBackBtn.addEventListener('click', ()=>{ dashboardPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); dashboardBackBtn.classList.add('hidden'); });

    function showSerialOptions(slot){
      const modal = document.createElement('div'); modal.className='popup';
      modal.innerHTML = `<div class="popup-content"><h3>${slot.name} — Serial Options</h3>
                         <div style="display:flex;flex-direction:column;gap:8px;margin-top:12px;text-align:left">
                           <button id="manageEpsBtn" class="btn btn-secondary">Manage Episodes</button>
                           <button id="addEpBtn" class="btn btn-primary">Add Episode</button>
                           <button id="openCreateBtn" class="btn btn-primary">Open Serial Form</button>
                           <button id="closeSlotOpts" class="btn btn-secondary" style="margin-top:8px">Close</button>
                         </div></div>`;
      document.body.appendChild(modal);
      modal.querySelector('#manageEpsBtn').addEventListener('click', ()=>{ modal.remove(); showSerialEpisodesEditor(serialSlots.indexOf(slot)); });
      modal.querySelector('#addEpBtn').addEventListener('click', ()=>{ modal.remove();
        const ser = serialsData.find(s=> s.title === slot.name);
        if(!ser){ const newSer = { title: slot.name, genre: '', description: '', episodes: slot.episodes ? slot.episodes.slice() : [] }; serialsData.push(newSer); }
        const serIndex = serialsData.findIndex(s=> s.title === slot.name);
        addEpisodeSerialIndex = serIndex; addEpTitleInput.value = ''; addEpDescInput.value = ''; addEpisodePopup.classList.remove('hidden');
      });
      modal.querySelector('#openCreateBtn').addEventListener('click', ()=>{ modal.remove();
        serialCreatePopup.dataset.slotIndex = serialSlots.indexOf(slot);
        const existing = serialsData.find(s=> s.title === slot.name);
        if(existing){ seriesTitleInput.value = existing.title || slot.name || ''; seriesGenreInput.value = existing.genre || ''; seriesDescInput.value = existing.description || ''; }
        else { seriesTitleInput.value = slot.name || ''; seriesGenreInput.value = ''; seriesDescInput.value = ''; }
        ep1TitleInput.value = ''; ep1DescInput.value = '';
        serialCreatePopup.classList.remove('hidden');
      });
      modal.querySelector('#closeSlotOpts').addEventListener('click', ()=> modal.remove());
    }

    function showSerialEpisodesEditor(serialIndex){
      const ser = serialsData[serialIndex]; if(!ser) { alert('Serial not found'); return; }
      const modal = document.createElement('div'); modal.className='popup'; modal.innerHTML = `<div class="popup-content"><h3>${ser.title} — Episodes</h3><div id="epsList" style="max-height:300px;overflow:auto;margin-top:10px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="closeEps" class="btn btn-secondary">Close</button></div></div>`;
      document.body.appendChild(modal);
      const epsList = modal.querySelector('#epsList'); const closeEps = modal.querySelector('#closeEps');
      (ser.episodes||[]).forEach((ep, i)=>{
        const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='8px 0';
        row.innerHTML = `<div style="max-width:70%"><strong>${i+1}. ${ep.title}</strong><div style="font-size:13px;color:var(--muted)">${ep.description||''}</div><div style="font-size:12px;color:var(--muted)">Status: ${ep.status||'Draft'}</div></div>`;
        const buttons = document.createElement('div'); buttons.style.display='flex'; buttons.style.gap='8px';
        const editBtn = document.createElement('button'); editBtn.className='small-btn btn btn-secondary'; editBtn.textContent='Edit'; editBtn.addEventListener('click', ()=>{ modal.remove(); createEditorPage(ep.title, ser.genre, ep.description, {isEdit:true, editType:'serial', index: serialIndex, episodeIndex: i, isNewEpisode:false}); });
        buttons.appendChild(editBtn);
        row.appendChild(buttons); epsList.appendChild(row);
      });
      closeEps.addEventListener('click', ()=> modal.remove());
    }

    // ---------- Init ----------
    loadProfile();
    storySlots = [{id:0,unlocked:false,name:''}];
    serialSlots = [{id:0,unlocked:false,name:''}];
    updateHeaderVisibility();
  
    // ---------- Browse Stories rendering & Preview/Reader ----------
const STORY_ALGO_CONFIG = {
  popularityWeight: 0.5,      // lower to allow new creators
  recencyWeight: 0.25,        // same as before
  noveltyWeight: 0.25,        // gives less popular stories a chance
  randomWeight: 0.1,          // small exploration
  freshDaysBoost: 21,         // recent content boost
  freshBoostMultiplier: 1.4,  // stronger boost for fresh content
  explorationFraction: 0.25,
  cardsPerViewport: 6
};

// Session RNG (seeded per page load)
(function initStorySeed() {
  if (window.__STORY_RENDER_SEED) return;
  let extra = 0;
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    extra = arr[0];
  } else {
    extra = Math.floor(Math.random() * 0xffffffff);
  }
  window.__STORY_RENDER_SEED = ((Date.now() & 0xffffffff) ^ extra) >>> 0;
})();
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r = r + Math.imul(r ^ (r >>> 7), 61 | r) ^ r;
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function rngForStoryRender() {
  return mulberry32(window.__STORY_RENDER_SEED);
}

// Utilities
function daysSince(dateString) {
  if (!dateString) return Number.MAX_SAFE_INTEGER;
  const d = new Date(dateString);
  if (isNaN(d)) return Number.MAX_SAFE_INTEGER;
  return Math.floor((Date.now() - d.getTime()) / (1000*60*60*24));
}
function normalizeArray(values) {
  const clean = values.map(v => Number.isFinite(v) ? v : 0);
  const min = Math.min(...clean);
  const max = Math.max(...clean);
  return max === min ? clean.map(() => 0.5) : clean.map(v => (v - min) / (max - min));
}
function shuffleArray(arr, rng=Math.random) {
  for (let i = arr.length-1; i>0; i--) {
    const j = Math.floor((rng ? rng() : Math.random())*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function computeStoryPopularity(s) {
  const reads = Number(s.reads ?? s.readCount ?? 0);
  const likes = Number(s.likes ?? 0);
  return Math.log1p(reads) + 1.5*Math.log1p(likes); // log scale like ALGO_CONFIG
}

// ================= SCORING =================
function scoredStories(stories, rng) {
  rng = rng || Math.random;

  const popArr = stories.map(computeStoryPopularity);
  const ageArr = stories.map(s => Math.max(0, 365 - Math.min(daysSince(s.published||s.createdAt||s.date||s.uploadedAt),365)));

  const popNorm = normalizeArray(popArr);
  const recNorm = normalizeArray(ageArr);

  return stories.map((s,i) => {
    const pop = popNorm[i];
    const rec = recNorm[i];
    const novelty = Math.max(0.2, 1-pop); // ensure new stories get minimum chance
    const randomEps = (rng ? rng() : Math.random()) * STORY_ALGO_CONFIG.randomWeight;

    let score = STORY_ALGO_CONFIG.popularityWeight*pop
              + STORY_ALGO_CONFIG.recencyWeight*rec
              + STORY_ALGO_CONFIG.noveltyWeight*novelty
              + randomEps;

    const ageDays = daysSince(s.published||s.createdAt||s.date||s.uploadedAt);
    if (ageDays <= STORY_ALGO_CONFIG.freshDaysBoost) score *= STORY_ALGO_CONFIG.freshBoostMultiplier;

    return Object.assign({}, s, {
      __score: score,
      __popNorm: pop,
      __recNorm: rec,
      __novelty: novelty,
      __ageDays: ageDays
    });
  });
}

// ================= EXPLORATION =================
function pickStoryExploration(candidates, count, rng) {
  if (!candidates || candidates.length===0 || count<=0) return [];
  rng = rng || Math.random;

  const scored = candidates.map(s => {
    const novelty = s.__novelty ?? 0.5;
    const recency = s.__recNorm ?? 0.5;
    return Object.assign({}, s, { __exploreScore: novelty*0.6 + recency*0.4 + (rng ? rng() : Math.random())*0.1 });
  });

  scored.sort((a,b) => b.__exploreScore - a.__exploreScore);
  return shuffleArray(scored.slice(0, Math.min(count, scored.length)), rng);
}

// Demo stories generator
function generateDemoStories(count=50,rng){rng=rng||rngForStoryRender(); 
  const genres=["Action","Romance","Comedy","Fantasy","Horror","Tragic","Thriller","Adventure","Crime","Historic"]; 
  const covers=[
    "https://picsum.photos/seed/demo1/600/900",
    "https://picsum.photos/seed/demo2/600/900",
    "https://picsum.photos/seed/demo3/600/900",
    "https://picsum.photos/seed/demo4/600/900",
    "https://picsum.photos/seed/demo5/600/900",
    "https://picsum.photos/seed/demo6/600/900"
  ]; 
  const stories=[]; 
  for(let i=0;i<count;i++){
    const genre=genres[Math.floor(rng()*genres.length)];
    const title=`${genre} Demo Story ${i+1}`;
    const readCount=Math.floor(rng()*1000);
    const likes=Math.floor(rng()*400);
    const daysAgo=Math.floor(rng()*400);
    const date=new Date(Date.now()-daysAgo*86400000).toISOString();
    stories.push({id:`demo-${i+1}`,title,genre,description:`Demo ${genre.toLowerCase()} story — random readCount ${readCount}.`,cover:covers[i%covers.length],readCount,reads:readCount,likes,createdAt:date});
  } 
  return stories;
}

// Main render function
function renderBrowseStories(selectedCategory = 'All', opts = { includeDemo: false, demoCount: 50, mergeWithSaved: false }) {
  const rng = rngForStoryRender();
  try {
    const storiesListDiv = document.getElementById('storiesBrowseList');
    const cards = document.getElementById('storiesCards');
    if (!cards) return;

    // Ensure main container is vertical and full-width
    cards.style.display = 'block';
    cards.style.width = '100%';
    cards.style.flexWrap = 'wrap';

    const publicStories = (storiesData || []).filter(s => s.status === 'Public');
    let filteredStories = selectedCategory !== 'All'
      ? publicStories.filter(s => (s.genre || '').toLowerCase() === selectedCategory.toLowerCase())
      : publicStories;

    const demoStories = opts.includeDemo ? generateDemoStories(opts.demoCount || 50, rng) : [];
    let allStories = opts.mergeWithSaved ? demoStories.concat(filteredStories) : demoStories;

    if (allStories.length === 0) {
      storiesListDiv.style.display = 'none';
      return;
    } else {
      storiesListDiv.style.display = 'block';
    }

    // Save horizontal scroll positions for each genre
    const oldScrollX = {};
    cards.querySelectorAll('div[data-genre]').forEach(sec => {
      const g = sec.dataset.genre;
      const sc = sec.querySelector('.scroll-wrap');
      if (sc) oldScrollX[g] = sc.scrollLeft;
    });

    const genresOrder = ["Action", "Romance", "Comedy", "Fantasy", "Horror", "Tragic", "Thriller","Adventure","Crime","Historic"];
    const grouped = {};
    allStories.forEach(s => {
      const g = s.genre ? s.genre.trim() : "Other";
      if (!grouped[g]) grouped[g] = [];
      grouped[g].push(s);
    });

    const allScored = scoredStories(allStories, rng);
    const scoredMap = new Map();
    allScored.forEach(s => scoredMap.set(s.id ?? s.title, s));

    const imagesToWait = [];

    genresOrder.forEach(genre => {
      const list = grouped[genre];
      if (!list || list.length === 0) return;

      // --- reuse existing section if possible ---
      let section = cards.querySelector(`div[data-genre="${genre}"]`);
      if (!section) {
        section = document.createElement('div');
        section.dataset.genre = genre;
        section.style.display = 'block';
        section.style.marginBottom = '32px';
        cards.appendChild(section);

        const heading = document.createElement('h3');
        heading.textContent = genre;
        heading.style.margin = '6px 12px';
        heading.style.textAlign = 'left';
        section.appendChild(heading);
      }

      // --- reuse or create scrollWrap ---
      let scrollWrap = section.querySelector('.scroll-wrap');
      if (!scrollWrap) {
        scrollWrap = document.createElement('div');
        scrollWrap.className = 'scroll-wrap';
        scrollWrap.style.display = 'flex';
        scrollWrap.style.overflowX = 'auto';
        scrollWrap.style.gap = '12px';
        scrollWrap.style.padding = '12px';
        scrollWrap.style.scrollBehavior = 'smooth';
        scrollWrap.style.scrollbarWidth = 'thin';
        scrollWrap.style.flexWrap = 'nowrap';
        section.appendChild(scrollWrap);
      }
      // Clear only the cards inside
      scrollWrap.innerHTML = '';

      const scoredList = list.map(s => scoredMap.get(s.id ?? s.title) || Object.assign({}, s, { __score: rng() * 0.2 }));
      const sorted = scoredList.slice().sort((a, b) => b.__score - a.__score);

      const displayCount = Math.min(sorted.length, Math.max(STORY_ALGO_CONFIG.cardsPerViewport, Math.ceil(sorted.length)));
      const explorationCount = Math.ceil(displayCount * STORY_ALGO_CONFIG.explorationFraction);
      const topCandidates = sorted.slice(0, Math.max(0, displayCount - explorationCount));
      const remaining = sorted.slice(displayCount - explorationCount);
      const explorationPool = remaining.concat(sorted.slice(displayCount));
      const explorationPicked = pickStoryExploration(explorationPool, explorationCount, rng);

      const finalList = [];
      const maxLen = Math.max(topCandidates.length, explorationPicked.length);
      for (let i = 0; i < maxLen; i++) {
        if (i < topCandidates.length) finalList.push(topCandidates[i]);
        if (i < explorationPicked.length) finalList.push(explorationPicked[i]);
      }
      if (finalList.length === 0) finalList.push(...sorted.slice(0, displayCount));
      shuffleArray(finalList, rng);

      // --- build cards ---
finalList.forEach(s => {
    const card = document.createElement('div');
    card.className = 'story-card';
    card.dataset.title = s.title || '';
    card.style.minWidth = '260px';
    card.style.flex = '0 0 auto';
    card.style.borderRadius = '14px';
    card.style.padding = '14px';
    card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.justifyContent = 'space-between';
    card.style.cursor = 'pointer';
    card.style.position = 'relative';
    card.style.flexShrink = '0';
    card.style.backfaceVisibility = 'hidden';
    card.style.transition = 'box-shadow 0.25s ease-out';
    card.style.willChange = 'transform, box-shadow';

    // Inner wrapper for scaling & lifting
    const inner = document.createElement('div');
    inner.style.display = 'flex';
    inner.style.flexDirection = 'column';
    inner.style.justifyContent = 'space-between';
    inner.style.height = '100%';
    inner.style.transition = 'transform 0.25s ease-out';
    inner.style.transformOrigin = 'center center';
    card.appendChild(inner);

    // State
    let scaled = false;

    const scaleUp = () => {
        if (!scaled) {
            inner.style.transform = 'scale(1.15) translateY(-6px)'; // bigger + lift
            card.style.boxShadow = '0 16px 32px rgba(0,0,0,0.35)'; // stronger shadow
            scaled = true;
        }
    };

    const scaleDown = () => {
        if (scaled) {
            inner.style.transform = 'scale(1) translateY(0)';
            card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)';
            scaled = false;
        }
    };

    // Desktop hover
    card.addEventListener('mouseenter', scaleUp);
    card.addEventListener('mouseleave', scaleDown);

    // Mobile / touch
    let touchTimer;
    card.addEventListener('touchstart', e => {
        e.stopPropagation();
        touchTimer = setTimeout(scaleUp, 150);
    });
    card.addEventListener('touchend', e => {
        clearTimeout(touchTimer);
        scaleDown();
    });
    card.addEventListener('touchcancel', scaleDown);

    




        if (s.cover) {
          const img = new Image();
          img.src = s.cover;
          imagesToWait.push(new Promise(resolve => { if (img.complete) return resolve(); img.onload = img.onerror = () => resolve(); }));
          card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)),url(${s.cover})`;
          card.style.backgroundSize = 'cover';
          card.style.backgroundPosition = 'center';
          card.style.color = '#fff';
        } else {
          let color;
          switch ((s.genre || '').toLowerCase()) {
            case 'action': color = '#ff4b4b'; break;
            case 'romance': color = '#ff6fa8'; break;
            case 'comedy': color = '#ffd54f'; break;
            case 'tragic': color = '#4fc3f7'; break;
            case 'horror': color = '#000'; break;
            case 'fantasy': color = '#a78bfa'; break;
            case 'thriller': color = '#A52A2A'; break;
            case 'crime': color = '#FF0000'; break;
            case 'adventure': color = '#FF0000'; break;
            case 'historic': color = '#C0C0C0'; break;
            default: color = '#888'; break;
          }
          card.style.background = color;
          card.style.color = color === '#000' ? '#fff' : '#000';
        }

        const titleEl = document.createElement('h4');
        titleEl.textContent = s.title || 'Untitled';
        titleEl.style.margin = '0 0 6px';
        titleEl.style.fontSize = '17px';
        titleEl.style.fontWeight = '700';
        titleEl.style.textShadow = s.cover ? '1px 1px 3px rgba(0,0,0,0.6)' : '';

        const genreEl = document.createElement('p');
        genreEl.textContent = s.genre || 'Unknown';
        genreEl.style.margin = '0 0 6px';
        genreEl.style.fontSize = '13px';
        genreEl.style.fontWeight = '600';
        genreEl.style.opacity = '0.9';
        genreEl.style.textShadow = s.cover ? '1px 1px 2px rgba(0,0,0,0.4)' : '';

        const desc = document.createElement('p');
        desc.textContent = s.description || '';
        desc.style.margin = '4px 0 8px';
        desc.style.fontSize = '14px';
        desc.style.lineHeight = '1.4';
        desc.style.overflow = 'hidden';
        desc.style.display = '-webkit-box';
        desc.style.webkitLineClamp = '3';
        desc.style.webkitBoxOrient = 'vertical';
        desc.style.textShadow = s.cover ? '1px 1px 2px rgba(0,0,0,0.4)' : '';

        const bottomRow = document.createElement('div');
        bottomRow.style.display = 'flex';
        bottomRow.style.justifyContent = 'space-between';
        bottomRow.style.alignItems = 'center';
        bottomRow.style.marginTop = 'auto';

        const reads = document.createElement('div');
        reads.textContent = '👁️ ' + (s.reads || 0);
        reads.style.fontSize = '13px';
        reads.style.fontWeight = '600';

        const readBtn = document.createElement('button');
        readBtn.className = 'btn btn-primary';
        readBtn.textContent = 'Read';
        readBtn.addEventListener('click', e => {
          e.stopPropagation();
          openPreviewFullScreen(s);
        });

        bottomRow.appendChild(reads);
        bottomRow.appendChild(readBtn);

        card.appendChild(titleEl);
        card.appendChild(genreEl);
        card.appendChild(desc);
        card.appendChild(bottomRow);

        scrollWrap.appendChild(card);
      });

      // Restore horizontal scroll
      if (oldScrollX[genre] !== undefined) {
        const prevBehavior = scrollWrap.style.scrollBehavior;
        scrollWrap.style.scrollBehavior = 'auto';
        scrollWrap.scrollLeft = oldScrollX[genre];
        scrollWrap.style.scrollBehavior = prevBehavior || 'smooth';
      }
    });

    // --- no vertical scroll restoration --- 

  } catch (err) {
    console.warn(err);
  }
}

// Run demo
renderBrowseStories('All');



    // open preview modal for a story object
    function openPreview(story){
      const modal = document.getElementById('previewModal');
      document.getElementById('previewTitle').textContent = story.title;
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      let author = '—';
      if(profileRaw){ try{ const p = JSON.parse(profileRaw); author = p.name || '—'; }catch(e){} }
      const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];
      document.getElementById('previewMeta').textContent = `${story.genre || '—'} • Written by ${author} • Written on ${dateStr}`;
      document.getElementById('previewDesc').textContent = story.description || '';
      // pick random sentence(s) from sheets
      let snippet = '';
      try{
        const allText = (story.sheets||[]).map(sh => sh.content || '').join(' ');
        const sentences = allText.split(/(?<=[.!?])\s+/).filter(Boolean);
        for(let i=0;i<3 && i<sentences.length;i++){
          const r = Math.floor(Math.random()*sentences.length);
          snippet += (sentences[r] || '') + ' ';
        }
        snippet = snippet.trim().slice(0,300) + (snippet.length>300 ? '...' : '');
      }catch(e){ snippet = (story.sheets && story.sheets[0] && story.sheets[0].content.slice(0,200)) || ''; }
      document.getElementById('previewSnippet').textContent = snippet;
      modal.classList.remove('hidden');
      document.getElementById('previewCloseBtn').onclick = ()=> modal.classList.add('hidden');
      document.getElementById('startReadingBtn').onclick = ()=> { modal.classList.add('hidden'); openReader(story); };
    }

    // Reader
    let _currentReader = { story:null, sheetIndex:0 };
    function openReader(story){
      const modal = document.getElementById('readerModal');
      const titleEl = document.getElementById('readerTitle');
      const metaEl = document.getElementById('readerMeta');
      const sheetEl = document.getElementById('readerSheet');
      const pager = document.getElementById('readerPager');
      _currentReader.story = story;
      _currentReader.sheetIndex = 0;
      titleEl.textContent = story.title;
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      let author = '—';
      if(profileRaw){ try{ const p = JSON.parse(profileRaw); author = p.name || '—'; }catch(e){} }
      const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];
      metaEl.textContent = `${story.genre || '—'} • Written by ${author} • Published on ${dateStr}`;
      function renderSheet(){
        const sheets = story.sheets || [];
        const s = sheets[_currentReader.sheetIndex] || { content: '' };
        sheetEl.textContent = s.content || '';
        pager.textContent = `${_currentReader.sheetIndex+1} / ${Math.max(1,sheets.length)}`;
        document.getElementById('readerPrevBtn').disabled = _currentReader.sheetIndex===0;
        document.getElementById('readerNextBtn').disabled = _currentReader.sheetIndex >= sheets.length-1;
      }
      document.getElementById('readerPrevBtn').onclick = ()=> { if(_currentReader.sheetIndex>0) _currentReader.sheetIndex--; renderSheet(); };
      document.getElementById('readerNextBtn').onclick = ()=> { if((_currentReader.sheetIndex+1) < (story.sheets||[]).length) _currentReader.sheetIndex++; renderSheet(); };
      document.getElementById('readerCloseBtn').onclick = ()=> { modal.classList.add('hidden'); };
      document.getElementById('readerDownloadBtn').onclick = ()=> { downloadSingleStory(story); };
      // simple swipe support
      let startX = null;
      const readerContent = document.getElementById('readerContent');
      readerContent.ontouchstart = (e)=> { startX = e.touches[0].clientX; };
      readerContent.ontouchend = (e)=> {
        if(startX==null) return;
        const dx = e.changedTouches[0].clientX - startX;
        if(dx < -40){ // swipe left -> next
          if(_currentReader.sheetIndex < (story.sheets||[]).length-1) _currentReader.sheetIndex++;
        } else if(dx > 40){ // swipe right -> prev
          if(_currentReader.sheetIndex > 0) _currentReader.sheetIndex--;
        }
        renderSheet();
        startX = null;
      };
      modal.classList.remove('hidden');
      renderSheet();
    }

    // Download functions
    function downloadAllContent(){
      const data = { stories: storiesData, serials: serialsData, exportedOn: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'writer_content_export_'+(new Date().toISOString().slice(0,10))+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    function downloadSingleStory(story){
      const blob = new Blob([JSON.stringify(story, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = (story.title || 'story').replace(/[^\w\-]/g,'_') + '.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    // wire dashboard download button
    document.addEventListener('click', function(e){
      if(e.target && e.target.id === 'dashboardDownloadBtn') downloadAllContent();
    });

    // Ensure published stories show up in Browse after publish/save (hook used in createEditorPage)
    const originalPublishHook = null; // placeholder
    // We'll monkey-patch the place where storiesData is pushed: after publish or saveDraft in createEditorPage, renderBrowseStories is called.
    // To be safe, call renderBrowseStories periodically and when dashboard opens.
    setInterval(()=>{ renderBrowseStories(currentCategorySelection || 'All'); }, 1200);

    // hook categories selection to render browse list appropriately
    const cats = document.querySelectorAll('.cat-card');
    let currentCategorySelection = 'All';
    function attachCategoryClicks(){
      const grid = document.getElementById('categoriesGrid');
      if(!grid) return;
      grid.querySelectorAll('.cat-card').forEach(c=>{
        c.addEventListener('click', ()=>{
          const cat = c.querySelector('.cat-title').textContent || 'All'; currentCategorySelection = cat;
          renderBrowseStories(cat);
        });
      });
    }
    // attach on DOM ready
    window.addEventListener('DOMContentLoaded', ()=>{ setTimeout(attachCategoryClicks, 400); });

    // Fix profile header visibility when returning from dashboard - ensure profile button shown on welcome page
    dashboardBackBtn.addEventListener('click', ()=>{ dashboardPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); dashboardBackBtn.classList.add('hidden'); profileBtn.style.display = 'inline-flex'; });

    // Also whenever showDashboard is called, ensure profile button hidden and dropdown closed
    const originalShowDashboard = showDashboard;
    showDashboard = function(type, genreFilter){ profileBtn.style.display = 'none'; profileDropdown.style.display = 'none'; originalShowDashboard(type, genreFilter); };

    // Ensure renderBrowseStories runs when storiesData changes: override publish/save code paths by wrapping push functions
    // To keep it simple, we override the global arrays' push to call renderBrowseStories after new story added (only for storiesData)
    (function(){
      const origPush = storiesData.push;
      storiesData.push = function(){
        const res = origPush.apply(this, arguments);
        try{ renderBrowseStories(currentCategorySelection || 'All'); }catch(e){};
        return res;
      };
    })();

    // Also when editor publishes (the code in createEditorPage already pushes and then calls showDashboard), but renderBrowseStories will update automatically.
    // Finally, when page loads, render browse stories once
    window.addEventListener('load', ()=>{ setTimeout(()=> renderBrowseStories('All'), 600); });


// ======================
// Updated openPreviewFullScreen
// - Share & Comments buttons moved below author/date
// - Deep-link via ?previewStory=<title> (history updated on open/close)
// ======================
function openPreviewFullScreen(story){
  const previewFull = document.getElementById('previewFull');
  previewFull.innerHTML = '';

  const panel = document.createElement('div');
  panel.className = 'fullscreen-panel';
  const inner = document.createElement('div');
  inner.className = 'panel-inner';

  // --- Author & Date ---
  const profileRaw = localStorage.getItem(window.STORAGE_KEY || 'user_profile_v1');
  let author = 'Jashandeep'; // fallback
  if(profileRaw){
    try{
      const p = JSON.parse(profileRaw);
      if(p.name && p.name.trim()) author = p.name;
    }catch(e){}
  }
  const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];

  // --- Snippet from first sheet ---
  let topSnippet = '';
  try{
    const firstSheet = (story.sheets && story.sheets[0] && story.sheets[0].content) || '';
    const sentences = firstSheet.split(/(?<=[.!?])\s+/).filter(Boolean);
    topSnippet = sentences.length ? sentences.slice(0,2).join(' ').trim().slice(0,360) : firstSheet.slice(0,300);
  }catch(e){ topSnippet = ''; }

  const storyTitle = story.title && story.title.trim() ? story.title : 'GENZ';

  // helper escape
  function escapeHtml(str){
    return String(str == null ? '' : str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  // --- Build inner HTML ---
  // Note: Share + Comments buttons placed below author/date (as requested)
  inner.innerHTML = `
  <div class="panel-top" style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start">
    <div style="flex:1;min-width:0">
      <h1 style="margin:6px 0 4px 0;word-break:break-word">${escapeHtml(storyTitle)}</h1>

      <div class="panel-meta" style="word-break:break-word">${escapeHtml(story.description || '')}</div>
      <div class="panel-meta" style="margin-top:6px">Written by ${escapeHtml(author)} • Written on ${escapeHtml(dateStr)}</div>

      <!-- Share & Comments moved below the author/date -->
      <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
        <button id="previewShareBtn" class="share-btn-small" aria-expanded="false">Share</button>
        <button id="previewCommentsBtn" class="share-btn-small" aria-expanded="false">Comments</button>
      </div>

      <div style="display:flex;align-items:center;gap:12px;font-size:14px;color:var(--muted);margin-top:8px">
        <span>Genre: ${escapeHtml(story.genre || '—')}</span>
        <span id="previewReadCount" style="font-weight:600;color:#fff;background:#000000;padding:2px 6px;border-radius:4px;">👁️ ${story.reads || 0} Reads</span>
      </div>
    </div>
  </div>

  <hr />

  <div style="font-style:italic;color:var(--muted);margin-top:8px;min-height:44px;">${escapeHtml(topSnippet)}</div>
  <div style="margin-top:12px;color:var(--muted);font-size:14px">(Preview shows a few sentences from the story. Click Start Reading to open the full reader.)</div>

  <div id="previewFullTags" class="tag-row" style="margin-top:12px"></div>

  <div style="display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap">
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="previewCloseBtn" class="btn btn-secondary">Close</button>
      <button id="previewStartBtn" class="btn btn-primary">Start Reading</button>
    </div>
  </div>

  <div style="display:flex;gap:12px;align-items:center;margin-top:12px">
    <div style="display:flex;align-items:center;gap:8px">
      <button id="previewLikeBtn" class="btn btn-secondary" aria-pressed="false">👍 Like</button>
      <span id="previewLikeCount" class="muted">0</span>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <button id="previewDislikeBtn" class="btn btn-secondary" aria-pressed="false">👎 Dislike</button>
      <span id="previewDislikeCount" class="muted">0</span>
    </div>
  </div>
  `;

  panel.appendChild(inner);
  previewFull.appendChild(panel);
  previewFull.classList.remove('hidden');

  // --- when opening preview, set previewStory param so shared link opens this preview directly ---
  // Use URL and URLSearchParams to preserve other params
  try {
    const urlObj = new URL(window.location.href);
    urlObj.searchParams.set('previewStory', story.title || '');
    history.replaceState(null, '', urlObj.toString());
  } catch (e) {
    // ignore if URL API fails
  }

  // --- Render Tags ---
  const tagContainer = document.getElementById('previewFullTags');
  tagContainer.innerHTML = '';

  // Safe merge: story.tags + pending tags
  const storyKey = story.title ? story.title.trim() : '';
  const pendingTags = (window._pendingTags && Array.isArray(window._pendingTags[storyKey])) ? window._pendingTags[storyKey] : [];
  const storyTags = Array.isArray(story.tags) ? story.tags : [];
  const tags = [...new Set([...storyTags, ...pendingTags])]; // merge & remove duplicates

  if(tags.length === 0){
    const placeholder = document.createElement('span');
    placeholder.className = 'muted';
    placeholder.textContent = '(No tags yet)';
    tagContainer.appendChild(placeholder);
  } else {
    tags.forEach(t => {
      const chip = document.createElement('div');
      chip.className = 'tag-chip';
      chip.textContent = t;
      tagContainer.appendChild(chip);
    });
  }

  // --- Reads counter ---
  try{
    const previewStartBtn = inner.querySelector('#previewStartBtn');
    if(previewStartBtn){
      previewStartBtn.addEventListener('click', function(){
        story.reads = (story.reads || 0) + 1;
        try{ localStorage.setItem('storiesData', JSON.stringify(storiesData)); }catch(e){}
      });
    }
  }catch(e){ console.warn('reads init failed', e); }

  // --- Like/Dislike logic (kept as you had) ---
  (function setupPreviewVotes(){
    try{
      const keyGlobal = 'global_votes_v1';
      const keyMine = 'my_votes_v1';
      const title = (story && (story.title || 'untitled')).toString();

      function loadJSON(k){ try{ return JSON.parse(localStorage.getItem(k)||'{}'); }catch(e){ return {}; } }
      function saveJSON(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} }

      const globalVotes = loadJSON(keyGlobal);
      const myVotes = loadJSON(keyMine);

      if(!globalVotes[title]) globalVotes[title] = { likes: story.likes||0, dislikes: story.dislikes||0 };
      story.likes = globalVotes[title].likes;
      story.dislikes = globalVotes[title].dislikes;

      const likeBtn = inner.querySelector('#previewLikeBtn');
      const dislikeBtn = inner.querySelector('#previewDislikeBtn');
      const likeCount = inner.querySelector('#previewLikeCount');
      const dislikeCount = inner.querySelector('#previewDislikeCount');

      function render(){
        const mine = myVotes[title] || null;
        if(likeCount) likeCount.textContent = globalVotes[title].likes || 0;
        if(dislikeCount) dislikeCount.textContent = globalVotes[title].dislikes || 0;
        if(likeBtn){
          likeBtn.classList.toggle('btn-primary', mine==='like');
          likeBtn.classList.toggle('btn-secondary', mine!=='like');
        }
        if(dislikeBtn){
          dislikeBtn.classList.toggle('btn-primary', mine==='dislike');
          dislikeBtn.classList.toggle('btn-secondary', mine!=='dislike');
        }
      }

      function saveAndRender(){ saveJSON(keyGlobal, globalVotes); saveJSON(keyMine, myVotes); render(); }

      if(likeBtn) likeBtn.addEventListener('click', function(e){
        e.stopPropagation();
        const prev = myVotes[title] || null;
        if(prev==='like'){
          globalVotes[title].likes = Math.max(0, (globalVotes[title].likes||0)-1);
          delete myVotes[title];
        } else if(prev==='dislike'){
          globalVotes[title].dislikes = Math.max(0, (globalVotes[title].dislikes||0)-1);
          globalVotes[title].likes = (globalVotes[title].likes||0)+1;
          myVotes[title]='like';
        } else {
          globalVotes[title].likes = (globalVotes[title].likes||0)+1;
          myVotes[title]='like';
        }
        saveAndRender();
      });

      if(dislikeBtn) dislikeBtn.addEventListener('click', function(e){
        e.stopPropagation();
        const prev = myVotes[title] || null;
        if(prev==='dislike'){
          globalVotes[title].dislikes = Math.max(0, (globalVotes[title].dislikes||0)-1);
          delete myVotes[title];
        } else if(prev==='like'){
          globalVotes[title].likes = Math.max(0, (globalVotes[title].likes||0)-1);
          globalVotes[title].dislikes = (globalVotes[title].dislikes||0)+1;
          myVotes[title]='dislike';
        } else {
          globalVotes[title].dislikes = (globalVotes[title].dislikes||0)+1;
          myVotes[title]='dislike';
        }
        saveAndRender();
      });

      render();
    }catch(e){ console.warn('vote setup failed', e); }
  })();

  // --- Share UI styles injection (if not already) ---
  if (!document.getElementById('share-ui-style')) {
    const style = document.createElement('style');
    style.id = 'share-ui-style';
    style.textContent = `
      .share-btn-small { background: linear-gradient(135deg,#6ea8fe,#8bd3ff); border:none; color:#fff; padding:6px 10px; border-radius:12px; cursor:pointer; font-weight:600; font-size:13px; transition:transform .15s ease,box-shadow .15s ease; }
      .share-btn-small:hover{ transform:scale(1.03); box-shadow:0 4px 10px rgba(0,0,0,0.12); }
      .share-menu { position:absolute; background:#fff; border:1px solid #e6e6e6; border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:8px; min-width:210px; box-shadow:0 8px 24px rgba(15,15,15,0.12); z-index:1400; }
      .share-option { display:flex; align-items:center; gap:10px; padding:8px; border-radius:8px; border:none; background:#fbfbfb; cursor:pointer; font-weight:500; }
      .share-option:hover { background:#fff1e6; }
      /* Comments panel styles (kept compact) */
       .comments-panel { position: fixed; inset: 0; background: rgba(255,255,255,0.98); z-index: 1500; display: flex; flex-direction: column; padding: 18px; gap: 12px; overflow: hidden; }
  .comments-top { display:flex;align-items:center;justify-content:space-between;gap:12px;border-bottom:1px solid #eee;padding-bottom:12px; }
  .comments-list { display:flex; flex-direction:column; gap:12px; padding:12px 4px; max-width:900px; width:100%; margin:0 auto; overflow:auto; flex:1 1 auto; padding-bottom:120px; } /* reserve space for sticky input */
  .comment-card { background:#fff; border:1px solid #eee; border-radius:12px; padding:12px; box-shadow:0 4px 12px rgba(0,0,0,0.03); }
  .comment-input-wrap { position: sticky; bottom: 12px; display:flex; justify-content:center; width:100%; align-items:center; padding:12px 0 4px; z-index: 1510; pointer-events: auto; }
  .comment-input-wrapper-bg { width:100%; display:flex; justify-content:center; }
  .comment-input { width: min(880px, 96%); display:flex; gap:8px; align-items:center; border-radius:999px; padding:8px; border:1px solid #e5e7eb; box-shadow:0 6px 20px rgba(0,0,0,0.03); background:#fff; }
  .comment-input textarea { flex:1; border:none; outline:none; resize:none; font-size:14px; padding:10px 14px; border-radius:999px; line-height:1.3; background:transparent; color:inherit; }
  .comment-send { background:linear-gradient(90deg,#7c3aed,#06b6d4); color:#fff; border:none; padding:10px 16px; border-radius:999px; cursor:pointer; font-weight:700; box-shadow:0 8px 24px rgba(124,58,237,0.14); transition: transform .12s ease, box-shadow .12s ease; }
  .comment-send:hover { transform: translateY(-2px); box-shadow:0 14px 34px rgba(124,58,237,0.18); }

    `;
    document.head.appendChild(style);
  }

  // --- Create share menu (and make it deep-link aware) ---
  const existingMenu = document.getElementById('story-preview-share-menu');
  if (existingMenu) existingMenu.remove();

  const shareMenu = document.createElement('div');
  shareMenu.id = 'story-preview-share-menu';
  shareMenu.className = 'share-menu';
  shareMenu.style.display = 'none';
  document.body.appendChild(shareMenu);

  function getShareLink(platform){
    // deep link that opens the preview directly: preserves origin/path and sets previewStory param
    try {
      const u = new URL(window.location.href);
      u.searchParams.set('previewStory', story.title || '');
      const link = u.toString();
      const message = `Title: ${story.title || 'Untitled'}\nGenre: ${story.genre || '—'}\nDescription: ${story.description || ''}\nRead here: ${link}`;
      if(platform === 'WhatsApp') return `https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`;
      if(platform === 'Facebook') return `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(link)}`;
      if(platform === 'Twitter') return `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
      return link;
    } catch (e) {
      // fallback simple link
      const link = `${location.origin}${location.pathname}?previewStory=${encodeURIComponent(story.title || '')}`;
      return link;
    }
  }

  const options = [
    { name: 'WhatsApp', label: 'WhatsApp', emoji: '🟢' },
    { name: 'Facebook', label: 'Facebook', emoji: '🔵' },
    { name: 'Twitter', label: 'Twitter', emoji: '🐦' },
    { name: 'Copy', label: 'Copy Link', emoji: '🔗' }
  ];

  options.forEach(opt => {
    const btn = document.createElement('button');
    btn.className = 'share-option';
    btn.type = 'button';
    btn.innerHTML = `${opt.emoji} ${opt.label}`;
    btn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      const link = getShareLink(opt.name);
      if(opt.name === 'Copy'){
        try{
          await navigator.clipboard.writeText(link);
          btn.textContent = '✅ Link Copied!';
          setTimeout(()=> btn.innerHTML = `${opt.emoji} ${opt.label}`, 1400);
        }catch(e){
          // fallback copy
          const tmp = document.createElement('input');
          tmp.value = link;
          document.body.appendChild(tmp);
          tmp.select();
          try{ document.execCommand('copy'); btn.textContent = '✅ Link Copied!'; }catch(_){}
          tmp.remove();
          setTimeout(()=> btn.innerHTML = `${opt.emoji} ${opt.label}`, 1400);
        }
      } else {
        window.open(link, '_blank');
      }
      shareMenu.style.display = 'none';
      const shareBtn = inner.querySelector('#previewShareBtn');
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    });
    shareMenu.appendChild(btn);
  });

  // Position & toggle share menu
  const shareBtn = inner.querySelector('#previewShareBtn');
  if (shareBtn) {
    shareBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const rect = shareBtn.getBoundingClientRect();
      const spaceBelow = window.innerHeight - rect.bottom;
      const menuHeightGuess = 200;
      if(spaceBelow > menuHeightGuess) {
        shareMenu.style.top = (rect.bottom + window.scrollY + 8) + 'px';
      } else {
        shareMenu.style.top = Math.max(8, rect.top + window.scrollY - menuHeightGuess - 8) + 'px';
      }
      const left = rect.right + window.scrollX - Math.min(shareMenu.offsetWidth || 220, 220);
      shareMenu.style.left = (left > 8 ? left : rect.left + window.scrollX) + 'px';
      shareMenu.style.display = shareMenu.style.display === 'flex' || shareMenu.style.display === 'block' ? 'none' : 'flex';
      shareMenu.style.flexDirection = 'column';
      shareBtn.setAttribute('aria-expanded', shareMenu.style.display !== 'none');
    });
  }

  // Close share menu on outside click or escape
  function closeShareMenuOnClick(e){
    if(!shareMenu.contains(e.target) && e.target !== shareBtn) {
      shareMenu.style.display = 'none';
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    }
  }
  function closeShareMenuOnEsc(e){
    if(e.key === 'Escape') {
      shareMenu.style.display = 'none';
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    }
  }
  document.addEventListener('click', closeShareMenuOnClick);
  document.addEventListener('keydown', closeShareMenuOnEsc);

  // --- Close / Start Reading buttons (and cleanup of previewStory param) ---
  const closeBtn = inner.querySelector('#previewCloseBtn');
  const startBtn = inner.querySelector('#previewStartBtn');
  function cleanupPreviewParam(){
    try {
      const u = new URL(window.location.href);
      u.searchParams.delete('previewStory');
      history.replaceState(null, '', u.pathname + u.search + u.hash);
    } catch(e) {}
  }
  if(closeBtn) closeBtn.addEventListener('click', ()=>{
    previewFull.classList.add('hidden');
    cleanupPreviewParam();
  });
  if(startBtn) startBtn.addEventListener('click', ()=> {
    previewFull.classList.add('hidden');
    cleanupPreviewParam();
    if(typeof openReaderFullScreen === 'function') openReaderFullScreen(story);
  });

  // ============================
  // COMMENTS: full panel logic (same pattern as serials)
  // ============================
  (function integrateComments(){
    const COMMENTS_KEY = 'comments_v1';
    const STORAGE_KEY_LOCAL = window.STORAGE_KEY || 'user_profile_v1';
    const commentsKey = `comments::${story.title || 'untitled'}`;

    function loadStore(k){ try{ return JSON.parse(localStorage.getItem(k) || '{}'); }catch(e){ return {}; } }
    function saveStore(k,v){ try{ localStorage.setItem(k, JSON.stringify(v || {})); }catch(e){} }

    // ensure structure exists
    const base = loadStore(COMMENTS_KEY);
    base[commentsKey] = base[commentsKey] || { comments: [] };
    saveStore(COMMENTS_KEY, base);

    const commentsBtn = inner.querySelector('#previewCommentsBtn');
    if (commentsBtn) {
      commentsBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        openCommentsPanel();
      });
    }

    function getCurrentUserName(){
      try{
        const p = JSON.parse(localStorage.getItem(STORAGE_KEY_LOCAL) || '{}');
        if(p && p.name && p.name.trim()) return p.name.trim();
      }catch(e){}
      return 'You';
    }

    function generateId(){ return 'c_' + Date.now().toString(36) + '_' + Math.floor(Math.random()*1000).toString(36); }

    // state for UI
    const expandedReplies = new Set();
    let currentReplyTo = null;

    function loadCommentsObj(){
      const s = loadStore(COMMENTS_KEY);
      s[commentsKey] = s[commentsKey] || { comments: [] };
      return s;
    }
    function saveCommentsObj(obj){
      saveStore(COMMENTS_KEY, obj);
    }

    function openCommentsPanel(){
      // remove existing to re-create fresh
      let cpanel = document.getElementById('previewCommentsFull');
      if(cpanel) cpanel.remove();

      cpanel = document.createElement('div');
      cpanel.id = 'previewCommentsFull';
      cpanel.className = 'comments-panel';

      const top = document.createElement('div');
      top.className = 'comments-top';
      top.innerHTML = `
        <div style="display:flex;align-items:center;gap:12px;flex:1">
          <div class="comments-title" style="display:flex;gap:12px;align-items:center">
            <span style="font-size:20px">${escapeHtml(story.title || 'Untitled')}</span>
            <span class="comments-count-badge" id="previewCommentsCount">${(loadCommentsObj()[commentsKey].comments || []).length} comments</span>
          </div>
          <div class="small-muted" style="margin-left:auto">Likes: <strong id="previewSerialLikeBadge">${story.likes || 0}</strong></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="closePreviewCommentsBtn" class="share-btn-small" style="background:linear-gradient(90deg,#ef4444,#f97316)">Close</button>
        </div>
      `;
      cpanel.appendChild(top);

      const list = document.createElement('div');
      list.className = 'comments-list';
      list.id = 'previewCommentsList';
      cpanel.appendChild(list);

      const inputWrap = document.createElement('div');
      inputWrap.className = 'comment-input-wrap';
      inputWrap.innerHTML = `
        <div id="previewReplyModeIndicatorWrap" style="display:none;"></div>
        <div class="comment-input">
          <textarea id="previewCommentTextArea" placeholder="Add a public comment..." rows="2"></textarea>
          <button id="previewSendCommentBtn" class="comment-send">Send</button>
        </div>
      `;
      cpanel.appendChild(inputWrap);

      document.body.appendChild(cpanel);

      document.getElementById('closePreviewCommentsBtn').addEventListener('click', ()=> cpanel.remove() );
      document.getElementById('previewSendCommentBtn').addEventListener('click', sendComment);
      document.getElementById('previewCommentTextArea').addEventListener('keydown', function(e){
        if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendComment(); }
      });

      renderComments();
    }

    function sendComment(){
      const ta = document.getElementById('previewCommentTextArea');
      if(!ta) return;
      const text = ta.value.trim();
      if(!text) return;
      const user = getCurrentUserName();
      const obj = loadCommentsObj();

      if(currentReplyTo){
        const parent = (obj[commentsKey].comments || []).find(x => x.id === currentReplyTo);
        if(!parent){
          currentReplyTo = null;
        } else {
          const newReply = { id: generateId(), author: user, text: text, ts: Date.now(), likes: 0, dislikes: 0 };
          parent.replies = parent.replies || [];
          parent.replies.push(newReply);
          expandedReplies.add(parent.id);
          saveCommentsObj(obj);
          ta.value = '';
          currentReplyTo = null;
          renderComments();
          updateReplyModeIndicator();
          return;
        }
      }

      const newComment = { id: generateId(), author: user, text: text, ts: Date.now(), likes: 0, dislikes: 0, replies: [] };
      obj[commentsKey].comments.unshift(newComment);
      saveCommentsObj(obj);
      ta.value = '';
      renderComments();
    }

    function updateReplyModeIndicator(){
      const wrap = document.getElementById('previewReplyModeIndicatorWrap');
      if(!wrap) return;
      if(currentReplyTo){
        const obj = loadCommentsObj();
        const c = (obj[commentsKey].comments || []).find(x => x.id === currentReplyTo);
        const name = c ? c.author : '';
        wrap.style.display = 'block';
        wrap.innerHTML = `<div class="reply-mode-indicator">Replying to <strong>${escapeHtml(name)}</strong>
          <button id="previewCancelReplyMode" class="btn-action" style="margin-left:8px">Cancel</button></div>`;
        const cancel = document.getElementById('previewCancelReplyMode');
        if(cancel) cancel.addEventListener('click', ()=>{
          currentReplyTo = null;
          updateReplyModeIndicator();
          const ta = document.getElementById('previewCommentTextArea');
          if(ta) ta.focus();
        });
      } else {
        wrap.style.display = 'none';
        wrap.innerHTML = '';
      }
    }

    function renderComments(){
      const list = document.getElementById('previewCommentsList');
      if(!list) return;
      list.innerHTML = '';
      const obj = loadCommentsObj();
      const arr = obj[commentsKey].comments || [];
      const badge = document.getElementById('previewCommentsCount');
      if(badge) badge.textContent = `${arr.length} comments`;
      const likeBadge = document.getElementById('previewSerialLikeBadge');
      if(likeBadge) likeBadge.textContent = story.likes || 0;

      arr.forEach(comment => {
        const card = document.createElement('div');
        card.className = 'comment-card';
        card.dataset.cid = comment.id;

        const meta = document.createElement('div');
        meta.className = 'comment-meta';

        const left = document.createElement('div');
        left.innerHTML = `${escapeHtml(comment.author)} <span class="small-muted" style="font-weight:500;margin-left:8px">${new Date(comment.ts).toLocaleString()}</span>`;

        const right = document.createElement('div');

        if(comment.author === getCurrentUserName()){
          const delBtn = document.createElement('button');
          delBtn.className = 'btn-action delete-comment';
          delBtn.textContent = 'Delete';
          delBtn.addEventListener('click', ()=>{
            if(!confirm('Delete this comment?')) return;
            deleteComment(comment.id);
          });
          right.appendChild(delBtn);
        }

        meta.appendChild(left);
        meta.appendChild(right);
        card.appendChild(meta);

        const text = document.createElement('div');
        text.className = 'comment-text';
        text.innerHTML = escapeHtml(comment.text);
        card.appendChild(text);

        const actions = document.createElement('div');
        actions.className = 'comment-actions';
        const repliesCount = (comment.replies || []).length;
        actions.innerHTML = `
          <button class="btn-action like-comment">👍 <span class="cnt">${comment.likes || 0}</span></button>
          <button class="btn-action dislike-comment">👎 <span class="cnt">${comment.dislikes || 0}</span></button>
          <button class="btn-action reply-open">Reply</button>
          <button class="btn-action replies-toggle">Replies (${repliesCount})</button>
        `;
        card.appendChild(actions);

        const replyList = document.createElement('div');
        replyList.className = 'reply-list';
        replyList.style.display = expandedReplies.has(comment.id) ? 'flex' : 'none';

        (comment.replies || []).forEach(reply => {
          const r = document.createElement('div');
          r.className = 'reply-card';
          r.dataset.rid = reply.id;

          const topRow = document.createElement('div');
          topRow.style.display = 'flex';
          topRow.style.justifyContent = 'space-between';
          topRow.style.alignItems = 'center';

          const authorDiv = document.createElement('div');
          authorDiv.style.fontWeight = '600';
          authorDiv.innerHTML = `${escapeHtml(reply.author)} <span class="small-muted" style="font-weight:500;margin-left:8px">${new Date(reply.ts).toLocaleString()}</span>`;

          const rightTop = document.createElement('div');

          if(reply.author === getCurrentUserName()){
            const delR = document.createElement('button');
            delR.className = 'btn-action delete-reply';
            delR.textContent = 'Delete';
            delR.addEventListener('click', ()=>{
              if(!confirm('Delete this reply?')) return;
              deleteReply(comment.id, reply.id);
            });
            rightTop.appendChild(delR);
          }

          topRow.appendChild(authorDiv);
          topRow.appendChild(rightTop);

          const replyText = document.createElement('div');
          replyText.style.marginTop = '6px';
          replyText.innerHTML = escapeHtml(reply.text);

          const replyActions = document.createElement('div');
          replyActions.style.marginTop = '8px';
          replyActions.style.display = 'flex';
          replyActions.style.gap = '8px';
          replyActions.innerHTML = `<button class="btn-action like-reply">👍 <span class="cnt">${reply.likes || 0}</span></button>
                                    <button class="btn-action dislike-reply">👎 <span class="cnt">${reply.dislikes || 0}</span></button>`;

          r.appendChild(topRow);
          r.appendChild(replyText);
          r.appendChild(replyActions);

          replyActions.querySelector('.like-reply').addEventListener('click', ()=> toggleReplyVote(comment.id, reply.id, 'like'));
          replyActions.querySelector('.dislike-reply').addEventListener('click', ()=> toggleReplyVote(comment.id, reply.id, 'dislike'));

          replyList.appendChild(r);
        });

        card.appendChild(replyList);

        actions.querySelector('.like-comment').addEventListener('click', ()=> toggleCommentVote(comment.id, 'like'));
        actions.querySelector('.dislike-comment').addEventListener('click', ()=> toggleCommentVote(comment.id, 'dislike'));

        actions.querySelector('.reply-open').addEventListener('click', ()=> {
          currentReplyTo = comment.id;
          updateReplyModeIndicator();
          const ta = document.getElementById('previewCommentTextArea');
          if(ta) ta.focus();
        });

        actions.querySelector('.replies-toggle').addEventListener('click', ()=> {
          if(expandedReplies.has(comment.id)) expandedReplies.delete(comment.id);
          else expandedReplies.add(comment.id);
          renderComments();
        });

        list.appendChild(card);
      });

      updateReplyModeIndicator();
    }

    function toggleCommentVote(commentId, mode){
      const obj = loadCommentsObj();
      const comments = obj[commentsKey].comments || [];
      const c = comments.find(x => x.id === commentId);
      if(!c) return;
      if(mode === 'like') c.likes = (c.likes || 0) + 1;
      else c.dislikes = (c.dislikes || 0) + 1;
      saveCommentsObj(obj);
      renderComments();
    }

    function toggleReplyVote(commentId, replyId, mode){
      const obj = loadCommentsObj();
      const comments = obj[commentsKey].comments || [];
      const c = comments.find(x => x.id === commentId);
      if(!c) return;
      const r = (c.replies || []).find(rr => rr.id === replyId);
      if(!r) return;
      if(mode === 'like') r.likes = (r.likes || 0) + 1;
      else r.dislikes = (r.dislikes || 0) + 1;
      saveCommentsObj(obj);
      renderComments();
    }

    function deleteComment(commentId){
      const obj = loadCommentsObj();
      obj[commentsKey].comments = (obj[commentsKey].comments || []).filter(c => c.id !== commentId);
      saveCommentsObj(obj);
      expandedReplies.delete(commentId);
      renderComments();
    }

    function deleteReply(commentId, replyId){
      const obj = loadCommentsObj();
      const c = (obj[commentsKey].comments || []).find(x => x.id === commentId);
      if(!c) return;
      c.replies = (c.replies || []).filter(r => r.id !== replyId);
      saveCommentsObj(obj);
      renderComments();
    }
  })();

  // optional: remove listeners when preview closed to avoid leaks
  const observer = new MutationObserver((mutations)=>{
    if(previewFull.classList.contains('hidden')){
      try{
        document.removeEventListener('click', closeShareMenuOnClick);
        document.removeEventListener('keydown', closeShareMenuOnEsc);
      }catch(_){}
      const menu = document.getElementById('story-preview-share-menu');
      if(menu) menu.style.display = 'none';
      const cp = document.getElementById('previewCommentsFull');
      if(cp) cp.remove();

      // cleanup previewStory param (in case user closed by other means)
      try {
        const u = new URL(window.location.href);
        u.searchParams.delete('previewStory');
        history.replaceState(null, '', u.pathname + u.search + u.hash);
      } catch(e) {}
      observer.disconnect();
    }
  });
  observer.observe(previewFull, { attributes: true, attributeFilter: ['class'] });

  // small helper declarations used above (ensure they exist in scope for cleanup)
  function closeShareMenuOnClick(e){ if(!document.getElementById('story-preview-share-menu')) return; const menu = document.getElementById('story-preview-share-menu'); const btn = inner.querySelector('#previewShareBtn'); if(menu && !menu.contains(e.target) && e.target !== btn) { menu.style.display = 'none'; if(btn) btn.setAttribute('aria-expanded', 'false'); } }
  function closeShareMenuOnEsc(e){ const menu = document.getElementById('story-preview-share-menu'); const btn = inner.querySelector('#previewShareBtn'); if(e.key === 'Escape' && menu) { menu.style.display = 'none'; if(btn) btn.setAttribute('aria-expanded', 'false'); } }
}

// Auto-open preview if URL contains ?previewStory=...
(function autoOpenPreviewFromUrl(){
  try {
    const params = new URLSearchParams(window.location.search);
    const t = params.get('previewStory');
    if (!t) return;
    // find story by title (case-sensitive match like your other code)
    if (Array.isArray(storiesData)) {
      const s = storiesData.find(x => x && x.title === t);
      if (s && typeof openPreviewFullScreen === 'function') {
        // small timeout to ensure UI is ready
        setTimeout(()=> openPreviewFullScreen(s), 80);
      }
    }
  } catch(e) { /* ignore */ }
})();
	
    // ---------- Fullscreen Reader ----------
function openReaderFullScreen(story) {
  const readerFull = document.getElementById('readerFull');
  readerFull.innerHTML = '';

  const panel = document.createElement('div');
  panel.className = 'reader-full';
  panel.style.position = 'fixed';
  panel.style.top = 0;
  panel.style.left = 0;
  panel.style.width = '100vw';
  panel.style.height = '100vh';
  panel.style.background = '#f7f7fb';
  panel.style.zIndex = 1200;
  panel.style.display = 'flex';
  panel.style.flexDirection = 'column';

  // --- HEADER ---
  const header = document.createElement('div');
  header.className = 'reader-header';
  header.style.display = 'flex';
  header.style.justifyContent = 'space-between';
  header.style.alignItems = 'center';
  header.style.padding = '12px 18px';
  header.style.background = '#fff';

  const profileRaw = localStorage.getItem(STORAGE_KEY);
  let author = '—';
  if (profileRaw) {
    try { author = JSON.parse(profileRaw).name || '—'; } catch (e) {}
  }
  const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];

  header.innerHTML = `
    <div>
      <strong>${story.title}</strong>
      <div class="muted" style="font-size:12px">${story.genre || '—'} • Written by ${author} • ${dateStr}</div>
    </div>
    <div>
      <button id="readerCloseFullBtn" class="btn btn-secondary">Close</button>
    </div>
  `;
  panel.appendChild(header);

  // --- BODY ---
  const body = document.createElement('div');
  body.className = 'reader-body';
  body.style.flex = 1;
  body.style.overflowY = 'auto';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.justifyContent = 'flex-start';
  body.style.padding = '12px';

  const sheet = document.createElement('div');
  sheet.className = 'reader-sheet';
  sheet.style.position = 'relative';
  sheet.style.width = '100%';
  sheet.style.maxWidth = '880px';
  sheet.style.minHeight = '400px';
  sheet.style.padding = '20px';
  sheet.style.background = '#fffef9';
  sheet.style.border = '1px solid #e5d7b7';
  sheet.style.borderRadius = '12px';
  sheet.style.boxShadow = '0 8px 16px rgba(0,0,0,0.1)';
  sheet.style.fontFamily = `'Georgia', 'Times New Roman', serif`;
  sheet.style.fontSize = '16px';
  sheet.style.lineHeight = '1.6';
  sheet.style.color = '#2e2b23';
  sheet.style.textAlign = 'justify';
  sheet.style.letterSpacing = '0.3px';
  sheet.style.whiteSpace = 'pre-wrap';
  sheet.style.overflowWrap = 'break-word';
  body.appendChild(sheet);

  // --- CANVAS ---
  const canvas = document.createElement('canvas');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.pointerEvents = 'none';
  sheet.appendChild(canvas);

  // --- CONTROLS ---
  const controls = document.createElement('div');
  controls.className = 'reader-controls';
  controls.style.display = 'flex';
  controls.style.flexWrap = 'wrap';
  controls.style.gap = '6px';
  controls.style.marginTop = '12px';
  controls.innerHTML = `
    <button id="prevFullBtn" class="btn btn-secondary">◀ Prev</button>
    <button id="startFullBtn" class="btn btn-primary">Start</button>
    <button id="nextFullBtn" class="btn btn-secondary">Next ▶</button>
    <button id="markBtn" class="btn btn-warning">✏️ Mark Last Read</button>
    <button id="removeMarkBtn" class="btn btn-danger" style="display:none;">🗑️ Remove Last Mark</button>
  `;
  body.appendChild(controls);
  panel.appendChild(body);
  readerFull.appendChild(panel);
  readerFull.classList.remove('hidden');

  const sheets = story.sheets || [{ content: '' }];
  let idx = 0;
  const savedKey = `lastReadMark_${story.id || story.title}`;

  // --- CANVAS CONTEXT ---
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  let drawing = false;
  let lastX = 0, lastY = 0;

  function enableDrawing(canvas, context) {
    // Desktop
    canvas.addEventListener('mousedown', e => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    });
    canvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      context.beginPath();
      context.moveTo(lastX, lastY);
      context.lineTo(x, y);
      context.stroke();
      lastX = x;
      lastY = y;
    });
    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseout', () => drawing = false);

    // Mobile / Touch
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.touches[0].clientX - rect.left;
      lastY = e.touches[0].clientY - rect.top;
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      context.beginPath();
      context.moveTo(lastX, lastY);
      context.lineTo(x, y);
      context.stroke();
      lastX = x;
      lastY = y;
    }, { passive: false });

    canvas.addEventListener('touchend', () => drawing = false);
    canvas.addEventListener('touchcancel', () => drawing = false);
  }

  // --- LOAD MARK ---
  function loadMark() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const imgData = localStorage.getItem(`${savedKey}_${idx}`);
    if (imgData) {
      const img = new Image();
      img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      img.src = imgData;
      removeMarkBtn.style.display = 'inline-block';
    } else {
      removeMarkBtn.style.display = 'none';
    }
  }

  const markBtn = document.getElementById('markBtn');
  const removeMarkBtn = document.getElementById('removeMarkBtn');
  const startBtn = document.getElementById('startFullBtn');

  // --- INITIAL LOAD ---
  sheet.textContent = sheets[idx].content || '';
  loadMark();

  // --- EVENT LISTENERS ---
  markBtn.addEventListener('click', () => {
    canvas.style.pointerEvents = 'auto';
    enableDrawing(canvas, ctx);
  });

  removeMarkBtn.addEventListener('click', () => {
    canvas.style.pointerEvents = 'none';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    localStorage.removeItem(`${savedKey}_${idx}`);
    removeMarkBtn.style.display = 'none';
  });

  startBtn.addEventListener('click', () => {
    if (canvas) {
      localStorage.setItem(`${savedKey}_${idx}`, canvas.toDataURL());
      canvas.style.pointerEvents = 'none';
      removeMarkBtn.style.display = 'inline-block';
    }
  });

  document.getElementById('prevFullBtn').addEventListener('click', () => {
    if (idx > 0) {
      idx--;
      sheet.textContent = sheets[idx].content || '';
      loadMark();
    }
  });

  document.getElementById('nextFullBtn').addEventListener('click', () => {
    if (idx < sheets.length - 1) {
      idx++;
      sheet.textContent = sheets[idx].content || '';
      loadMark();
    }
  });

  document.getElementById('readerCloseFullBtn').addEventListener('click', () => {
    readerFull.classList.add('hidden');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
}
    
// --- Fix: Show only one section (stories or serials) and highlight active tab ---
function setDashboardTabHighlight(type) {
  const storiesBtn = document.getElementById('showStoriesBtn');
  const serialsBtn = document.getElementById('showSerialsBtn');

  if (type === 'stories') {
    storiesBtn.classList.add('btn-primary');
    storiesBtn.classList.remove('btn-secondary');
    serialsBtn.classList.add('btn-secondary');
    serialsBtn.classList.remove('btn-primary');
  } else {
    serialsBtn.classList.add('btn-primary');
    serialsBtn.classList.remove('btn-secondary');
    storiesBtn.classList.add('btn-secondary');
    storiesBtn.classList.remove('btn-primary');
  }
}

document.getElementById('showStoriesBtn').addEventListener('click', () => {
  showDashboard('stories');
  setDashboardTabHighlight('stories');
});

document.getElementById('showSerialsBtn').addEventListener('click', () => {
  showDashboard('serials');
  setDashboardTabHighlight('serials');
});

const oldShowDashboard = showDashboard;
showDashboard = function(type = 'stories', genreFilter = 'All') {
  oldShowDashboard(type, genreFilter);
  setDashboardTabHighlight(type);
};

</script>

<!-- START: SERIALS EXTENSION INJECTION -->
<script>
// Saved serials storage key
const SAVED_SERIALS_KEY = 'savedSerials_v1';

// Utility: load/save serials from localStorage
function loadSavedSerials(){
  try{ const raw = localStorage.getItem(SAVED_SERIALS_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ console.warn(e); return []; }
}
function saveSavedSerials(arr){ try{ localStorage.setItem(SAVED_SERIALS_KEY, JSON.stringify(arr)); }catch(e){ console.warn(e); } }

// Ensure serialsData syncs to savedSerials periodically and on key events
function syncSerialsToStorage(){
  try{
    const current = loadSavedSerials();
    // merge serialsData into saved (by title)
    (serialsData || []).forEach(s => {
      if(!s || !s.title) return;
      const existing = current.find(x => x.title === s.title);
      if(existing){
        // update existing
        existing.genre = s.genre || existing.genre;
        existing.description = s.description || existing.description;
        existing.episodes = s.episodes || existing.episodes || [];
      } else {
        current.push(JSON.parse(JSON.stringify(s)));
      }
    });
    saveSavedSerials(current);
    renderBrowseSerials(current);
  }catch(e){ console.warn(e); }
}
// call periodically as a safety net
setInterval(syncSerialsToStorage, 1500);

// Hook some UI actions that already exist to call sync after create/update
try{
  // when serial create popup confirms
  const origSerialCreateConfirm = window.serialCreateConfirmBtn;
}catch(e){ /* ignore if not accessible */ }

// expose a function to render serials browse listing
// Tunable parameters
// ------------------ CONFIG ------------------
const ALGO_CONFIG = {
  popularityWeight: 0.5,
  recencyWeight: 0.25,
  noveltyWeight: 0.25,
  randomWeight: 0.1,
  freshDaysBoost: 21,
  freshBoostMultiplier: 1.4,
  explorationFraction: 0.25,
  cardsPerViewport: 6,
  trending: {
    addThreshold: 50,
    keepThreshold: 100,
    dropThreshold: 40,
    expireDays: 7
  },
  recentlyReadLimit: 50
};

// LocalStorage keys
const SERIAL_READS_KEY = 'serial_reads_v1';
const TRENDING_STATE_KEY = 'trending_serials_v1';
const RECENTLY_READ_KEY = 'recently_read_v1';

// ---------------- SESSION SEED / PRNG ----------------
(function initSessionSeed() {
  if (window.__SERIALS_RENDER_SEED) return;
  let extra = 0;
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    extra = arr[0];
  } else {
    extra = Math.floor(Math.random() * 0xffffffff);
  }
  window.__SERIALS_RENDER_SEED = ((Date.now() & 0xffffffff) ^ extra) >>> 0;
})();

function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r = r + Math.imul(r ^ (r >>> 7), 61 | r) ^ r;
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function rngForThisRender() { return mulberry32(window.__SERIALS_RENDER_SEED); }

// ---------------- UTILITIES ----------------
function daysSince(dateString) {
  if (!dateString) return Number.MAX_SAFE_INTEGER;
  const d = new Date(dateString);
  if (isNaN(d)) return Number.MAX_SAFE_INTEGER;
  return Math.floor((Date.now() - d.getTime()) / (1000 * 60 * 60 * 24));
}
function normalizeArray(values) {
  const clean = values.map(v => Number.isFinite(v) ? v : 0);
  const min = Math.min(...clean);
  const max = Math.max(...clean);
  return max === min ? clean.map(() => 0.5) : clean.map(v => (v - min) / (max - min));
}
function shuffleArray(arr, rng = Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor((rng ? rng() : Math.random()) * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function computePopularityMetric(s) {
  const reads = Number(s.reads ?? s.readCount ?? 0);
  const likes = Number(s.likes ?? 0);
  return Math.log1p(reads) + 1.5 * Math.log1p(likes);
}

// ---------------- TRENDING state helpers ----------------
function loadTrendingState() {
  try {
    const raw = localStorage.getItem(TRENDING_STATE_KEY);
    return raw ? JSON.parse(raw) : { ids: {}, lastUpdated: Date.now() };
  } catch (e) { return { ids: {}, lastUpdated: Date.now() }; }
}
function saveTrendingState(state) {
  try { localStorage.setItem(TRENDING_STATE_KEY, JSON.stringify(state)); } catch (e) {}
}

function getRecentReadsForSerial(s) {
  const candidates = [ s.recentReads, s.readsLast24h, s.readsToday, s.readsLastDay, s.dailyReads ];
  for (let c of candidates) if (Number.isFinite(c)) return Number(c);
  if (Number.isFinite(s.readCount) && Number.isFinite(s.prevReadCount)) {
    return Math.max(0, Number(s.readCount) - Number(s.prevReadCount));
  }
  return undefined;
}

function updateTrendingStateForSerials(serials) {
  const state = loadTrendingState();
  const now = Date.now();
  const cfg = ALGO_CONFIG.trending;
  serials.forEach(s => {
    const id = s.id ?? s.slug ?? s.title;
    if (!id) return;
    const recent = getRecentReadsForSerial(s);
    const currentlyTrending = !!state.ids[id];

    if (Number.isFinite(recent)) {
      if (recent >= cfg.keepThreshold) {
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (recent >= cfg.addThreshold) {
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (currentlyTrending && recent < cfg.dropThreshold) {
        delete state.ids[id];
      } else if (currentlyTrending) {
        state.ids[id] = { ...state.ids[id], lastSeen: now, recent };
      }
    } else {
      if (currentlyTrending) {
        const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
        const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
        if (cfg.expireDays && daysSinceSeen > cfg.expireDays) delete state.ids[id];
      }
    }
  });

  // prune stale ids not in current list if expired
  const presentIds = new Set(serials.map(s => s.id ?? s.slug ?? s.title));
  Object.keys(state.ids).forEach(id => {
    if (!presentIds.has(id)) {
      const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
      const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
      if (ALGO_CONFIG.trending.expireDays && daysSinceSeen > ALGO_CONFIG.trending.expireDays) {
        delete state.ids[id];
      }
    }
  });

  state.lastUpdated = now;
  saveTrendingState(state);
  return state;
}
function getTrendingSerialsFromState(serials, state) {
  const ids = new Set(Object.keys(state.ids || {}));
  return serials.filter(s => {
    const id = s.id ?? s.slug ?? s.title;
    return id && ids.has(id);
  });
}

// ---------------- RECENTLY READ helpers ----------------
function recordRecentlyRead(serial) {
  try {
    const raw = localStorage.getItem(RECENTLY_READ_KEY);
    let arr = raw ? JSON.parse(raw) : [];
    const id = serial.id ?? serial.slug ?? serial.title;
    const entry = {
      id,
      title: serial.title || 'Untitled',
      cover: serial.cover || null,
      genre: serial.genre || null,
      description: serial.description || null,
      at: Date.now()
    };
    arr = arr.filter(x => x.id !== id);
    arr.unshift(entry);
    const limit = Number.isFinite(ALGO_CONFIG.recentlyReadLimit) ? ALGO_CONFIG.recentlyReadLimit : 50;
    if (arr.length > limit) arr = arr.slice(0, limit);
    localStorage.setItem(RECENTLY_READ_KEY, JSON.stringify(arr));
  } catch (e) {}
}
function loadRecentlyRead() {
  try {
    const raw = localStorage.getItem(RECENTLY_READ_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}

// Safe open + record
function openSerialPreviewAndRecord(serial) {
  try { recordRecentlyRead(serial); } catch (e) {}
  if (typeof openSerialPreview === 'function') {
    if (serial.id) openSerialPreview(serial.id);
    else if (serial.slug) openSerialPreview(serial.slug);
    else openSerialPreview(serial.title || '');
  } else {
    console.warn('openSerialPreview not defined');
  }
}

// ---------------- SCORING / EXPLORATION ----------------
function scoredSerialsWithNormalization(serials, rng) {
  rng = rng || Math.random;
  const popArr = serials.map(computePopularityMetric);
  const ageArr = serials.map(s => {
    const ds = daysSince(s.published || s.createdAt || s.date || s.uploadedAt);
    return Math.max(0, 365 - Math.min(ds, 365));
  });
  const popNorm = normalizeArray(popArr);
  const recNorm = normalizeArray(ageArr);

  return serials.map((s, i) => {
    const pop = popNorm[i];
    const rec = recNorm[i];
    const novelty = Math.max(0.2, 1 - pop);
    const randomEps = (rng ? rng() : Math.random()) * ALGO_CONFIG.randomWeight;
    let score = ALGO_CONFIG.popularityWeight * pop
              + ALGO_CONFIG.recencyWeight * rec
              + ALGO_CONFIG.noveltyWeight * novelty
              + randomEps;
    const ageDays = daysSince(s.published || s.createdAt || s.date || s.uploadedAt);
    if (ageDays <= ALGO_CONFIG.freshDaysBoost) score *= ALGO_CONFIG.freshBoostMultiplier;
    return Object.assign({}, s, { __score: score, __popNorm: pop, __recNorm: rec, __novelty: novelty, __ageDays: ageDays });
  });
}

function pickExploration(candidates, count, rng) {
  if (!candidates || candidates.length === 0 || count <= 0) return [];
  rng = rng || Math.random;
  const scored = candidates.map(s => {
    const novelty = s.__novelty ?? 0.5;
    const recency = s.__recNorm ?? 0.5;
    return Object.assign({}, s, { __exploreScore: novelty*0.6 + recency*0.4 + (rng ? rng() : Math.random())*0.1 });
  });
  scored.sort((a,b) => b.__exploreScore - a.__exploreScore);
  return shuffleArray(scored.slice(0, Math.min(count, scored.length)), rng);
}

// ---------------- DEMO generator ----------------
function generateDemoSerials(count = 0, rng) {
  rng = rng || rngForThisRender();
  const genres = ["Action","Romance","Comedy","Fantasy","Horror","Tragedy","Tragic","Thriller","Adventure","Crime","Historic"];
  const covers = [
    "https://picsum.photos/seed/demo1/600/900",
    "https://picsum.photos/seed/demo2/600/900",
    "https://picsum.photos/seed/demo3/600/900",
    "https://picsum.photos/seed/demo4/600/900",
    "https://picsum.photos/seed/demo5/600/900",
    "https://picsum.photos/seed/demo6/600/900"
  ];
  const serials = [];
  for (let i=0;i<count;i++){
    const genre = genres[Math.floor(rng()*genres.length)];
    const title = `${genre} Demo Serial ${i+1}`;
    const readCount = Math.floor(rng()*1000);
    const likes = Math.floor(rng()*400);
    const daysAgo = Math.floor(rng()*400);
    const date = new Date(Date.now()-daysAgo*86400000).toISOString();
    serials.push({
      id:`demo-${i+1}`,
      title, genre, description:`Demo ${genre.toLowerCase()} serial — random readCount ${readCount}.`,
      cover: covers[i % covers.length], readCount, reads: readCount, likes, createdAt: date
    });
  }
  return serials;
}

// ---------------- RENDER HELPERS (card creators) ----------------
function createSerialCard(s, imagesToWait, allSerials) {
  const card = document.createElement('div');
  card.className = 'serial-card';
  card.dataset.title = s.title || '';
  card.style.minWidth = '300px';
  card.style.height = '400px';
  card.style.flex = '0 0 auto';
  card.style.borderRadius = '16px';
  card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.15)';
  card.style.padding = '16px';
  card.style.display = 'flex';
  card.style.flexDirection = 'column';
  card.style.justifyContent = 'space-between';
  card.style.position = 'relative';
  card.style.transition = 'transform 0.25s ease, box-shadow 0.25s ease';
  card.style.overflow = 'hidden';
  card.style.cursor = 'pointer';
  card.style.scrollSnapAlign = 'center';

  if (s.cover) {
    const img = new Image();
    img.src = s.cover;
    img.alt = s.title || 'cover';
    imagesToWait.push(new Promise(resolve => {
      if (img.complete) return resolve();
      img.onload = img.onerror = () => resolve();
    }));
    card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.45),rgba(0,0,0,0.45)),url(${s.cover})`;
    card.style.backgroundSize = 'cover';
    card.style.backgroundPosition = 'center';
    card.style.color = '#fff';
  } else {
    card.style.background = '#fff';
    card.style.color = '#000';
  }

  // Hover / touch scale
  const scaleUp = () => { card.style.transform = 'scale(1.08)'; card.style.zIndex = '2'; card.style.boxShadow = '0 12px 24px rgba(0,0,0,0.3)'; };
  const scaleDown = () => { card.style.transform = 'scale(1)'; card.style.zIndex = '1'; card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.15)'; };
  card.addEventListener('mouseenter', scaleUp);
  card.addEventListener('mouseleave', scaleDown);
  card.addEventListener('touchstart', scaleUp);
  card.addEventListener('touchend', scaleDown);
  card.addEventListener('touchcancel', scaleDown);

  // Info
  const infoDiv = document.createElement('div');
  infoDiv.innerHTML = `<h4 style="margin:0;font-size:17px;text-shadow:1px 1px 3px rgba(0,0,0,0.6)">${s.title || 'Untitled Series'}</h4>
    <p style="margin:6px 0 0;font-size:13px;color:inherit;opacity:0.9;overflow:hidden;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;line-height:1.4;text-shadow:1px 1px 2px rgba(0,0,0,0.4)">${s.description || ''}</p>`;

  // readCount badge
  if (typeof s.readCount !== 'undefined' || typeof s.reads !== 'undefined') {
    const rc = document.createElement('div');
    rc.style.position = 'absolute';
    rc.style.right = '12px';
    rc.style.top = '12px';
    rc.style.background = 'rgba(255,255,255,0.85)';
    rc.style.padding = '6px 8px';
    rc.style.borderRadius = '12px';
    rc.style.fontSize = '12px';
    rc.style.color = '#222';
    rc.textContent = `reads ${Number(s.readCount ?? s.reads ?? 0).toLocaleString()}`;
    card.appendChild(rc);
  }

  // Buttons
  const bottomDiv = document.createElement('div');
  bottomDiv.style.display = 'flex';
  bottomDiv.style.justifyContent = 'flex-end';
  bottomDiv.style.gap = '8px';
  bottomDiv.style.marginTop = '10px';
  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn btn-secondary view-serial-btn';
  viewBtn.textContent = '🎬 View';
  viewBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    // prefer full object open
    openSerialPreviewAndRecord(s);
  });
  bottomDiv.appendChild(viewBtn);

  // Click on card opens preview too
  card.addEventListener('click', () => openSerialPreviewAndRecord(s));

  card.appendChild(infoDiv);
  card.appendChild(bottomDiv);
  return card;
}

function createRecentCard(r, allSerials) {
  const card = document.createElement('div');
  card.className = 'recent-card serial-card';
  card.style.minWidth = '260px';
  card.style.flex = '0 0 auto';
  card.style.borderRadius = '14px';
  card.style.padding = '14px';
  card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)';
  card.style.display = 'flex';
  card.style.flexDirection = 'column';
  card.style.justifyContent = 'space-between';
  card.style.cursor = 'pointer';
  card.style.position = 'relative';
  card.style.flexShrink = '0';
  card.style.backfaceVisibility = 'hidden';

  if (r.cover) {
    card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)),url(${r.cover})`;
    card.style.backgroundSize = 'cover';
    card.style.backgroundPosition = 'center';
    card.style.color = '#fff';
  } else {
    card.style.background = '#fff';
    card.style.color = '#000';
  }

  const titleDiv = document.createElement('h4');
  titleDiv.textContent = r.title || 'Untitled';
  titleDiv.style.margin = '0 0 6px';
  titleDiv.style.fontSize = '17px';
  titleDiv.style.fontWeight = '700';
  titleDiv.style.textShadow = r.cover ? '1px 1px 3px rgba(0,0,0,0.6)' : '';

  const genreDiv = document.createElement('div');
  genreDiv.textContent = r.genre || 'Unknown';
  genreDiv.style.margin = '0 0 6px';
  genreDiv.style.fontSize = '13px';
  genreDiv.style.fontWeight = '600';
  genreDiv.style.opacity = '0.9';

  const descDiv = document.createElement('p');
  descDiv.textContent = r.description || '';
  descDiv.style.margin = '4px 0 8px';
  descDiv.style.fontSize = '14px';
  descDiv.style.lineHeight = '1.4';
  descDiv.style.overflow = 'hidden';
  descDiv.style.display = '-webkit-box';
  descDiv.style.webkitLineClamp = '3';
  descDiv.style.webkitBoxOrient = 'vertical';

  const bottomRow = document.createElement('div');
  bottomRow.style.display = 'flex';
  bottomRow.style.justifyContent = 'flex-end';
  bottomRow.style.alignItems = 'center';
  bottomRow.style.marginTop = 'auto';

  const readBtn = document.createElement('button');
  readBtn.className = 'btn btn-primary';
  readBtn.textContent = 'Read';
  readBtn.addEventListener('click', e => {
    e.stopPropagation();
    // try find in list
    const found = allSerials.find(s => (s.id ?? s.slug ?? s.title) === r.id);
    if (found) openSerialPreviewAndRecord(found);
    else if (typeof openSerialPreview === 'function') openSerialPreview(r.title);
  });

  bottomRow.appendChild(readBtn);
  card.appendChild(titleDiv);
  card.appendChild(genreDiv);
  card.appendChild(descDiv);
  card.appendChild(bottomRow);

  card.addEventListener('click', () => {
    const found = allSerials.find(s => (s.id ?? s.slug ?? s.title) === r.id);
    if (found) openSerialPreviewAndRecord(found);
    else if (typeof openSerialPreview === 'function') openSerialPreview(r.title);
  });

  return card;
}

// ---------------- MAIN renderBrowseSerials (Full integration) ----------------
function renderBrowseSerials(list = null, opts = { includeDemo: true, demoCount: 50, mergeWithSaved: true }) {
  const rng = rngForThisRender();
  try {
    // container
    let container = document.getElementById('serialsBrowseList');
    if (!container) {
      const parent = document.getElementById('serialCategoriesPage') || document.body;
      container = document.createElement('div');
      container.id = 'serialsBrowseList';
      container.style.maxWidth = '980px';
      container.style.margin = '18px auto';
      container.style.display = 'none';
      parent.appendChild(container);
    }

    // load serials (saved or passed in)
    const saved = Array.isArray(list)
      ? list
      : (typeof loadSavedSerials === 'function'
          ? loadSavedSerials()
          : JSON.parse(localStorage.getItem('saved_serials_v1') || '[]'));
    const demo = opts.includeDemo ? generateDemoSerials(opts.demoCount || 50, rng) : [];
    const serialsRaw = saved && saved.length && opts.mergeWithSaved ? demo.concat(saved) : saved && saved.length ? saved : demo;
    if (!serialsRaw || !serialsRaw.length) {
      container.style.display = 'none';
      return;
    }

    // preserve vertical scroll
    const oldScrollY = window.scrollY || document.documentElement.scrollTop;

    // preserve horizontal per-genre scrolls
    const oldScrollX = {};
    container.querySelectorAll('div[data-genre]').forEach(sec => {
      const g = sec.dataset.genre;
      const sc = sec.querySelector('.scroll-wrap');
      if (sc) oldScrollX[g] = sc.scrollLeft;
    });
    // also trending scroll
    const oldTrendingScroll = (container.querySelector('.trending-wrap') || {}).scrollLeft;

    // grouping
    const genresOrder = ['Action','Romance','Comedy','Fantasy','Horror','Tragic','Thriller','Adventure','Crime','Historic'];
    const grouped = {};
    serialsRaw.forEach(s => {
      const g = s.genre ? s.genre.trim() : 'Other';
      if (!grouped[g]) grouped[g] = [];
      grouped[g].push(s);
    });

    // trending update before scoring
    const trendingState = updateTrendingStateForSerials(serialsRaw);

    // scoring
    const allScored = scoredSerialsWithNormalization(serialsRaw, rng);
    const scoredMap = new Map();
    allScored.forEach(s => {
      const key = s.id ?? s.slug ?? s.title ?? JSON.stringify({ title: s.title, createdAt: s.createdAt });
      scoredMap.set(key, s);
    });

    // Clear container
    container.innerHTML = '';
    container.style.display = 'block';
    const imagesToWait = [];

    // ---- TRENDING SECTION (above genres) ----
// ---- TRENDING SECTION (top) ----
const trendingSerials = getTrendingSerialsFromState(allScored, trendingState);
if (trendingSerials && trendingSerials.length) {
  trendingSerials.sort((a,b) => {
    const ida = a.id ?? a.slug ?? a.title;
    const idb = b.id ?? b.slug ?? b.title;
    const ra = (trendingState.ids[ida]?.recent || 0) + (a.__score || 0);
    const rb = (trendingState.ids[idb]?.recent || 0) + (b.__score || 0);
    return rb - ra;
  });

  const trendingSection = document.createElement('div');
  trendingSection.dataset.genre = 'Trending';
  trendingSection.style.display = 'block';
  trendingSection.style.marginBottom = '28px';
  container.appendChild(trendingSection);

  const heading = document.createElement('h2');
  heading.textContent = '🔥 Trending';
  heading.style.margin = '6px 12px';
  heading.style.textAlign = 'left';
  trendingSection.appendChild(heading);

  const scrollWrap = document.createElement('div');
  scrollWrap.className = 'scroll-wrap trending-wrap';
  scrollWrap.style.display = 'flex';
  scrollWrap.style.overflowX = 'auto';
  scrollWrap.style.gap = '12px';
  scrollWrap.style.padding = '12px';
  scrollWrap.style.scrollBehavior = 'smooth';
  scrollWrap.style.scrollSnapType = 'x mandatory';
  scrollWrap.style.scrollbarWidth = 'thin';

  scrollWrap.addEventListener('wheel', e => {
    if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) {
      scrollWrap.scrollLeft += e.deltaY;
      e.preventDefault();
    }
  }, { passive: false });

  const trendingIds = new Set(trendingSerials.map(s => s.id ?? s.slug ?? s.title));

  trendingSerials.forEach(s => {
    const card = createSerialCard(s, imagesToWait, serialsRaw);
    card.style.minWidth = '300px';
    card.style.height = '400px';
    scrollWrap.appendChild(card);
  });

  trendingSection.appendChild(scrollWrap);

  if (oldTrendingScroll !== undefined) {
    const prevBehavior = scrollWrap.style.scrollBehavior;
    scrollWrap.style.scrollBehavior = 'auto';
    scrollWrap.scrollLeft = oldTrendingScroll;
    scrollWrap.style.scrollBehavior = prevBehavior || 'smooth';
  }

  container.__trendingIds = trendingIds;
} else {
  container.__trendingIds = new Set();
}

// ---- GENRE SECTIONS (middle) ----
// ... your existing genre section code here ...

// ---- RECENTLY READ (bottom) ----
// ---- GENRE SECTIONS ----
genresOrder.forEach(genre => {
  const rawList = grouped[genre];
  if (!rawList || !rawList.length) return;

  // filter out anything already in trending (dedupe)
  const trendingIds = container.__trendingIds || new Set();
  const filtered = rawList.filter(s => !trendingIds.has(s.id ?? s.slug ?? s.title));

  if (!filtered.length) return;

  const scoredList = filtered.map(s => {
    const key = s.id ?? s.slug ?? s.title ?? JSON.stringify({ title: s.title, createdAt: s.createdAt });
    return scoredMap.get(key) || Object.assign({}, s, { __score: rng() * 0.2 });
  });

  const sorted = scoredList.slice().sort((a,b) => (b.__score || 0) - (a.__score || 0));

  const displayCount = Math.min(sorted.length, Math.max(ALGO_CONFIG.cardsPerViewport, Math.ceil(sorted.length)));
  const explorationCount = Math.ceil(displayCount * ALGO_CONFIG.explorationFraction);
  const topCandidates = sorted.slice(0, Math.max(0, displayCount - explorationCount));
  const remaining = sorted.slice(displayCount - explorationCount);
  const explorationPool = remaining.concat(sorted.slice(displayCount));
  const explorationPicked = pickExploration(explorationPool, explorationCount, rng);

  const finalList = [];
  const maxLen = Math.max(topCandidates.length, explorationPicked.length);
  for (let i = 0; i < maxLen; i++) {
    if (i < topCandidates.length) finalList.push(topCandidates[i]);
    if (i < explorationPicked.length) finalList.push(explorationPicked[i]);
  }
  if (finalList.length === 0) finalList.push(...sorted.slice(0, displayCount));
  shuffleArray(finalList, rng);

  const section = document.createElement('div');
  section.dataset.genre = genre;
  section.style.marginBottom = '32px';

  const heading = document.createElement('h3');
  heading.textContent = genre;
  heading.style.margin = '6px 12px';
  heading.style.textAlign = 'left';
  section.appendChild(heading);

  const scrollWrap = document.createElement('div');
  scrollWrap.className = 'scroll-wrap';
  scrollWrap.style.display = 'flex';
  scrollWrap.style.overflowX = 'auto';
  scrollWrap.style.gap = '12px';
  scrollWrap.style.padding = '12px';
  scrollWrap.style.scrollBehavior = 'smooth';
  scrollWrap.style.scrollSnapType = 'x mandatory';
  scrollWrap.style.scrollbarWidth = 'thin';

  scrollWrap.addEventListener('wheel', e => {
    if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) {
      scrollWrap.scrollLeft += e.deltaY;
      e.preventDefault();
    }
  }, { passive: false });

  finalList.forEach(s => {
    const card = createSerialCard(s, imagesToWait, serialsRaw);
    scrollWrap.appendChild(card);
  });

  section.appendChild(scrollWrap);
  container.appendChild(section);

  // restore scroll if any
  if (oldScrollX[genre] !== undefined) {
    const prevBehavior = scrollWrap.style.scrollBehavior;
    scrollWrap.style.scrollBehavior = 'auto';
    scrollWrap.scrollLeft = oldScrollX[genre];
    scrollWrap.style.scrollBehavior = prevBehavior || 'smooth';
  }
});

const recentArr = loadRecentlyRead();
if (recentArr && recentArr.length) {
  let recentSection = container.querySelector('[data-section="recently-read"]');
  if (!recentSection) {
    recentSection = document.createElement('div');
    recentSection.dataset.section = 'recently-read';
    recentSection.style.marginTop = '18px';
    recentSection.style.marginBottom = '28px';
    container.appendChild(recentSection);

    const heading = document.createElement('h3');
    heading.textContent = '📚 Recently Read';
    heading.style.margin = '6px 12px';
    heading.style.textAlign = 'left';
    recentSection.appendChild(heading);

    const wrap = document.createElement('div');
    wrap.className = 'recent-wrap';
    wrap.style.display = 'flex';
    wrap.style.flexWrap = 'nowrap';
    wrap.style.overflowX = 'auto';
    wrap.style.overflowY = 'hidden';
    wrap.style.gap = '12px';
    wrap.style.padding = '12px';
    wrap.style.webkitOverflowScrolling = 'touch';
    wrap.style.scrollSnapType = 'x mandatory';
    wrap.style.scrollbarWidth = 'thin';

    wrap.addEventListener('wheel', e => {
      if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) {
        wrap.scrollLeft += e.deltaY;
        e.preventDefault();
      }
    }, { passive: false });

    // Save scroll continuously
    wrap.addEventListener('scroll', () => {
      localStorage.setItem('recentlyReadScrollX', wrap.scrollLeft);
    });

    recentSection.appendChild(wrap);
  }

  const wrap = recentSection.querySelector('.recent-wrap');

  // Add missing cards only
  recentArr.forEach(r => {
    if (![...wrap.children].some(c => c.dataset.title === r.title)) {
      const card = createSerialCard(r, imagesToWait, serialsRaw);
      card.style.minWidth = '300px';
      card.style.height = '400px';
      card.style.flex = '0 0 auto';

      card.querySelectorAll('img').forEach(img => {
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
      });

      wrap.appendChild(card);
    }
  });

  // Restore scroll instantly (no auto or smooth)
  const savedScroll = parseFloat(localStorage.getItem('recentlyReadScrollX') || '0');
  requestAnimationFrame(() => {
    wrap.scrollLeft = savedScroll; // <-- instant jump
  });
}


    // restore vertical scroll
    window.scrollTo({ top: oldScrollY, behavior: 'auto' });

    // optional: wait for images to settle (not awaited here, but we tracked imagesToWait if you want)
    // Promise.all(imagesToWait).then(()=>{/* images loaded */}).catch(()=>{});
  } catch (e) {
    console.warn(e);
  }
}

// ---------------- INITIAL CALL ----------------
// Auto-run like your previous code (keeps demo on by default)
renderBrowseSerials(null, { includeDemo: false, demoCount: 50, mergeWithSaved: false });

function openSerialPreview(title) {
  try {
    const VOTES_STORE_KEY = 'global_votes_v1';
    const USER_VOTES_KEY = 'user_votes_v1';
    const READS_KEY = 'serial_reads_v1';
    const COMMENTS_KEY = 'comments_v1'; // new storage for comments
    const STORAGE_KEY = window.STORAGE_KEY || 'user_profile_v1';

    let saved = [];
    try {
      saved = typeof loadSavedSerials === 'function' ? loadSavedSerials() : (JSON.parse(localStorage.getItem('saved_serials_v1') || '[]'));
    } catch (e) { saved = []; }

    const serial = (saved || []).find(s => s.title === title) || (serialsData || []).find(s => s.title === title);
    if (!serial) { alert('Serial not found'); return; }

    const voteKey = `serial::${serial.title || 'untitled'}`;
    const readKey = `serial::${serial.title || 'untitled'}`;
    const commentsKey = voteKey; // reuse same serial identifier for comments store nesting

    function loadStore(key) { try { return JSON.parse(localStorage.getItem(key) || '{}'); } catch (e) { return {}; } }
    function saveStore(key, obj) { try { localStorage.setItem(key, JSON.stringify(obj || {})); } catch (e) {} }

    const votesStore = loadStore(VOTES_STORE_KEY);
    const userStore = loadStore(USER_VOTES_KEY);
    const readsStore = loadStore(READS_KEY);
    const commentsStore = loadStore(COMMENTS_KEY);

    const storedVotes = votesStore[voteKey] || { likes: Number(serial.likes || 0), dislikes: Number(serial.dislikes || 0) };
    serial.likes = Number(storedVotes.likes || 0);
    serial.dislikes = Number(storedVotes.dislikes || 0);
    votesStore[voteKey] = { likes: serial.likes, dislikes: serial.dislikes };
    saveStore(VOTES_STORE_KEY, votesStore);

    const storedReads = readsStore[readKey] || { total: 0, episodes: {} };
    readsStore[readKey] = storedReads;
    saveStore(READS_KEY, readsStore);

    // ensure comments structure exists
    commentsStore[commentsKey] = commentsStore[commentsKey] || { comments: [] };
    saveStore(COMMENTS_KEY, commentsStore);

    // local UI state
    const expandedReplies = new Set(); // which comment IDs currently showing replies
    let currentReplyTo = null; // if set, sending uses addReply instead of addComment

    let panel = document.getElementById('serialPreviewFull');
    if (!panel) {
      panel = document.createElement('div');
      panel.id = 'serialPreviewFull';
      panel.className = 'fullscreen-panel';
      panel.style.zIndex = 1100;
      panel.style.overflow = 'auto';
      document.body.appendChild(panel);
    }

    panel.innerHTML = '';
    const inner = document.createElement('div');
    inner.className = 'panel-inner';

    function esc(str) { return String(str == null ? '' : str).replace(/</g, '&lt;'); }
    function formatDateVal(raw) {
      if (!raw && raw !== 0) return '—';
      let d = null;
      if (typeof raw === 'number' || /^\d+$/.test(String(raw))) d = new Date(Number(raw));
      else d = new Date(raw);
      if (isNaN(d.getTime())) return '—';
      return d.toLocaleDateString('en-IN', { year: 'numeric', month: 'short', day: 'numeric' });
    }

    let author = serial.author || serial.authorName || serial.writtenBy || serial.writer || serial.by;
    if (!author) {
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      if (profileRaw) {
        try {
          const p = JSON.parse(profileRaw);
          if (p.name && p.name.trim()) author = p.name.trim();
        } catch (e) {}
      }
    }
    author = author || 'Unknown';

    let rawPublished = serial.publishedOn || serial.date || serial.published || serial.published_on || serial.publishedDate || serial.published_at;
    if (!rawPublished) {
      rawPublished = new Date().toISOString();
      serial.publishedOn = rawPublished;
      try { if (typeof saveSerials === 'function') saveSerials(); } catch (e) {}
    }
    const dateStr = formatDateVal(rawPublished);

    // Header (with genre div for share & comments buttons)
    const header = document.createElement('div');
    header.className = 'panel-top';
    header.innerHTML = `
      <div style="flex:1">
        <h1 style="margin:6px 0 4px 0">${esc(serial.title || 'Untitled')}</h1>
        <div class="panel-meta" style="margin-top:6px">Written by ${esc(author)} • Written on ${dateStr}</div>
        <div class="serial-genre" style="display:flex;align-items:center;gap:8px;font-size:14px;color:var(--muted);margin-top:6px">
          Genre: ${esc(serial.genre || '—')}
        </div>
        <div class="panel-meta" style="margin-top:6px">${esc(serial.description || '')}</div>
      </div>
    `;
    inner.appendChild(header);

    // SHARE + COMMENTS BUTTONS
    const genreDiv = header.querySelector('.serial-genre');
    if (genreDiv) {
      const shareBtn = document.createElement('button');
      shareBtn.className = 'share-btn';
      shareBtn.textContent = 'Share';
      genreDiv.appendChild(shareBtn);

      const commentsBtn = document.createElement('button');
      commentsBtn.className = 'comments-btn';
      commentsBtn.textContent = 'Comments';
      commentsBtn.style.marginLeft = '8px';
      genreDiv.appendChild(commentsBtn);

      if (!document.getElementById('share-ui-style')) {
        const style = document.createElement('style');
        style.id = 'share-ui-style';
        style.textContent = `
          .share-btn, .comments-btn {
            background: linear-gradient(135deg, #ff5f6d, #ffc371);
            border: none;
            color: white;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.25s ease;
            font-size: 14px;
          }
          .comments-btn { background: linear-gradient(135deg, #6ee7b7, #3b82f6); }
          .share-btn:hover, .comments-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
          }
          .share-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 8px;
            display: none;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
            box-shadow: 0 4px 14px rgba(0,0,0,0.15);
            z-index: 1200;
            animation: fadeIn 0.15s ease-out;
          }
          .share-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: none;
            border-radius: 8px;
            background: #f9f9f9;
            cursor: pointer;
            transition: all 0.15s ease;
            font-weight: 500;
          }
          .share-option:hover { background: #ffe9d6; }
          @keyframes fadeIn {
            from {opacity:0; transform:translateY(-5px);}
            to {opacity:1; transform:translateY(0);}
          }

          /* Comments panel */
          .comments-panel {
            position: fixed;
            inset: 0;
            background: rgba(255,255,255,0.98);
            z-index: 1300;
            display: flex;
            flex-direction: column;
            padding: 18px;
            gap: 12px;
            overflow: auto;
          }
          .comments-top {
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:12px;
            border-bottom: 1px solid #eee;
            padding-bottom: 12px;
          }
          .comments-title { font-size:18px; font-weight:700; display:flex; gap:12px; align-items:center; }
          .comments-count-badge {
            background:#f3f4f6; border-radius:999px; padding:6px 10px; font-weight:600;
          }
          .comments-list { display:flex; flex-direction:column; gap:12px; padding:12px 4px; max-width:900px; width:100%; margin:0 auto; }
          .comment-card {
            background:#fff; border:1px solid #eee; border-radius:12px; padding:12px; box-shadow:0 4px 12px rgba(0,0,0,0.03);
          }
          .comment-meta { display:flex; justify-content:space-between; gap:12px; align-items:center; margin-bottom:8px; color:#374151; font-weight:600; }
          .comment-text { color:#111827; white-space:pre-wrap; margin-bottom:8px; }
          .comment-actions { display:flex; gap:8px; align-items:center; font-size:13px; color:#374151; }
          .btn-action { background:transparent; border:none; cursor:pointer; padding:6px 8px; border-radius:8px; transition:background 0.12s; }
          .btn-action:hover { background:#f3f4f6; }
          .reply-list { margin-top:8px; display:flex; flex-direction:column; gap:8px; margin-left:12px; }
          .reply-card { background:#fafafa; border:1px solid #f0f0f0; padding:8px; border-radius:8px; }
          .comment-input-wrap {
            position: sticky; bottom:0; background:transparent; padding:12px 0; border-top:1px solid #eee; display:flex; justify-content:center;
          }
          .comment-input {
            display:flex; gap:px; align-items:center; width:100%; max-width:900px; background:#fff; border:1px solid #e5e7eb; border-radius:999px; padding:10px;
            box-shadow:0 6px 20px rgba(0,0,0,0.03);
          }
          .comment-input textarea { border:0; outline:0; resize:none; width:100%; padding:6px 8px; font-size:14px; }
          .comment-send { background:linear-gradient(90deg,#7c3aed,#06b6d4); color:#fff; border:none; padding:8px 14px; border-radius:999px; cursor:pointer; font-weight:700; }
          .small-muted { color:#6b7280; font-size:13px; }
          .reply-mode-indicator {
            display:flex; align-items:center; gap:8px; background:#fff8; border-radius:999px; padding:6px 10px; border:1px dashed #e5e7eb; margin-bottom:6px;
            max-width:900px; margin-left:auto; margin-right:auto;
          }
        `;
        document.head.appendChild(style);
      }

      const shareMenu = document.createElement('div');
      shareMenu.className = 'share-menu';
      document.body.appendChild(shareMenu);

      function getShareLink(platform) {
        const link = `https://meurbal.in?serial=${encodeURIComponent(serial.title)}`;
        const message = `Title: ${serial.title || 'Untitled'}\nGenre: ${serial.genre || '—'}\nDescription: ${serial.description || ''}\nRead here: ${link}`;
        if (platform === 'WhatsApp') return `https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`;
        if (platform === 'Facebook') return `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(link)}`;
        if (platform === 'Twitter') return `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
        return link;
      }

      const platforms = [
        { name: 'WhatsApp', emoji: '🟢' },
        { name: 'Facebook', emoji: '🔵' },
        { name: 'Twitter', emoji: '🐦' },
        { name: 'Copy Link', emoji: '🔗' }
      ];

      platforms.forEach(({ name, emoji }) => {
        const option = document.createElement('button');
        option.className = 'share-option';
        option.innerHTML = `${emoji} ${name}`;
        option.addEventListener('click', async () => {
          if (name === 'Copy Link') {
            const link = getShareLink();
            await navigator.clipboard.writeText(link);
            option.textContent = '✅ Link Copied!';
            setTimeout(() => (option.innerHTML = `${emoji} ${name}`), 1500);
          } else {
            const url = getShareLink(name);
            window.open(url, '_blank');
          }
          shareMenu.style.display = 'none';
        });
        shareMenu.appendChild(option);
      });

      shareBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = shareBtn.getBoundingClientRect();
        shareMenu.style.top = `${rect.bottom + window.scrollY + 6}px`;
        shareMenu.style.left = `${rect.left + window.scrollX}px`;
        shareMenu.style.display = shareMenu.style.display === 'flex' ? 'none' : 'flex';
      });

      document.addEventListener('click', (e) => {
        if (!shareMenu.contains(e.target) && e.target !== shareBtn) {
          shareMenu.style.display = 'none';
        }
      });

      // COMMENTS PANEL logic
      commentsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        openCommentsPanel();
      });

      function openCommentsPanel() {
        // create panel if not exists
        let cpanel = document.getElementById('serialCommentsFull');
        if (cpanel) cpanel.remove(); // recreate to ensure fresh state
        cpanel = document.createElement('div');
        cpanel.id = 'serialCommentsFull';
        cpanel.className = 'comments-panel';

        // top area: title + close + like count
        const top = document.createElement('div');
        top.className = 'comments-top';
        top.innerHTML = `
          <div style="display:flex;align-items:center;gap:12px">
            <div class="comments-title">
              <span style="font-size:20px">${esc(serial.title || 'Untitled')}</span>
              <span class="comments-count-badge" id="commentsCountBadge">${(commentsStore[commentsKey].comments || []).length} comments</span>
            </div>
            <div class="small-muted">Likes: <strong id="serialLikeBadge">${serial.likes}</strong></div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="closeCommentsBtn" class="share-btn" style="background:linear-gradient(90deg,#ef4444,#f97316)">Close</button>
          </div>
        `;
        cpanel.appendChild(top);

        // main list container
        const list = document.createElement('div');
        list.className = 'comments-list';
        list.id = 'commentsList';
        cpanel.appendChild(list);

        // bottom input area (sticky)
        const inputWrap = document.createElement('div');
        inputWrap.className = 'comment-input-wrap';
        inputWrap.innerHTML = `
          <div id="replyModeIndicatorWrap" style="display:none;"></div>
          <div class="comment-input">
            <textarea id="commentTextArea" placeholder="Add a public comment..." rows="2"></textarea>
            <button id="sendCommentBtn" class="comment-send">Send</button>
          </div>
        `;
        cpanel.appendChild(inputWrap);

        document.body.appendChild(cpanel);
        renderComments();

        document.getElementById('closeCommentsBtn').addEventListener('click', () => cpanel.remove());
        document.getElementById('sendCommentBtn').addEventListener('click', sendComment);
        document.getElementById('commentTextArea').addEventListener('keydown', function (e) {
          if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendComment(); }
        });
      }

      // helper: get current user name (from STORAGE_KEY) or "You"
      function getCurrentUserName() {
        try {
          const p = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
          if (p && p.name && p.name.trim()) return p.name.trim();
        } catch (e) { }
        return 'You';
      }

      function generateId() { return 'c_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1000).toString(36); }

      // Comments manipulation functions
      function loadCommentsObj() {
        const s = loadStore(COMMENTS_KEY);
        s[commentsKey] = s[commentsKey] || { comments: [] };
        return s;
      }
      function saveCommentsObj(obj) {
        saveStore(COMMENTS_KEY, obj);
      }

      function sendComment() {
        const ta = document.getElementById('commentTextArea');
        if (!ta) return;
        const text = ta.value.trim();
        if (!text) return;
        const user = getCurrentUserName();
        const commentsObj = loadCommentsObj();

        if (currentReplyTo) {
          // post as reply to currentReplyTo
          const c = (commentsObj[commentsKey].comments || []).find(x => x.id === currentReplyTo);
          if (!c) {
            // fallback to normal comment
            currentReplyTo = null;
          } else {
            const newReply = {
              id: generateId(),
              author: user,
              text: text,
              ts: Date.now(),
              likes: 0,
              dislikes: 0
            };
            c.replies = c.replies || [];
            c.replies.push(newReply);
            // ensure replies panel shows after adding
            expandedReplies.add(c.id);
            saveCommentsObj(commentsObj);
            ta.value = '';
            currentReplyTo = null;
            renderComments();
            updateReplyModeIndicator();
            return;
          }
        }

        // normal comment
        const newComment = {
          id: generateId(),
          author: user,
          text: text,
          ts: Date.now(),
          likes: 0,
          dislikes: 0,
          replies: []
        };
        commentsObj[commentsKey].comments.unshift(newComment); // newest first
        saveCommentsObj(commentsObj);
        ta.value = '';
        renderComments();
      }

      function updateReplyModeIndicator() {
        const wrap = document.getElementById('replyModeIndicatorWrap');
        if (!wrap) return;
        if (currentReplyTo) {
          const obj = loadCommentsObj();
          const c = (obj[commentsKey].comments || []).find(x => x.id === currentReplyTo);
          const name = c ? c.author : '';
          wrap.style.display = 'block';
          wrap.innerHTML = `<div class="reply-mode-indicator">Replying to <strong>${esc(name)}</strong>
            <button id="cancelReplyMode" class="btn-action" style="margin-left:8px">Cancel</button></div>`;
          document.getElementById('cancelReplyMode').addEventListener('click', () => {
            currentReplyTo = null;
            updateReplyModeIndicator();
            document.getElementById('commentTextArea').focus();
          });
        } else {
          wrap.style.display = 'none';
          wrap.innerHTML = '';
        }
      }

      function renderComments() {
        const list = document.getElementById('commentsList');
        if (!list) return;
        list.innerHTML = '';
        const commentsObj = loadCommentsObj();
        const commentsArr = commentsObj[commentsKey].comments || [];
        const badge = document.getElementById('commentsCountBadge');
        if (badge) badge.textContent = `${commentsArr.length} comments`;
        const likeBadge = document.getElementById('serialLikeBadge');
        if (likeBadge) likeBadge.textContent = serial.likes;

        commentsArr.forEach(comment => {
          const card = document.createElement('div');
          card.className = 'comment-card';
          card.dataset.cid = comment.id;

          const meta = document.createElement('div');
          meta.className = 'comment-meta';

          // left: author + timestamp
          const left = document.createElement('div');
          left.innerHTML = `${esc(comment.author)} <span class="small-muted" style="font-weight:500;margin-left:8px">${new Date(comment.ts).toLocaleString()}</span>`;

          // right: delete only if same author
          const right = document.createElement('div');

          if (comment.author === getCurrentUserName()) {
            const delBtn = document.createElement('button');
            delBtn.className = 'btn-action delete-comment';
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', () => {
              if (!confirm('Delete this comment?')) return;
              deleteComment(comment.id);
            });
            right.appendChild(delBtn);
          }

          meta.appendChild(left);
          meta.appendChild(right);
          card.appendChild(meta);

          const text = document.createElement('div');
          text.className = 'comment-text';
          text.innerHTML = esc(comment.text);
          card.appendChild(text);

          const actions = document.createElement('div');
          actions.className = 'comment-actions';
          // reply toggle text shows replies count and toggles visibility
          const repliesCount = (comment.replies || []).length;
          actions.innerHTML = `
            <button class="btn-action like-comment">👍 <span class="cnt">${comment.likes || 0}</span></button>
            <button class="btn-action dislike-comment">👎 <span class="cnt">${comment.dislikes || 0}</span></button>
            <button class="btn-action reply-open">Reply</button>
            <button class="btn-action replies-toggle">Replies (${repliesCount})</button>
          `;
          card.appendChild(actions);

          // reply list (hidden by default)
          const replyList = document.createElement('div');
          replyList.className = 'reply-list';
          replyList.style.display = expandedReplies.has(comment.id) ? 'flex' : 'none';

          (comment.replies || []).forEach(reply => {
            const r = document.createElement('div');
            r.className = 'reply-card';
            r.dataset.rid = reply.id;
            r.innerHTML = `
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div style="font-weight:600">${esc(reply.author)} <span class="small-muted" style="font-weight:500;margin-left:8px">${new Date(reply.ts).toLocaleString()}</span></div>
                <div></div>
              </div>
              <div style="margin-top:6px">${esc(reply.text)}</div>
              <div style="margin-top:8px;display:flex;gap:8px">
                <button class="btn-action like-reply">👍 <span class="cnt">${reply.likes || 0}</span></button>
                <button class="btn-action dislike-reply">👎 <span class="cnt">${reply.dislikes || 0}</span></button>
              </div>
            `;
            // delete reply only visible to reply author
            const rightContainer = r.querySelector('div > div:last-child');
            if (reply.author === getCurrentUserName()) {
              const delR = document.createElement('button');
              delR.className = 'btn-action delete-reply';
              delR.textContent = 'Delete';
              delR.addEventListener('click', () => {
                if (!confirm('Delete this reply?')) return;
                deleteReply(comment.id, reply.id);
              });
              // append delete to the top-right container
              r.querySelector('div').querySelector('div').appendChild(delR);
            }

            // attach reply-level like/dislike
            r.querySelector('.like-reply').addEventListener('click', () => toggleReplyVote(comment.id, reply.id, 'like'));
            r.querySelector('.dislike-reply').addEventListener('click', () => toggleReplyVote(comment.id, reply.id, 'dislike'));

            replyList.appendChild(r);
          });

          card.appendChild(replyList);

          // attach comment-level handlers
          actions.querySelector('.like-comment').addEventListener('click', () => toggleCommentVote(comment.id, 'like'));
          actions.querySelector('.dislike-comment').addEventListener('click', () => toggleCommentVote(comment.id, 'dislike'));

          // Reply button: set the bottom bar to reply mode for this comment
          actions.querySelector('.reply-open').addEventListener('click', () => {
            currentReplyTo = comment.id;
            updateReplyModeIndicator();
            const ta = document.getElementById('commentTextArea');
            if (ta) {
              ta.focus();
              // prefill with @author optionally (but keep typed text separate)
              // ta.value = `@${comment.author} `;
            }
          });

          // Replies toggle: show/hide replies for this comment
          actions.querySelector('.replies-toggle').addEventListener('click', () => {
            if (expandedReplies.has(comment.id)) expandedReplies.delete(comment.id);
            else expandedReplies.add(comment.id);
            renderComments();
          });

          list.appendChild(card);
        });

        updateReplyModeIndicator();
      }

      function toggleCommentVote(commentId, mode) {
        const obj = loadCommentsObj();
        const comments = obj[commentsKey].comments || [];
        const c = comments.find(x => x.id === commentId);
        if (!c) return;
        if (mode === 'like') {
          c.likes = (c.likes || 0) + 1;
        } else {
          c.dislikes = (c.dislikes || 0) + 1;
        }
        saveCommentsObj(obj);
        renderComments();
      }

      function toggleReplyVote(commentId, replyId, mode) {
        const obj = loadCommentsObj();
        const comments = obj[commentsKey].comments || [];
        const c = comments.find(x => x.id === commentId);
        if (!c) return;
        const r = (c.replies || []).find(rr => rr.id === replyId);
        if (!r) return;
        if (mode === 'like') r.likes = (r.likes || 0) + 1;
        else r.dislikes = (r.dislikes || 0) + 1;
        saveCommentsObj(obj);
        renderComments();
      }

      function deleteComment(commentId) {
        const obj = loadCommentsObj();
        obj[commentsKey].comments = (obj[commentsKey].comments || []).filter(c => c.id !== commentId);
        saveCommentsObj(obj);
        // remove from expandedReplies set
        expandedReplies.delete(commentId);
        renderComments();
      }

      function deleteReply(commentId, replyId) {
        const obj = loadCommentsObj();
        const c = (obj[commentsKey].comments || []).find(x => x.id === commentId);
        if (!c) return;
        c.replies = (c.replies || []).filter(r => r.id !== replyId);
        saveCommentsObj(obj);
        renderComments();
      }

      // end of genreDiv handling
    } // end if genreDiv

    // CONTROL WRAPPER (close + likes/dislikes + reads)
    // --- CONTROL WRAPPER (close + likes/dislikes + reads) ---
    // NOTE: removed the separate "countDisplay" element to avoid duplication.
    // Like/dislike counts are shown inside the buttons (.cnt spans).
    const controlWrapper = document.createElement('div');
    controlWrapper.style.display = 'flex';
    controlWrapper.style.alignItems = 'center';
    controlWrapper.style.gap = '12px';
    controlWrapper.style.margin = '12px 0';

    const closeBtn = document.createElement('button');
    closeBtn.className = 'jelly-btn';
    closeBtn.id = 'closeSerialPreviewBtn';
    closeBtn.textContent = 'Close';
    controlWrapper.appendChild(closeBtn);

    const likeBtn = document.createElement('button');
    likeBtn.className = 'jelly-btn';
    likeBtn.innerHTML = '👍 <span class="cnt">0</span>';
    likeBtn.dataset.state = 'none';
    controlWrapper.appendChild(likeBtn);

    const dislikeBtn = document.createElement('button');
    dislikeBtn.className = 'jelly-btn dislike-btn';
    dislikeBtn.innerHTML = '👎 <span class="cnt">0</span>';
    dislikeBtn.dataset.state = 'none';
    controlWrapper.appendChild(dislikeBtn);

    // --- keep reads display as single label ---
    // remove any existing duplicate reads element (safe-guard)
    const existingReadEl = document.getElementById('readCountDisplay');
    if (existingReadEl) existingReadEl.remove();

    inner.appendChild(controlWrapper);

    // --- refreshUI (update only button counts and reads) ---
    function refreshUI() {
      serial.likes = Math.max(0, Number(serial.likes || 0));
      serial.dislikes = Math.max(0, Number(serial.dislikes || 0));

      // update counts inside the buttons
      const likeCnt = likeBtn.querySelector('.cnt');
      const dislikeCnt = dislikeBtn.querySelector('.cnt');
      if (likeCnt) likeCnt.textContent = serial.likes;
      if (dislikeCnt) dislikeCnt.textContent = serial.dislikes;

      // update button visual states
      const userChoice = (loadStore(USER_VOTES_KEY)[voteKey]) || 'none';
      likeBtn.dataset.state = (userChoice === 'liked') ? 'liked' : 'none';
      dislikeBtn.dataset.state = (userChoice === 'disliked') ? 'disliked' : 'none';
      likeBtn.style.backgroundColor = likeBtn.dataset.state === 'liked' ? '#dbeafe' : '';
      dislikeBtn.style.backgroundColor = dislikeBtn.dataset.state === 'disliked' ? '#fee2e2' : '';

      // update reads
      const readsNow = (loadStore(READS_KEY)[readKey] || { total: 0 }).total;
      const rDisplay = document.getElementById('readCountDisplay');
      if (rDisplay) rDisplay.textContent = `Reads = ${readsNow}`;

      // update comments count badge if open
      const badge = document.getElementById('commentsCountBadge');
      const commentsObj = loadStore(COMMENTS_KEY);
      if (badge && commentsObj[commentsKey]) badge.textContent = `${(commentsObj[commentsKey].comments || []).length} comments`;
    }

    function incrementReadCount(epIndex) {
      const reads = loadStore(READS_KEY);
      reads[readKey] = reads[readKey] || { total: 0, episodes: {} };
      reads[readKey].total++;
      reads[readKey].episodes[epIndex] = (reads[readKey].episodes[epIndex] || 0) + 1;
      saveStore(READS_KEY, reads);
      refreshUI();
    }

    function updateUserVote(newChoice) {
      const votes = loadStore(VOTES_STORE_KEY);
      const user = loadStore(USER_VOTES_KEY);
      votes[voteKey] = votes[voteKey] || { likes: 0, dislikes: 0 };
      const prev = user[voteKey] || 'none';

      if (prev === 'liked') votes[voteKey].likes = Math.max(0, (votes[voteKey].likes || 1) - 1);
      if (prev === 'disliked') votes[voteKey].dislikes = Math.max(0, (votes[voteKey].dislikes || 1) - 1);

      if (newChoice === 'liked') votes[voteKey].likes = (votes[voteKey].likes || 0) + 1;
      if (newChoice === 'disliked') votes[voteKey].dislikes = (votes[voteKey].dislikes || 0) + 1;

      user[voteKey] = (newChoice === 'none') ? 'none' : newChoice;

      saveStore(VOTES_STORE_KEY, votes);
      saveStore(USER_VOTES_KEY, user);

      serial.likes = votes[voteKey].likes;
      serial.dislikes = votes[voteKey].dislikes;
      refreshUI();
      try { if (typeof saveSerials === 'function') saveSerials(); } catch (e) { }
    }

    likeBtn.addEventListener('click', function () {
      const current = likeBtn.dataset.state === 'liked' ? 'liked' : (dislikeBtn.dataset.state === 'disliked' ? 'disliked' : 'none');
      if (current === 'liked') updateUserVote('none');
      else updateUserVote('liked');
    });

    dislikeBtn.addEventListener('click', function () {
      const current = dislikeBtn.dataset.state === 'disliked' ? 'disliked' : (likeBtn.dataset.state === 'liked' ? 'liked' : 'none');
      if (current === 'disliked') updateUserVote('none');
      else updateUserVote('disliked');
    });

    const epsWrap = document.createElement('div');
    epsWrap.style.display = 'flex';
    epsWrap.style.flexDirection = 'column';
    epsWrap.style.gap = '10px';

    (serial.episodes || []).forEach((ep, i) => {
      const epCard = document.createElement('div');
      epCard.className = 'story-card';
      epCard.style.display = 'flex';
      epCard.style.justifyContent = 'space-between';
      epCard.style.alignItems = 'center';
      epCard.innerHTML = `
        <div style="max-width:72%">
          <strong>${i + 1}. ${(ep.title || ('Episode ' + (i + 1))).replace(/</g, '&lt;')}</strong>
          <div style="font-size:13px;color:var(--muted)">${(ep.description || '').replace(/</g, '&lt;')}</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn btn-primary read-episode-btn">Read Episode</button>
        </div>
      `;
      epCard.querySelector('.read-episode-btn').addEventListener('click', () => {
        incrementReadCount(i);
        openSerialReader(serial.title, i);
      });
      epsWrap.appendChild(epCard);
    });

    inner.appendChild(epsWrap);
    panel.appendChild(inner);

    closeBtn.addEventListener('click', () => panel.remove());

    refreshUI();
    window.scrollTo(0, 0);

  } catch (err) {
    console.error('openSerialPreview error', err);
    alert('Something went wrong opening preview — check console for details.');
  }
}


// Open dedicated fullscreen reader for a serial episode (separate page div)
function openSerialReader(serialTitle, episodeIndex) {
    const saved = loadSavedSerials();
    const serial = (saved || []).find(s => s.title === serialTitle) || (serialsData || []).find(s => s.title === serialTitle);
    if (!serial) { alert('Serial not found'); return; }
    const ep = (serial.episodes || [])[episodeIndex];
    if (!ep) { alert('Episode not found'); return; }

    // --- CREATE PANEL ---
    let panel = document.getElementById('serialReaderFull');
    if (!panel) {
        panel = document.createElement('div');
        panel.id = 'serialReaderFull';
        panel.className = 'reader-full';
        panel.style.position = 'fixed';
        panel.style.top = '0';
        panel.style.left = '0';
        panel.style.width = '100vw';
        panel.style.height = '100vh';
        panel.style.zIndex = '1200';
        panel.style.background = '#f7f7fb';
        panel.style.display = 'flex';
        panel.style.flexDirection = 'column';
        panel.style.overflow = 'hidden';
        document.body.appendChild(panel);
    }
    panel.innerHTML = '';

    // --- HEADER ---
    const header = document.createElement('div');
    header.className = 'reader-header';
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    header.style.flexShrink = '0';
    header.style.padding = '12px 18px';
    header.style.background = '#fff';
    header.innerHTML = `
        <div><button class="btn btn-secondary" id="backToSerialBtn">← Back</button></div>
        <div style="text-align:center;flex:1">
            <h2 style="margin:6px 0;font-size:16px">${serial.title} — ${ep.title}</h2>
            <div class="muted" style="font-size:12px">${serial.genre || '—'} • ${ep.description || ''}</div>
        </div>
        <div style="width:120px;visibility:hidden"></div>
    `;

    // --- BODY ---
    const body = document.createElement('div');
    body.className = 'reader-body';
    body.style.flex = '1';
    body.style.overflowY = 'auto';
    body.style.padding = '12px';
    body.style.display = 'flex';
    body.style.flexDirection = 'column';
    body.style.alignItems = 'center';
    body.style.justifyContent = 'flex-start';

    const sheetsArray = (ep.sheets || []).map(s => (typeof s === 'string') ? { content: s } : (s.content ? s : { content: s }));
    const totalPages = Math.max(1, sheetsArray.length || 1);
    let currentPage = 0;

    // --- PAGE WRAP & BOX ---
    const pageWrap = document.createElement('div');
    pageWrap.style.display = 'flex';
    pageWrap.style.flexDirection = 'column';
    pageWrap.style.alignItems = 'center';
    pageWrap.style.width = '100%';
    pageWrap.style.boxSizing = 'border-box';

    const pageBox = document.createElement('div');
    pageBox.className = 'reader-sheet';
    pageBox.style.width = '100%';
    pageBox.style.maxWidth = '880px';
    pageBox.style.minHeight = '540px';
    pageBox.style.margin = '20px auto';
    pageBox.style.padding = '30px 35px';
    pageBox.style.background = 'linear-gradient(135deg, #fffef9 0%, #fdf8e4 100%)';
    pageBox.style.border = '1px solid #e5d7b7';
    pageBox.style.borderRadius = '12px';
    pageBox.style.boxShadow = '0 8px 16px rgba(0,0,0,0.1)';
    pageBox.style.boxSizing = 'border-box';
    pageBox.style.fontFamily = `'Georgia', 'Times New Roman', serif`;
    pageBox.style.fontSize = '16px';
    pageBox.style.lineHeight = '1.7';
    pageBox.style.color = '#2e2b23';
    pageBox.style.textAlign = 'justify';
    pageBox.style.letterSpacing = '0.3px';
    pageBox.style.whiteSpace = 'pre-wrap';
    pageBox.style.overflowWrap = 'break-word';
    pageBox.style.position = 'relative';
    pageBox.style.transition = 'all 0.3s ease';

    // --- PAGER ROW ---
    const pagerRow = document.createElement('div');
    pagerRow.style.display = 'flex';
    pagerRow.style.flexWrap = 'wrap';
    pagerRow.style.alignItems = 'center';
    pagerRow.style.justifyContent = 'center';
    pagerRow.style.gap = '6px';
    pagerRow.style.marginTop = '12px';

    const prevPageBtn = document.createElement('button');
    prevPageBtn.className = 'btn btn-secondary';
    prevPageBtn.textContent = '◀ Prev Page';

    const pageIndicator = document.createElement('div');
    pageIndicator.className = 'muted';
    pageIndicator.style.minWidth = '80px';
    pageIndicator.style.textAlign = 'center';
    pageIndicator.style.fontSize = '14px';

    const nextPageBtn = document.createElement('button');
    nextPageBtn.className = 'btn btn-primary';
    nextPageBtn.textContent = 'Next Page ▶';

    const markLastReadBtn = document.createElement('button');
    markLastReadBtn.className = 'btn btn-warning';
    markLastReadBtn.textContent = 'Mark Last Read';

    const completeMarkBtn = document.createElement('button');
    completeMarkBtn.className = 'btn btn-success';
    completeMarkBtn.textContent = 'Complete Mark';
    completeMarkBtn.style.display = 'none';

    const removeMarkBtn = document.createElement('button');
    removeMarkBtn.className = 'btn btn-danger';
    removeMarkBtn.textContent = 'Remove Last Mark';
    removeMarkBtn.style.display = 'inline-block';

    // --- SMALL BUTTON STYLE ---
    function styleButton(btn) {
        btn.style.padding = '6px 10px';
        btn.style.fontSize = '14px';
        btn.style.borderRadius = '6px';
        btn.style.minWidth = 'auto';
    }
    [prevPageBtn, nextPageBtn, markLastReadBtn, completeMarkBtn, removeMarkBtn].forEach(styleButton);

    pagerRow.append(prevPageBtn, pageIndicator, nextPageBtn, markLastReadBtn, completeMarkBtn, removeMarkBtn);
    pageWrap.append(pageBox, pagerRow);
    body.appendChild(pageWrap);

    // --- DRAWING CANVAS ---
    const marksPerPage = {};
    let drawCanvas = null;
    let drawContext = null;

    function enableDrawing(canvas, context) {
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // Desktop
        canvas.addEventListener('mousedown', e => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        });
        canvas.addEventListener('mousemove', e => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(x, y);
            context.stroke();
            lastX = x;
            lastY = y;
        });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        // Mobile / Touch
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.touches[0].clientX - rect.left;
            lastY = e.touches[0].clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            const y = e.touches[0].clientY - rect.top;
            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(x, y);
            context.stroke();
            lastX = x;
            lastY = y;
        }, { passive: false });

        canvas.addEventListener('touchend', () => isDrawing = false);
        canvas.addEventListener('touchcancel', () => isDrawing = false);
    }

    markLastReadBtn.addEventListener('click', () => {
        if (!drawCanvas) {
            drawCanvas = document.createElement('canvas');
            drawCanvas.style.position = 'absolute';
            drawCanvas.style.top = '0';
            drawCanvas.style.left = '0';
            drawCanvas.style.width = '100%';
            drawCanvas.style.height = '100%';
            drawCanvas.width = pageBox.clientWidth;
            drawCanvas.height = pageBox.clientHeight;
            drawCanvas.style.zIndex = 5;
            drawCanvas.style.pointerEvents = 'auto';
            drawCanvas.style.cursor = 'crosshair';
            pageBox.appendChild(drawCanvas);

            drawContext = drawCanvas.getContext('2d');
            drawContext.strokeStyle = 'rgba(0,0,0,0.7)';
            drawContext.lineWidth = 2;

            // Restore previous marks
            if (marksPerPage[currentPage]) {
                const img = new Image();
                img.onload = () => drawContext.drawImage(img, 0, 0, drawCanvas.width, drawCanvas.height);
                img.src = marksPerPage[currentPage];
            }

            enableDrawing(drawCanvas, drawContext);
        }
        completeMarkBtn.style.display = 'inline-block';
    });

    completeMarkBtn.addEventListener('click', () => {
        if (drawCanvas) {
            marksPerPage[currentPage] = drawCanvas.toDataURL();
            drawCanvas.style.pointerEvents = 'none';
        }
        completeMarkBtn.style.display = 'none';
    });

    removeMarkBtn.addEventListener('click', () => {
        if (drawCanvas) {
            drawCanvas.remove();
            drawCanvas = null;
            drawContext = null;
        }
        delete marksPerPage[currentPage];
        completeMarkBtn.style.display = 'none';
    });

    // --- RENDER PAGE FUNCTION ---
    function renderPage(idx) {
        currentPage = Math.max(0, Math.min(idx, totalPages - 1));
        const sheetObj = sheetsArray[currentPage] || { content: '(No content in this page)' };

        if (typeof sheetObj.content === 'string' && /<[a-z][\s\S]*>/i.test(sheetObj.content)) {
            pageBox.innerHTML = sheetObj.content;
        } else {
            pageBox.textContent = sheetObj.content || '(No content in this page)';
        }

        pageIndicator.textContent = `Page ${currentPage + 1} / ${totalPages}`;
        prevPageBtn.disabled = currentPage === 0;
        nextPageBtn.disabled = currentPage === totalPages - 1;

        if (drawCanvas) {
            drawCanvas.remove();
            drawCanvas = null;
            drawContext = null;
            completeMarkBtn.style.display = 'none';
            removeMarkBtn.style.display = 'none';
        }

        if (marksPerPage[currentPage] && !drawCanvas) {
            drawCanvas = document.createElement('canvas');
            drawCanvas.style.position = 'absolute';
            drawCanvas.style.top = 0;
            drawCanvas.style.left = 0;
            drawCanvas.style.width = '100%';
            drawCanvas.style.height = '100%';
            drawCanvas.width = pageBox.clientWidth;
            drawCanvas.height = pageBox.clientHeight;
            drawCanvas.style.zIndex = 5;
            drawCanvas.style.pointerEvents = 'none';
            pageBox.appendChild(drawCanvas);
            drawContext = drawCanvas.getContext('2d');
            const img = new Image();
            img.onload = () => drawContext.drawImage(img, 0, 0, drawCanvas.width, drawCanvas.height);
            img.src = marksPerPage[currentPage];
        }
    }

    prevPageBtn.addEventListener('click', () => renderPage(currentPage - 1));
    nextPageBtn.addEventListener('click', () => renderPage(currentPage + 1));
    if (sheetsArray.length === 0) sheetsArray.push({ content: '(No content in this episode yet)' });
    renderPage(0);

    // --- FOOTER ---
    const footer = document.createElement('div');
    footer.style.display = 'flex';
    footer.style.justifyContent = 'center';
    footer.style.flexWrap = 'wrap';
    footer.style.gap = '6px';
    footer.style.padding = '12px';
    footer.style.flexShrink = 0;
    footer.style.background = '#fff';

    const prevBtn = document.createElement('button');
    prevBtn.className = 'btn btn-secondary';
    prevBtn.textContent = '◀ Prev Episode';

    const nextBtn = document.createElement('button');
    nextBtn.className = 'btn btn-primary';
    nextBtn.textContent = 'Next Episode ▶';

    [prevBtn, nextBtn].forEach(styleButton);

    footer.append(prevBtn, nextBtn);
    panel.append(header, body, footer);

    document.getElementById('backToSerialBtn').addEventListener('click', () => {
        panel.remove();
        openSerialPreview(serialTitle);
    });

    prevBtn.addEventListener('click', () => {
        if (episodeIndex > 0) openSerialReader(serialTitle, episodeIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
        if (episodeIndex < (serial.episodes || []).length - 1) openSerialReader(serialTitle, episodeIndex + 1);
    });

    window.scrollTo(0, 0);
}

// --- DOMContentLoaded Hook --- document.addEventListener('DOMContentLoaded', ()=>{ const browseSerialsBtn = document.getElementById('browseSerialsBtn'); if(browseSerialsBtn){ browseSerialsBtn.addEventListener('click', ()=>{ const welcomePage = document.getElementById('welcomePage'); if(welcomePage) welcomePage.classList.add('hidden'); const serialPage = document.getElementById('serialCategoriesPage'); if(serialPage) serialPage.classList.remove('hidden'); renderBrowseSerials(loadSavedSerials()); }); } if(document.getElementById('serialCategoriesPage') && !document.getElementById('serialsBrowseList')){ renderBrowseSerials(loadSavedSerials()); } }); // --- Optional: Sync serialsData push --- (function(){ try{ if(Array.prototype._origSerialPush == null){ Array.prototype._origSerialPush = Array.prototype.push; } if(window.serialsData && window.serialsData.push){ const orig = window.serialsData.push; window.serialsData.push = function(){ const res = orig.apply(this, arguments); try{ syncSerialsToStorage(); }catch(e){} return res; }; } }catch(e){} })();
// --- Optional: Sync serialsData push ---
(function(){
  try{
    if(Array.prototype._origSerialPush == null){
      Array.prototype._origSerialPush = Array.prototype.push;
    }
    if(window.serialsData && window.serialsData.push){
      const orig = window.serialsData.push;
      window.serialsData.push = function(){
        const res = orig.apply(this, arguments);
        try{ syncSerialsToStorage(); }catch(e){}
        return res;
      };
    }
  }catch(e){}
})();

// Also call sync after some known buttons if they exist
setTimeout(()=>{
  if(window.serialCreateConfirmBtn){
    serialCreateConfirmBtn.addEventListener('click', ()=> setTimeout(syncSerialsToStorage, 500) );
  }
  if(window.addEpConfirmBtn){
    addEpConfirmBtn.addEventListener('click', ()=> setTimeout(syncSerialsToStorage, 500) );
  }
}, 800);

</script>
<!-- END: SERIALS EXTENSION INJECTION -->

<!-- START: Auto-Injected Serial READs & Download Augmentation -->
<script>
(function(){
  // Helper: stable key for serial (using title)
  function serialKey(title) {
    return 'serial_reads_' + (title || 'unknown').replace(/\s+/g,'_').toLowerCase();
  }

  // Persisted storage helpers
  function loadCounts(key) {
    try {
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : {};
    } catch(e){ return {}; }
  }
  function saveCounts(key, obj) {
    try { localStorage.setItem(key, JSON.stringify(obj)); } catch(e){}
  }

  // Download helper
  function downloadJSON(filename, obj) {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(obj, null, 2));
    const a = document.createElement('a');
    a.setAttribute('href', dataStr);
    a.setAttribute('download', filename);
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Try to detect serial preview containers added to DOM.
  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      for (const node of m.addedNodes) {
        if (!(node instanceof HTMLElement)) continue;
        // Detect likely serial preview by common heuristics: header with <h1>, description, and multiple episode cards/lists.
        const h1 = node.querySelector && (node.querySelector('h1') || node.querySelector('.serial-title') || node.querySelector('.title'));
        const episodes = node.querySelectorAll && (node.querySelectorAll('.episode, .ep, .story-card, .episode-card, .ep-card') || []);
        // episodes NodeList may be empty; we will further search inside for lists
        const potentialEpisodeItems = node.querySelectorAll('li, .episode, .story-card, .episode-card, .ep-card');
        const epCount = potentialEpisodeItems.length;
        if (h1 && (epCount > 0 || node.querySelectorAll('.episode').length>0)) {
          enhanceSerialPreview(node);
        } else {
          // Some previews might use a wrapper with class 'serial-preview' or id 'serialPreview'
          if (node.matches && (node.matches('.serial-preview') || node.id === 'serialPreview')) {
            enhanceSerialPreview(node);
          }
        }
      }
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });

  // Also attempt to enhance already-present preview on page load (in case it exists)
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const previews = document.querySelectorAll('.serial-preview, [data-serial-preview], #serialPreview');
      if (previews.length) previews.forEach(enhanceSerialPreview);
      // Fallback: find containers with h1 and multiple story-card children
      const nodes = Array.from(document.querySelectorAll('div, section'));
      for (const n of nodes) {
        const h1 = n.querySelector && (n.querySelector('h1') || n.querySelector('.serial-title'));
        const items = n.querySelectorAll && n.querySelectorAll('.story-card, .episode, li').length;
        if (h1 && items>0) enhanceSerialPreview(n);
      }
    }, 500);
  });

  // Main enhancer function
  function enhanceSerialPreview(container){
    try {
      // Avoid double-enhancing
      if (container.__readsEnhanced) return;
      container.__readsEnhanced = true;

      // Locate serial title, genre, description
      const titleEl = container.querySelector('h1') || container.querySelector('.serial-title') || container.querySelector('.title');
      const title = titleEl ? titleEl.textContent.trim() : 'untitled_serial';
      const key = serialKey(title);

      // Find or create the READ total label under header
      let readsLabel = container.querySelector('#serialReadsLabel');
      if (!readsLabel) {
        readsLabel = document.createElement('div');
        readsLabel.id = 'serialReadsLabel';
        readsLabel.style.fontWeight = '700';
        readsLabel.style.marginTop = '8px';
        // Prefer to insert after the title or after a header block
        if (titleEl && titleEl.parentElement) {
          titleEl.parentElement.appendChild(readsLabel);
        } else {
          container.insertBefore(readsLabel, container.firstChild);
        }
      }


      // Load counts from storage
      const counts = loadCounts(key);

      // Identify episode elements (best-effort)
      let episodeEls = Array.from(container.querySelectorAll('.episode, .episode-card, .ep-card, .story-card, li'));
      // Filter out container-level lists that are not episodes by checking for a 'Read' button inside or 'Start Reading' text
      episodeEls = episodeEls.filter(el => {
        const txt = (el.textContent||'').toLowerCase();
        const hasReadBtn = !!el.querySelector('button, a');
        return txt.length<10000 && (hasReadBtn || txt.includes('episode') || txt.includes('start reading') || txt.includes('read'));
      });

      // If nothing found, try direct children
      if (episodeEls.length === 0) {
        const list = container.querySelectorAll('ul > li, ol > li');
        episodeEls = Array.from(list);
      }

      // Add per-episode UI
      episodeEls.forEach((epEl, idx) => {
        // Avoid double-insert
        if (epEl.querySelector('.read-count-badge')) return;

        // Determine an episode title
        const epTitleEl = epEl.querySelector('h3, h4, .ep-title, .title') || epEl.querySelector('strong') || epEl;
        const epTitle = epTitleEl ? (epTitleEl.textContent || '').trim().substring(0,120) : ('Episode ' + (idx+1));

        // Ensure reads value exists
        if (typeof counts[idx] !== 'number') counts[idx] = counts[idx] || 0;

        // Create read badge
        const badge = document.createElement('span');
        badge.className = 'read-count-badge';
        badge.style.marginLeft = '8px';
        badge.style.fontWeight = '700';
        badge.style.fontSize = '13px';
        badge.textContent = 'Reads = ' + (counts[idx]||0);

        // Append badge near title or at the end
        if (epTitleEl && epTitleEl.parentElement) {
          epTitleEl.parentElement.appendChild(badge);
        } else {
          epEl.appendChild(badge);
        }

        // Wire the episode's "Read" or "Start Reading" button to increment the count
        // Search for button-like elements
        const candidateBtns = Array.from(epEl.querySelectorAll('button, a'));
        let readBtn = candidateBtns.find(b => /read|start reading|open/i.test((b.textContent||'')));
        if (!readBtn && candidateBtns.length) readBtn = candidateBtns[0];

        if (readBtn) {
          readBtn.addEventListener('click', (ev) => {
            // Increment count and save
            counts[idx] = (counts[idx] || 0) + 1;
            saveCounts(key, counts);
            // Update badge and total label
            badge.textContent = 'READ = ' + counts[idx];
            updateTotalLabel(container, counts);
            // allow other handlers to run
            setTimeout(()=>{},0);
          });
        }
      });

      // Save counts back (initial)
      saveCounts(key, counts);
      updateTotalLabel(container, counts);
    } catch(e){
      console.error('enhanceSerialPreview error', e);
    }
  }

  function updateTotalLabel(container, counts) {
    const total = (Array.isArray(counts) ? counts.reduce((a,b)=>a+(b||0),0) : Object.values(counts).reduce((a,b)=>a+(b||0),0));
    let lbl = container.querySelector('#serialReadsLabel');
    if (!lbl) {
      lbl = document.createElement('div');
      lbl.id = 'serialReadsLabel';
      lbl.style.fontWeight = '700';
      lbl.style.marginTop = '8px';
      if (container.querySelector('h1')) container.querySelector('h1').parentElement.appendChild(lbl);
      else container.appendChild(lbl);
    }
    lbl.textContent = 'Reads = ' + total;
  }

  // Build a best-effort serial JSON from the DOM preview (title, genre, description, episodes text)
  function buildSerialJSON(container) {
    const title = (container.querySelector('h1') || container.querySelector('.serial-title') || {textContent:'Untitled'}).textContent.trim();
    const genre = (container.querySelector('.genre') || container.querySelector('[data-genre]') || {textContent:''}).textContent.trim();
    const desc = (container.querySelector('.description') || container.querySelector('.serial-description') || {textContent:''}).textContent.trim();
    const episodes = [];
    const episodeEls = Array.from(container.querySelectorAll('.episode, .episode-card, .story-card, li'));
    episodeEls.forEach((el, idx) => {
      const epTitle = (el.querySelector('h3, h4, .ep-title') || el.querySelector('strong') || {textContent:('Episode '+(idx+1))}).textContent.trim();
      const body = (el.querySelector('.body, p') || el).textContent.trim();
      // load counts
      const key = 'serial_reads_' + title.replace(/\s+/g,'_').toLowerCase();
      let counts = {};
      try { counts = JSON.parse(localStorage.getItem(key) || '{}'); } catch(e){}
      const reads = counts[idx] || 0;
      episodes.push({ title: epTitle, body: body, reads: reads });
    });
    return { title, genre, description: desc, episodes };
  }

    })();

  // Additional UI tweaks:
  // 1) If both Close and Download buttons exist in a preview, swap their positions so Close is where Download was and vice versa.
  function swapPreviewButtons(container) {
    try {
      const closeBtn = container.querySelector('#closeSerialPreviewBtn') || Array.from(container.querySelectorAll('button')).find(b => /close/i.test(b.textContent||''));
      const downloadBtn = container.querySelector('#downloadSerialBtn') || Array.from(container.querySelectorAll('button')).find(b => /download serial/i.test(b.textContent||''));
      if (closeBtn && downloadBtn && closeBtn.parentElement && downloadBtn.parentElement) {
        const closeParent = closeBtn.parentElement;
        const downloadParent = downloadBtn.parentElement;
        // Swap by replacing nodes
        const closeClone = closeBtn.cloneNode(true);
        const downloadClone = downloadBtn.cloneNode(true);
        closeClone.id = closeBtn.id || 'closeSerialPreviewBtn_clone';
        downloadClone.id = downloadBtn.id || 'downloadSerialBtn_clone';
        // replace
        closeParent.replaceChild(downloadClone, closeBtn);
        downloadParent.replaceChild(closeClone, downloadBtn);
        // reattach listeners if any by clicking behaviors (best-effort: forward click to original behavior)
        downloadClone.addEventListener('click', function(e){ downloadBtn.click && downloadBtn.click(); });
        closeClone.addEventListener('click', function(e){ closeBtn.click && closeBtn.click(); });
      }
    } catch(e){console.warn('swapPreviewButtons failed', e);}
  }

 
  // Run these helpers when new previews are detected and on DOMContentLoaded
  const extraObserver = new MutationObserver(muts => {
    muts.forEach(m => {
      m.addedNodes.forEach(n => {
        if (!(n instanceof HTMLElement)) return;
        // If a preview or header added, attempt swap
        if (n.querySelector && (n.querySelector('#downloadSerialBtn') || n.querySelector('#closeSerialPreviewBtn') || n.querySelector('h1'))) {
          swapPreviewButtons(n);
        }
      });
    });
    // Also attempt to ensure Back button on any mutation
    ensureBrowseBackButton();
  });
  extraObserver.observe(document.body, { childList: true, subtree: true });

  document.addEventListener('DOMContentLoaded', () => {
    // Try swapping in already-present previews
    const previews = document.querySelectorAll('.serial-preview, #serialPreview, .preview-modal, .story-preview');
    previews.forEach(p => swapPreviewButtons(p));
    ensureBrowseBackButton();
    // Also attempt a second pass after a short delay
    setTimeout(()=>{ previews.forEach(p => swapPreviewButtons(p)); ensureBrowseBackButton(); }, 800);
  });

</script>
<!-- END: Auto-Injected Serial READs & Download Augmentation -->
  <!-- existing app scripts -->
  <script>
// ---------- Tags helpers (insert near other helpers) ----------

// create a tag "chip" element
function makeTagChip(tagText) {
  const chip = document.createElement('div');
  chip.className = 'tag-chip';
  chip.style.cssText = 'display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#f3f4f6;border:1px solid #e5e7eb;font-weight:600';
  chip.innerHTML = `<span class="tag-label">${tagText}</span><button type="button" class="tag-remove" title="Remove tag" style="background:transparent;border:0;cursor:pointer;font-weight:700">✕</button>`;
  chip.querySelector('.tag-remove').addEventListener('click', () => chip.remove());
  return chip;
}

// add one tag from an input to a container (prevents duplicates, trims)
function addTagFromInput(inputEl, containerEl) {
  if (!inputEl || !containerEl) return;
  const raw = (inputEl.value || '').trim();
  if (!raw) return inputEl.value = '';

  // support comma-separated tags (e.g. "apple, banana")
  const parts = raw.split(',').map(s => s.trim()).filter(Boolean);

  parts.forEach(v => {
    // prevent duplicates (case-insensitive)
    const exist = Array.from(containerEl.querySelectorAll('.tag-label'))
      .some(n => n.textContent.toLowerCase() === v.toLowerCase());
    if (exist) return;
    const chip = makeTagChip(v);
    containerEl.appendChild(chip);
  });

  inputEl.value = '';
  inputEl.focus();
}

// return array of tag texts from a container
function getTagsFromContainer(containerEl) {
  if (!containerEl) return [];
  return Array.from(containerEl.querySelectorAll('.tag-label')).map(n => n.textContent.trim()).filter(Boolean);
}

// clear container and set tags (useful when loading an existing story/serial)
function setTagsToContainer(containerEl, tagsArray) {
  if (!containerEl) return;
  containerEl.innerHTML = '';
  (Array.isArray(tagsArray) ? tagsArray : []).forEach(t => {
    if (!t) return;
    const chip = makeTagChip(t);
    containerEl.appendChild(chip);
  });
}

// wire inputs/buttons: inputEl = <input>, btnEl = add button, containerEl = tags container
function wireTagInput(inputEl, btnEl, containerEl) {
  if (!inputEl || !btnEl || !containerEl) return;

  // add click handler
  btnEl.addEventListener('click', () => addTagFromInput(inputEl, containerEl));

  // add Enter handler on input
  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addTagFromInput(inputEl, containerEl);
    } else if (e.key === ',' && e.ctrlKey) {
      // optional: ctrl+, to quickly add current value
      e.preventDefault();
      addTagFromInput(inputEl, containerEl);
    }
  });

  // handle paste of multiple tags (comma-separated)
  inputEl.addEventListener('paste', (ev) => {
    const text = (ev.clipboardData || window.clipboardData).getData('text');
    if (text && text.includes(',')) {
      ev.preventDefault();
      inputEl.value = text;
      addTagFromInput(inputEl, containerEl);
    }
  });
}

// convenience initialiser — automatically finds the elements you added earlier
function initTagsUI() {
  try {
    const storyInput = document.getElementById('storyTagInput');
    const storyBtn = document.getElementById('addStoryTagBtn');
    const storyCont = document.getElementById('storyTagsContainer');

    const seriesInput = document.getElementById('seriesTagInput');
    const seriesBtn = document.getElementById('addSeriesTagBtn');
    const seriesCont = document.getElementById('seriesTagsContainer');

    if (storyInput && storyBtn && storyCont) wireTagInput(storyInput, storyBtn, storyCont);
    if (seriesInput && seriesBtn && seriesCont) wireTagInput(seriesInput, seriesBtn, seriesCont);

    // If you want to pre-load tags when editing, call setTagsToContainer(container, tagsArray)
    // Example:
    // setTagsToContainer(storyCont, existingStory.tags || []);

  } catch (err) {
    console.warn('initTagsUI error', err);
  }
}

// call init on DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initTagsUI);
} else {
  initTagsUI();
}

// ---- Helpers to attach tags to your payloads before save/publish ----

// Usage: before saving/publishing a story, do:
// const story = { title: ..., content: ... };
// attachStoryTagsToPayload(story);
// then save story object
function attachStoryTagsToPayload(payload) {
  const c = document.getElementById('storyTagsContainer');
  if (!payload) payload = {};
  payload.tags = getTagsFromContainer(c);
  return payload;
}

// Usage for series/serial create flow:
// const series = { title: ..., desc: ... };
// attachSeriesTagsToPayload(series);
function attachSeriesTagsToPayload(payload) {
  const c = document.getElementById('seriesTagsContainer');
  if (!payload) payload = {};
  payload.tags = getTagsFromContainer(c);
  return payload;
}

// ---- Small CSS helper (optional) ----
// If you prefer to add styles inside a <style> tag, here's a compact rule you can paste into your CSS:
const tagChipStyle = `
.tag-chip { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background:#f3f4f6; border:1px solid #e5e7eb; font-weight:600; margin:2px; }
.tag-chip .tag-remove { cursor:pointer; font-weight:700; padding-left:6px; }
`;
// inject style once (non-destructive)
if (!document.getElementById('meurbal-tagchip-styles')) {
  const s = document.createElement('style');
  s.id = 'meurbal-tagchip-styles';
  s.textContent = tagChipStyle;
  document.head.appendChild(s);
}

    // your main app code ...
  </script>

  <!-- ✅ Add this line for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js">
// ---- Inject cover background in browse stories ----
function applyCoverToStoryCards() {
  document.querySelectorAll('#storiesCards .story-card').forEach(card => {
    const title = card.querySelector('h2')?.innerText?.trim();
    if (!title) return;
    const story = (window.storiesData || []).find(s => s.title === title);
    if (story && story.cover) {
      card.style.backgroundImage = `url(${story.cover})`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';
      card.style.color = '#fff';
    }
  });
}



// ---- Enhanced cover display for Browse Stories ----
function renderStoryCardsWithCovers(storiesArray) {
  const container = document.getElementById('storiesCards');
  if (!container) return;
  container.innerHTML = '';
  (storiesArray || []).forEach(story => {
    const storyCard = document.createElement('div');
    storyCard.className = 'story-card';
    storyCard.innerHTML = `<h2>${story.title}</h2><p>${story.genre || ''}</p>`;

    if (story.cover) {
      storyCard.style.backgroundImage = `url(${story.cover})`;
      storyCard.style.backgroundSize = 'cover';
      storyCard.style.backgroundPosition = 'center';
      storyCard.style.color = '#fff';
    }

    container.appendChild(storyCard);
  });
}

// Automatically override story browsing behavior
window._oldRenderStories = window.renderStories;
window.renderStories = function() {
  if (typeof window._oldRenderStories === 'function') window._oldRenderStories();
  try {
    renderStoryCardsWithCovers(window.storiesData || []);
  } catch (e) { console.warn('Cover apply failed:', e); }
};

// Run once on page load in case stories are already shown
document.addEventListener('DOMContentLoaded', () => renderStoryCardsWithCovers(window.storiesData || []));


// Apply covers to serial cards in browse serials (runs after serials rendered)
function applySerialCovers() {
  // serialCategoriesGrid might contain cat cards; serial listing rendering may be elsewhere.
  // We'll scan serialsData and update any card elements that have data-title attribute matching serial title.
  document.querySelectorAll('.serial-card').forEach(card => {
    const title = card.dataset.title;
    if (!title) return;
    const ser = (window.serialsData || []).find(s => s.title === title);
    if (ser && ser.cover) {
      card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.35), rgba(0,0,0,0.35)), url(${ser.cover})`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';
      card.style.color = '#fff';
    }
  });
}
document.addEventListener('DOMContentLoaded', () => setTimeout(applySerialCovers, 300));
// === TESTING ONLY ===
// Generates 100 random serials with varying popularity, genres, and recency
function generateFakeSerials(count = 100) {
  const genres = ["Action", "Romance", "Comedy", "Fantasy", "Horror", "Tragic", "Thriller","Adventure","Crime","Historic"];
  const covers = [
    "https://picsum.photos/seed/serial1/500/700",
    "https://picsum.photos/seed/serial2/500/700",
    "https://picsum.photos/seed/serial3/500/700",
    "https://picsum.photos/seed/serial4/500/700",
    "https://picsum.photos/seed/serial5/500/700"
  ];

  const randomDate = () => {
    const daysAgo = Math.floor(Math.random() * 365); // up to 1 year old
    const date = new Date(Date.now() - daysAgo * 86400000);
    return date.toISOString();
  };

  const serials = [];
  for (let i = 0; i < count; i++) {
    const genre = genres[Math.floor(Math.random() * genres.length)];
    const title = `${genre} Serial #${i + 1}`;
    const views = Math.floor(Math.random() * 10000);
    const likes = Math.floor(Math.random() * 500);
    const votes = Math.floor(Math.random() * 200);
    const cover = covers[Math.floor(Math.random() * covers.length)];
    const description = `A ${genre.toLowerCase()} story full of twists, heroes, and heart. Random ID ${i}.`;

    serials.push({
      id: i + 1,
      title,
      genre,
      description,
      views,
      likes,
      votes,
      cover,
      createdAt: randomDate()
    });
  }

  return serials;
}

// === CALL THIS TO TEST ===
function testSerialAlgorithm() {
  const fakeList = generateFakeSerials(100);
  renderBrowseSerials(fakeList);
  console.log("✅ Generated 100 fake serials and rendered using new algorithm.");
}

// Run automatically for quick testing (you can remove this after testing)
document.addEventListener('DOMContentLoaded', () => {
  testSerialAlgorithm();
});

</script>

<script>
// --- Real Search (no demo/fake stories) ---
function initRealSearch(){
  // helper
  function escapeHtml(str){return String(str??'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
  function debounce(fn,wait=220){let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),wait)};}

  // -------- STORIES SEARCH ----------
  const storiesInput=document.getElementById('storiesSearchInput');
  const storiesClear=document.getElementById('storiesClearSearchBtn');
  const storiesCards=document.getElementById('storiesCards');
  function searchStories(q){
    const query=(q||'').trim().toLowerCase();
    if(!storiesCards)return;
    let pool=[];
    try{pool=(window.storiesData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedStories_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!query){
      storiesCards.innerHTML='';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    storiesCards.innerHTML='';
    matches.forEach(story=>{
      const card=document.createElement('div');
      card.className='story-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(story.title||'Untitled')}</h3><p>${escapeHtml(story.genre||'')}</p>`;
      if(story.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${story.cover})`;
      card.addEventListener('click',()=>{try{openPreviewFullScreen(story);}catch(e){}});
      storiesCards.appendChild(card);
    });
  }
  if(storiesInput)storiesInput.addEventListener('input',debounce(e=>searchStories(e.target.value),200));
  if(storiesClear)storiesClear.addEventListener('click',()=>{storiesInput.value='';searchStories('');});

  // -------- SERIALS SEARCH ----------
  const serialsInput=document.getElementById('serialsSearchInput');
  const serialsClear=document.getElementById('serialsClearSearchBtn');
  const serialsWrap=document.getElementById('serialSearchResults');
  const serialsCards=document.getElementById('serialsCards');
  function searchSerials(q){
    const query=(q||'').trim().toLowerCase();
    let pool=[];
    try{pool=(window.serialsData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedSerials_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!serialsCards)return;
    if(!query){
      serialsCards.innerHTML='';
      if(serialsWrap)serialsWrap.style.display='none';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    serialsCards.innerHTML='';
    matches.forEach(s=>{
      const card=document.createElement('div');
      card.className='story-card serial-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(s.title||'Untitled')}</h3><p>${escapeHtml(s.genre||'')}</p>`;
      if(s.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${s.cover})`;
      card.addEventListener('click',()=>{try{openSerialPreview(s.id||s.title);}catch(e){}});
      serialsCards.appendChild(card);
    });
    if(serialsWrap)serialsWrap.style.display=matches.length?'block':'none';
  }
  if(serialsInput)serialsInput.addEventListener('input',debounce(e=>searchSerials(e.target.value),200));
  if(serialsClear)serialsClear.addEventListener('click',()=>{serialsInput.value='';searchSerials('');});
}
if(document.readyState==='loading')document.addEventListener('DOMContentLoaded',initRealSearch);
else initRealSearch();
</script>


<script>
document.addEventListener('DOMContentLoaded', async ()=>{
  // load from firebase if available
  try{
    if(window._firebase && window._firebase.get){
      const { db, ref, get, child } = window._firebase;
      // load stories
      try{
        const snap = await get(child(ref(db), 'stories'));
        if(snap && snap.exists && snap.exists()){
          const val = snap.val();
          // val may be an object of keyed stories; map to array
          window.storiesData = Object.values(val || {});
          console.log('Loaded stories from Firebase:', window.storiesData.length);
        } else { console.log('No stories in Firebase'); }
      }catch(e){ console.warn('Failed to load stories from Firebase', e); }

      // load serials
      try{
        const snap2 = await get(child(ref(db), 'serials'));
        if(snap2 && snap2.exists && snap2.exists()){
          const val2 = snap2.val();
          window.serialsData = Object.values(val2 || {});
          console.log('Loaded serials from Firebase:', window.serialsData.length);
        } else { console.log('No serials in Firebase'); }
      }catch(e){ console.warn('Failed to load serials from Firebase', e); }
    }
  }catch(e){ console.warn('Firebase loader error', e); }
});
</script>

</body>
</html>


<script>
// --- Real Search (no demo/fake stories) ---
function initRealSearch(){
  // helper
  function escapeHtml(str){return String(str??'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
  function debounce(fn,wait=220){let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),wait)};}

  // -------- STORIES SEARCH ----------
  const storiesInput=document.getElementById('storiesSearchInput');
  const storiesClear=document.getElementById('storiesClearSearchBtn');
  const storiesCards=document.getElementById('storiesCards');
  function searchStories(q){
    const query=(q||'').trim().toLowerCase();
    if(!storiesCards)return;
    let pool=[];
    try{pool=(window.storiesData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedStories_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!query){
      storiesCards.innerHTML='';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    storiesCards.innerHTML='';
    matches.forEach(story=>{
      const card=document.createElement('div');
      card.className='story-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(story.title||'Untitled')}</h3><p>${escapeHtml(story.genre||'')}</p>`;
      if(story.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${story.cover})`;
      card.addEventListener('click',()=>{try{openPreviewFullScreen(story);}catch(e){}});
      storiesCards.appendChild(card);
    });
  }
  if(storiesInput)storiesInput.addEventListener('input',debounce(e=>searchStories(e.target.value),200));
  if(storiesClear)storiesClear.addEventListener('click',()=>{storiesInput.value='';searchStories('');});

  // -------- SERIALS SEARCH ----------
  const serialsInput=document.getElementById('serialsSearchInput');
  const serialsClear=document.getElementById('serialsClearSearchBtn');
  const serialsWrap=document.getElementById('serialSearchResults');
  const serialsCards=document.getElementById('serialsCards');
  function searchSerials(q){
    const query=(q||'').trim().toLowerCase();
    let pool=[];
    try{pool=(window.serialsData||[]).slice();}catch(e){}
    try{
      const saved=JSON.parse(localStorage.getItem('savedSerials_v1')||'[]');
      if(Array.isArray(saved))pool=pool.concat(saved);
    }catch(e){}
    if(!serialsCards)return;
    if(!query){
      serialsCards.innerHTML='';
      if(serialsWrap)serialsWrap.style.display='none';
      return;
    }
    const seen=new Map();
    pool.forEach(s=>{if(s&&s.title&&!seen.has(s.title))seen.set(s.title,s)});
    const matches=Array.from(seen.values()).filter(s=>(s.title||'').toLowerCase().includes(query));
    serialsCards.innerHTML='';
    matches.forEach(s=>{
      const card=document.createElement('div');
      card.className='story-card serial-card';
      card.style.minHeight='220px';
      card.innerHTML=`<h3>${escapeHtml(s.title||'Untitled')}</h3><p>${escapeHtml(s.genre||'')}</p>`;
      if(s.cover)card.style.backgroundImage=`linear-gradient(rgba(0,0,0,0.25),rgba(0,0,0,0.25)),url(${s.cover})`;
      card.addEventListener('click',()=>{try{openSerialPreview(s.id||s.title);}catch(e){}});
      serialsCards.appendChild(card);
    });
    if(serialsWrap)serialsWrap.style.display=matches.length?'block':'none';
  }
  if(serialsInput)serialsInput.addEventListener('input',debounce(e=>searchSerials(e.target.value),200));
  if(serialsClear)serialsClear.addEventListener('click',()=>{serialsInput.value='';searchSerials('');});
}
if(document.readyState==='loading')document.addEventListener('DOMContentLoaded',initRealSearch);
else initRealSearch();
</script>
<!-- ===== START: Firebase sync + bottom status box (paste before </body>) ===== -->
<script>
/* FIREBASE SYNC INTEGRATION
   - Paste this just before </body>
   - Uses your provided firebaseConfig (Realtime Database)
   - Will: init Firebase, load on start, sync periodically and on key events,
     and show a black status box at bottom with saving/loading states.
*/

/* ======= 1) Firebase config (use exactly what you provided) ======= */
<!-- ===== FULL FIXED FIREBASE SYNC BLOCK ===== -->
<script>
const firebaseConfig = {
  apiKey: "AIzaSyCgTh6FzKWYCGyRgBmeclvGKxuuFL3L81Y",
  authDomain: "meurbal.firebaseapp.com",
  databaseURL: "https://meurbal-default-rtdb.firebaseio.com",
  projectId: "meurbal",
  storageBucket: "meurbal.firebasestorage.app",
  messagingSenderId: "917148598257",
  appId: "1:917148598257:web:dd42e5d690b56d2ac08e50",
  measurementId: "G-EHJVB3XC90"
};

// ---- Create status box ----
(function(){
  if(document.getElementById('firebaseStatusBox')) return;
  const box=document.createElement('div');
  box.id='firebaseStatusBox';
  box.style='position:fixed;bottom:10px;left:10px;right:10px;padding:8px 12px;background:#000;color:#fff;font:13px/1.4 sans-serif;border-radius:10px;z-index:99999;display:flex;justify-content:space-between;align-items:center';
  box.innerHTML=`<div id="fbStatusText">Connecting…</div>
  <div>
    <button id="fbLoadBtn" style="background:#111;color:#fff;border:none;padding:4px 10px;border-radius:8px;cursor:pointer">Load</button>
  </div>`;
  document.body.appendChild(box);
  document.getElementById('fbLoadBtn').onclick=()=>{ if(window.loadFromFirebase) loadFromFirebase(true); };
})();
function fbSetStatus(t){ const el=document.getElementById('fbStatusText'); if(el) el.textContent=t; }

function ensureFirebase(cb){
  if(window.firebase && window.firebase.database) return cb();
  const s1=document.createElement('script'); s1.src='https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js';
  s1.onload=()=>{ const s2=document.createElement('script'); s2.src='https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js'; s2.onload=cb; document.head.appendChild(s2); };
  document.head.appendChild(s1);
}

ensureFirebase(async ()=>{
  try{
    if(!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  }catch(e){ fbSetStatus('Firebase init error'); console.error(e); return; }
  const db=firebase.database();
  fbSetStatus('Connected');

  async function saveToFirebase(){
    try{
      fbSetStatus('Saving…');
      await db.ref('meurbal_v1/stories').set(window.storiesData||[]);
      await db.ref('meurbal_v1/serials').set(window.serialsData||[]);
      fbSetStatus('Saved ✓');
    }catch(e){ console.error(e); fbSetStatus('Save error'); }
  }

  async function loadFromFirebase(force){
    try{
      fbSetStatus('Loading…');
      const [stSnap,seSnap]=await Promise.all([
        db.ref('meurbal_v1/stories').once('value'),
        db.ref('meurbal_v1/serials').once('value')
      ]);
      const stories=stSnap.val()||[], serials=seSnap.val()||[];
      if(force || !(window.storiesData&&window.storiesData.length)){
        window.storiesData=stories;
      }
      if(force || !(window.serialsData&&window.serialsData.length)){
        window.serialsData=serials;
      }
      fbSetStatus('Loaded ✓');
      if(typeof renderBrowseStories==='function') renderBrowseStories('All');
      if(typeof renderBrowseSerials==='function') renderBrowseSerials(serials);
    }catch(e){ console.error(e); fbSetStatus('Load error'); }
  }
  window.loadFromFirebase=loadFromFirebase;

  // ---- Auto load when app ready ----
  const wait=setInterval(()=>{
    if(window.storiesData&&window.serialsData){
      clearInterval(wait);
      loadFromFirebase();
    }
  },700);

  // ---- Auto save triggers ----
  document.addEventListener('click',e=>{
    const id=e.target&&e.target.id;
    if(['publishStoryBtn','saveDraftBtn','serialCreateConfirmBtn','addEpConfirmBtn'].includes(id)){
      setTimeout(saveToFirebase,600);
    }
  });

  // periodic auto save
  setInterval(saveToFirebase,20000);
});
</script>
<!-- ===== END FIXED BLOCK ===== -->

<!-- ===== END: Firebase sync + bottom status box ===== -->

</body>
</html>
