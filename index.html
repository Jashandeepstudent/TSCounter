<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Profiles App — Updated (Hire + description + better notifications)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{
    --primary:#0077ff;
    --primary-2:#2aa0ff;
    --accent:#ff6a00;
    --danger:#ff3333;
    --bg:#f4f7fb;
    --card-bg:#ffffff;
    --muted:#6b7280;
    --glass: rgba(255,255,255,0.6);
  }

  html,body{height:100%; margin:0; padding:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#111;}
  .page{ display:none; min-height:100vh; box-sizing:border-box; padding:28px; }

  #home {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    padding: 0;
  }
#savedProfilesPage h2 {
  text-align: center;
  margin-top: 0;
  margin-bottom: 16px;
}


  .menu-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    gap: 22px;
    align-items: center;
  }

  .menu-container button{
    background: linear-gradient(135deg, #0077ff, #2aa0ff);
    border: none;
    border-radius: 14px;
    padding: 14px 32px;
    font-size: 18px;
    font-weight: 700;
    color: #fff;
    box-shadow: 0 10px 28px rgba(0, 0, 0, 0.12);
    transition: all 0.25s ease;
}
    min-width:260px;
    font-size:18px;
    padding:12px 32px;
    border-radius:12px;
    border:none;
    cursor:pointer;
    font-weight:700;
    letter-spacing:0.2px;
    background: linear-gradient(90deg,var(--primary),var(--primary-2));
    color:#fff;
    box-shadow: 0 10px 30px rgba(34,120,255,0.12);
    transition: transform .22s ease, box-shadow .22s;
  }
  .menu-container button:hover{ transform: translateY(-4px); box-shadow: 0 16px 40px rgba(34,120,255,0.16); }

  button { font-family: inherit; }

  .back-btn{
    position:fixed;
    bottom:20px;
    left:20px;
    background:var(--danger);
    color:#fff;
    padding:10px 20px;
    border-radius:10px;
    border:none;
    cursor:pointer;
    font-weight:bold;
    box-shadow:0 6px 16px rgba(0,0,0,0.12);
  }

  /* Categories page */
  #categoriesPage h2{
    text-align:center;
    margin-top:0;
    margin-bottom:16px;
  }
  .categories{
    display:flex;
    justify-content:center;
    gap:12px;
    margin-bottom:18px;
    flex-wrap:wrap;
  }
  .category{
    background:#fff;
    padding:10px 18px;
    border-radius:999px;
    box-shadow:0 6px 18px rgba(12,40,80,0.06);
    cursor:pointer;
    font-weight:600;
    transition: background .2s, transform .12s;
  }
  .category:hover{ transform: translateY(-4px); }

  .search-bar{ display:flex; justify-content:center; margin-bottom:20px; }
  .search-bar input{
    width:50%;
    max-width:520px;
    padding:12px 14px;
    border:1px solid #e6eefc;
    border-radius:12px;
    font-size:16px;
    box-shadow: 0 6px 20px rgba(18,40,80,0.04);
  }

  .profile-list{ display:flex; flex-direction:column; gap:12px; padding-bottom:80px; }
  .profile-box{
    background:linear-gradient(180deg,#ffffff, #fbfdff);
    color:#111;
    padding:18px;
    border-radius:14px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:18px;
    box-shadow: 0 8px 28px rgba(14,30,70,0.06);
  }
  .profile-box button {
    background: linear-gradient(90deg,#28a745,#66cc66);
    color:#fff;
    border:none;
    border-radius:12px;
    padding:8px 16px;
    font-size:14px;
    cursor:pointer;
    font-weight:700;
    box-shadow:0 6px 18px rgba(34,120,255,0.06);
    transition:transform .18s, box-shadow .18s;
  }
  .profile-box button:hover {
    transform:translateY(-3px);
    box-shadow:0 10px 26px rgba(34,120,255,0.08);
  }

  .save-btn {
    margin-left: 12px;
    cursor: pointer;
    font-size: 20px;
    user-select:none;
  }
  .saved { color: gold; }

  /* Create Profile form */
  #createProfilePage h2{ text-align:center; margin-bottom:14px; }
  form{
    display:flex;
    flex-direction:column;
    gap:12px;
    max-width:520px;
    margin:auto;
    background:#fff;
    padding:20px;
    border-radius:12px;
    box-shadow:0 6px 24px rgba(14,30,70,0.06);
  }
  input,select,textarea{
    padding:12px;
    font-size:16px;
    border-radius:8px;
    border:1px solid #e8eefb;
  }
  input:focus,select:focus,textarea:focus{ border-color:var(--primary); outline:none; box-shadow:0 8px 20px rgba(42,160,255,0.06); }
  .note{ font-size:13px; color:var(--muted); }

  form button[type="submit"] {
    background: linear-gradient(90deg,var(--accent),#ff3c82);
    font-size:18px;
    font-weight:800;
    border:none;
    border-radius:12px;
    color:#fff;
    padding:12px;
    cursor:pointer;
    box-shadow:0 10px 28px rgba(255,80,120,0.08);
    transition:transform .16s, box-shadow .16s;
  }
  form button[type="submit"]:hover {
    transform:scale(1.02);
    box-shadow:0 14px 38px rgba(255,80,120,0.12);
  }

  /* Redesigned open profile card */
  .open-profile{
    background: linear-gradient(180deg,#0f172a 0%, #071229 60%);
    color:#fff;
    padding:22px;
    max-width:820px;
    margin:28px auto;
    border-radius:18px;
    box-shadow: 0 18px 40px rgba(3,9,23,0.6);
    position:relative;
    text-align:left;
    overflow:hidden;
  }
  .open-profile .close-btn{
    position:absolute;
    top:14px; right:14px;
    background:transparent;
    color:#fff;
    border:none;
    padding:8px;
    border-radius:8px;
    cursor:pointer;
    font-size:18px;
    background: rgba(255,255,255,0.06);
  }
  .profile-header{
    display:flex;
    gap:18px;
    align-items:center;
  }
  .avatar{
    width:96px; height:96px; border-radius:18px;
    background: linear-gradient(135deg,#1e3a8a,#0ea5a6);
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:28px; color:#fff;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  .profile-head-info h3{ margin:0 0 6px 0; font-size:24px; letter-spacing:0.2px; }
  .profile-meta{ display:flex; gap:8px; align-items:center; }
  .skill-badge{
    background: rgba(255,255,255,0.06);
    padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px;
  }
  .status-badge{
    padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px;
    background: rgba(255,255,255,0.06);
  }
  .profile-body{
    display:grid;
    grid-template-columns: repeat(2, 1fr);
    gap:14px;
    margin-top:18px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:14px;
    border-radius:12px;
  }
  .profile-body strong{ color: #cfe8ff; display:block; margin-bottom:6px; font-weight:700; }
  .profile-body div{ color:#d6e9ff; padding-bottom:6px; }

  .profile-actions{
    margin-top:18px; display:flex; gap:12px; align-items:center;
  }
  .hire-btn{
    background: linear-gradient(90deg,#ff8a3d,#ff3c82);
    border:none; color:#fff; padding:12px 18px; font-weight:800; border-radius:12px; cursor:pointer;
    box-shadow:0 12px 30px rgba(255,60,130,0.14); font-size:16px;
  }
  .save-small{
    background:transparent; border:1px solid rgba(255,255,255,0.12); color:#fff; padding:10px 12px; border-radius:10px; cursor:pointer;
    font-weight:700;
  }

  .privacy-note{ margin-top:12px; font-size:13px; color:rgba(255,255,255,0.7); }

  /* Modal */
  .modal{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999;
    background: linear-gradient(90deg, rgba(2,6,23,0.6), rgba(2,6,23,0.6));
    padding:20px;
  }
  .modal.open{ display:flex; }
  .modal-content{
    width:100%; max-width:520px; background: #fff; color:#111; border-radius:12px; padding:18px; position:relative;
    box-shadow:0 22px 60px rgba(2,6,23,0.3);
  }
  .modal-close{
    position:absolute; top:10px; right:10px; border:none; background:transparent; font-size:18px; cursor:pointer;
  }
  .modal-buttons{ display:flex; gap:12px; margin-top:10px; }
  .modal-buttons button{ flex:1; padding:12px; border-radius:10px; border:none; font-weight:700; cursor:pointer; }
  .modal-buttons button:first-child{ background: linear-gradient(90deg,#06b6d4,#0ea5a6); color:#fff; }
  .modal-buttons button:last-child{ background: #eef2ff; color:#111; }

  .modal-result{ margin-top:14px; padding:12px; border-radius:8px; background:#fbfdff; color:#0b1220; }
  .modal-result .note{ color:#6b7280; font-size:13px; margin-top:8px; }

  /* Notifications tab tweaks */
  #notificationsPage {
    display: flex;
    flex-direction: column;
    justify-content: flex-start; 
    align-items: center;          
    height: 100vh;
    padding-top: 40px;            
    text-align: center;
  }

  #notificationsPage .tabs {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
  }
  .tabs button {
    padding: 10px 16px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    background: #eee;
    font-weight: bold;
  }
  .tabs button.active {
    background: linear-gradient(90deg,#ff6a00,#ff3c82);
    color: white;
  }

  @media (max-width:700px){
    .profile-body{ grid-template-columns: 1fr; }
    .avatar{ width:80px; height:80px; border-radius:14px; }
    .open-profile{ padding:16px; border-radius:12px; margin:16px; }
  }

.contact-btn {
  flex:1;
  padding: 10px 16px;
  border-radius: 10px;
  border: none;
  font-weight: 700;
  cursor: pointer;
  font-size: 15px;
  transition: transform 0.2s, box-shadow 0.2s;
}
.copy-btn {
  background: linear-gradient(90deg,#0077ff,#2aa0ff);
  color: #fff;
}
.close-btn {
  background: linear-gradient(90deg,#ef4444,#f97316);
  color: #fff;
}
.contact-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.2);
}

</style>

<style>
  .icon-btn {
    background: linear-gradient(135deg, #0077ff, #2aa0ff);
    color: #fff;
    border: none;
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .icon-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 28px rgba(0,0,0,0.18);
  }

  .dropdown {
    display: none;
    position: absolute;
    top: 44px;
    left: 0;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.12);
    min-width: 160px;
    flex-direction: column;
    z-index: 200;
    overflow: hidden;
  }
  .dropdown div {
    padding: 12px 16px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
  }
  .dropdown div:hover {
    background: #f0f4ff;
    color: #0077ff;
  }
</style>


<style>
  .notif-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .notif-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.12);
  }
  .reply-btn {
    background: linear-gradient(90deg,#0077ff,#2aa0ff);
    color: #fff;
    margin-right: 6px;
  }
  .read-btn {
    background: linear-gradient(90deg,#22c55e,#4ade80);
    color: #fff;
  }
  .bell-container {
    position: relative;
    display: inline-block;
  }
  .bell-badge {
    position: absolute;
    top: -6px;
    right: -6px;
    background: red;
    color: #fff;
    border-radius: 50%;
    padding: 2px 6px;
    font-size: 12px;
    font-weight: 700;
  }
</style>


<style>
/* Improved menu button styles (scoped to .menu-container to avoid affecting other buttons) */
.menu-container .menu-btn{
  min-width:260px;
  padding:14px 34px;
  border-radius:14px;
  border:none;
  cursor:pointer;
  font-weight:800;
  color:#fff;
  font-size:18px;
  box-shadow:0 12px 36px rgba(2,6,23,0.12);
  transition: transform .22s ease, box-shadow .22s;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:10px;
}
.menu-container .menu-btn.view-btn{
  background: linear-gradient(90deg,#06b6d4,#0ea5a6);
}
.menu-container .menu-btn.profile-btn{
  background: linear-gradient(90deg,#ff8a3d,#ff3c82);
}
.menu-container .menu-btn:hover{ transform: translateY(-6px); box-shadow: 0 18px 46px rgba(2,6,23,0.18); }
</style>

<!-- Added: Leaderboard + Ratings + UID styles -->
<style>
  /* Leaderboard styles */
  .leaderboard-tabs{display:flex;gap:10px;justify-content:center;margin-bottom:18px}
  .leaderboard-tabs button{padding:10px 16px;border-radius:10px;border:none;cursor:pointer;font-weight:700;background:#eee}
  .leaderboard-tabs button.active{background:linear-gradient(90deg,#0077ff,#2aa0ff);color:#fff}
  .leaderboard-list{display:flex;flex-direction:column;gap:12px;padding-bottom:40px}
  .leader-card{background:linear-gradient(180deg,#fff,#fbfdff);padding:14px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.06);display:flex;gap:12px;align-items:center}
  .leader-rank{font-size:32px;font-weight:900;width:64px;text-align:center;border-radius:8px;padding:6px}
  .leader-gold{background:linear-gradient(135deg,#facc15,#f59e0b);color:#111}
  .leader-silver{background:linear-gradient(135deg,#d1d5db,#9ca3af);color:#111}
  .leader-bronze{background:linear-gradient(135deg,#fbbf24,#b45309);color:#111}
  .leader-info strong{display:block;font-size:18px}
  .leader-info .uid{font-size:12px;color:var(--muted);margin-top:4px}
  .leader-info .meta{margin-top:8px;color:#374151;font-weight:700}
  /* Rating stars inside open profile */
  .profile-rating{margin-top:12px;display:flex;flex-direction:column;gap:8px}
  .rating-stars{display:inline-flex;gap:6px}
  .rating-stars span{cursor:pointer;font-size:20px;color:#e5e7eb}
  .rating-stars span.active{color:#fbbf24}
  .rating-result{margin-top:6px;font-weight:800;color:#0077ff}
  /* OTP box style */
  .otp-card{background:#ecfdf5;border:1px solid #bbf7d0;color:#065f46;padding:12px;border-radius:10px;font-weight:800;box-shadow:0 8px 30px rgba(2,6,23,0.04);margin-top:10px}
</style>
<!-- End injection -->
</head>

<body>

<div class="top-bar" style="position:fixed; top:12px; left:12px; right:12px; display:flex; justify-content:space-between; align-items:center; z-index:100;">
  <div id="menuWrap" style="position:relative;">
    <button class="icon-btn" onclick="toggleMenu()">⋮</button>
    <div id="menuDropdown" class="dropdown">
      <div onclick="showPage('savedProfilesPage')">Saved Profiles</div>
    </div>
  </div>
  <div id="bellWrap" class="bell-container"><button class="icon-btn" onclick="showPage('notificationsPage')">🔔</button></div>
</div>

<!-- Main menu -->
<div id="home" class="page">
  <div class="menu-container">
    <button class="menu-btn view-btn" onclick="showPage('categoriesPage')">View Profiles</button>
    <button id="profileBtn" class="menu-btn profile-btn" onclick="openProfileForm()">Create a Profile</button>
  </div>
</div>

<!-- Create Profile -->
<div id="createProfilePage" class="page">
  <h2 id="formTitle">Create Your Profile</h2>
  <form id="profileForm">
    <input type="text" id="name" placeholder="Your Name" required>
    <input type="number" id="age" placeholder="Your Age" required>
    <select id="skill" required>
      <option value="">-- Select Skill --</option>
      <option value="Plumber">Plumber</option>
      <option value="Mechanic">Mechanic</option>
      <option value="Electrician">Electrician</option>
      <option value="Painter">Painter</option>
      <option value="Tutor">Tutor</option>
    </select>
    <input type="text" id="address" placeholder="Your Address" required>
    <input type="text" id="contact" placeholder="Contact No." required>
    <label>Portfolio (optional):</label>
    <input type="file" id="portfolio">
    <p class="note">If not uploaded, you have to submit portfolio in 2 days.</p>
    <input type="text" id="language" placeholder="Languages Spoken">
    <textarea id="description" placeholder="Short description about you (will show under your name)" rows="3"></textarea>
    <div id="statusSection" style="display:none;">
      <label for="status">Profile Status:</label>
      <select id="status">
        <option value="Free" selected>Free</option>
        <option value="Busy">Busy</option>
      </select>
      <p class="note">Free means your profile is visible in the app. Busy will hide it, letting you rest.</p>
    </div>
    <button type="submit" id="submitBtn">₹250</button>
  </form>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<!-- View Profiles -->
<div id="categoriesPage" class="page">
  <h2>View Profiles</h2>
  <div class="categories" id="categoryFilter">
    <div class="category" onclick="filterSkill('All')">All</div>
    <div class="category" onclick="filterSkill('Plumber')">Plumber</div>
    <div class="category" onclick="filterSkill('Mechanic')">Mechanic</div>
    <div class="category" onclick="filterSkill('Electrician')">Electrician</div>
    <div class="category" onclick="filterSkill('Painter')">Painter</div>
    <div class="category" onclick="filterSkill('Tutor')">Tutor</div>
  </div>
  <div class="search-bar">
    <input type="text" id="searchInput" placeholder="Search by Name or UID" oninput="displayProfiles()">
  </div>
  <div id="profileList" class="profile-list"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<!-- Open Profile (redesigned) -->
<div id="openProfilePage" class="page">
  <div class="open-profile">
    <button class="close-btn" onclick="closeProfile()">✕</button>

    <div class="profile-header">
      <div class="avatar" id="profileAvatar">P</div>
      <div class="profile-head-info">
        <h3 id="profileName">Name</h3>
        <div id="profileDescription" style="margin-top:6px; color:#d6e9ff;"></div>
        <div class="profile-meta">
          <div id="profileSkill" class="skill-badge">Skill</div>
          <div id="profileStatus" class="status-badge">Status</div>
        </div>
      </div>
    </div>

    <div class="profile-body">
      <div>
        <strong>UID</strong>
        <div id="profileUID">—</div>
      </div>
      <div>
        <strong>Age</strong>
        <div id="profileAge">—</div>
      </div>
      <div>
        <strong>Address</strong>
        <div id="profileAddress">—</div>
      </div>
      <div>
        <strong>Languages Spoken</strong>
        <div id="profileLanguage">—</div>
      </div>
    </div>

    <div class="profile-actions">
      <button id="hireBtn" class="hire-btn" onclick="openHireModal()">Hire</button>
      <button id="saveBtn" class="save-small" onclick="toggleSaveFromOpen()">⭐ Save</button>
    </div>

    <p class="privacy-note">Contact is hidden by default. Click <strong>Hire → Contact</strong> to view the number. </p>
  </div>
</div>

<!-- Hire modal -->
<div id="hireModal" class="modal" onclick="modalBackgroundClick(event)">
  <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="hireTitle">
    <button class="modal-close" onclick="closeHireModal()">✕</button>
    <h4 id="hireTitle">Hire Options</h4>
    <p class="note">Choose how you'd like to proceed with this profile.</p>
    <div class="modal-buttons">
      <button id="modalContactBtn" onclick="showContact()">Contact</button>
      <button id="modalMessageBtn" onclick="showMessage()">Message</button>
    </div>
    <div id="modalResult" class="modal-result" aria-live="polite"></div>
  </div>
</div>

<!-- Notifications -->
<div id="notificationsPage" class="page">
  <h2>Notifications</h2>
  <div class="tabs">
    <button onclick="switchTab('unread')" id="tab-unread" class="active">Unread</button>
    <button onclick="switchTab('read')" id="tab-read">Read</button>
    <button onclick="switchTab('hire')" id="tab-hire">Hire Requests</button>
  </div>
  <div id="notificationContent"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>


<!-- Chat Page -->
<div id="chatPage" class="page">
  <div style="display:flex; align-items:center; padding:12px; background:#0077ff; color:#fff; position:sticky; top:0; border-radius:0 0 12px 12px;">
    <button onclick="backFromChat()" style="background:none; border:none; color:#fff; font-size:18px; margin-right:12px; cursor:pointer;">←</button>
    <strong id="chatWithName">Chat</strong>
  </div>
  <div id="chatMessages" style="flex:1; overflow-y:auto; padding:16px; height:70vh; background:#f0f4ff; border-radius:12px; margin:12px 0;"></div>
  <div style="display:flex; gap:8px; padding:12px; background:#fff; border-radius:12px; box-shadow:0 -4px 10px rgba(0,0,0,0.08);">
    <input type="text" id="chatInput" placeholder="Type a message..." style="flex:1; padding:12px; border-radius:8px; border:1px solid #ddd; font-size:16px;">
    <button onclick="sendMessage()" style="background:linear-gradient(90deg,#0077ff,#2aa0ff); border:none; border-radius:8px; color:#fff; padding:0 18px; font-size:16px; cursor:pointer;">Send</button>
  </div>
</div>

<!-- Saved Profiles -->
<div id="savedProfilesPage" class="page">
  <h2>Saved Profiles</h2>
  <div class="categories" id="savedCategoryFilter">
    <div class="category" onclick="savedSkill='All';displaySaved()">All</div>
    <div class="category" onclick="savedSkill='Plumber';displaySaved()">Plumber</div>
    <div class="category" onclick="savedSkill='Mechanic';displaySaved()">Mechanic</div>
    <div class="category" onclick="savedSkill='Electrician';displaySaved()">Electrician</div>
    <div class="category" onclick="savedSkill='Painter';displaySaved()">Painter</div>
    <div class="category" onclick="savedSkill='Tutor';displaySaved()">Tutor</div>
  </div>
  <div class="search-bar">
    <input type="text" id="savedSearchInput" placeholder="Search in Saved" oninput="displaySaved()">
  </div>
  <div id="savedList" class="profile-list"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<script>
let profiles=[];
let savedProfiles=[];
let currentSkill='All';
let savedSkill='All';
let myProfile=null;
const PROFILES_STORAGE_KEY = 'profiles_data_v1';
const MY_PROFILE_KEY = 'profiles_my_profile_v1';

// Load profiles + myProfile from storage once DOM is ready
window.addEventListener("DOMContentLoaded", () => {
  try {
    const rawProfiles = localStorage.getItem(PROFILES_STORAGE_KEY);
    if (rawProfiles) profiles = JSON.parse(rawProfiles) || [];
  } catch(e){ profiles = []; }

  try {
    const rawMy = localStorage.getItem(MY_PROFILE_KEY);
    if (rawMy) myProfile = JSON.parse(rawMy);
  } catch(e){ myProfile = null; }

  const btn = document.getElementById('profileBtn');
  if (btn) btn.textContent = myProfile ? "Manage Profile" : "Create a Profile";
});

let currentOpenProfile=null;

function generateUID(){ return Date.now()+Math.floor(Math.random()*1000); }

function showPage(id){
  document.querySelectorAll('.page').forEach(p=>p.style.display='none');
  document.getElementById(id).style.display='block';

  if(id==='categoriesPage') displayProfiles();

  if(id==='savedProfilesPage') {
    displaySaved();
    // close 3-dots menu if open
    const dd = document.getElementById("menuDropdown");
    if(dd) {
      dd.style.display = "none";
      dd.style.removeProperty("display");
    }
  }

  if(id==='notificationsPage') {
    // restore the last active notifications tab (keeps user's previous context)
    switchTab(lastNotificationTab || 'unread');
  }
}


function filterSkill(skill){ currentSkill=skill; displayProfiles(); }

function openProfileForm(){
  showPage('createProfilePage');
  if(myProfile){
    document.getElementById('formTitle').textContent="Manage Your Profile";
    document.getElementById('submitBtn').textContent="Save";
    document.getElementById('statusSection').style.display="block";
    document.getElementById('name').value=myProfile.name;
    document.getElementById('age').value=myProfile.age;
    document.getElementById('skill').value=myProfile.skill;
    document.getElementById('address').value=myProfile.address;
    document.getElementById('contact').value=myProfile.contact;
    document.getElementById('language').value=myProfile.language;
    document.getElementById('description').value = myProfile.description || '';
    document.getElementById('status').value=myProfile.status;
  } else {
    document.getElementById('formTitle').textContent="Create Your Profile";
    document.getElementById('submitBtn').textContent="₹250";
    document.getElementById('statusSection').style.display="none";
    document.getElementById('profileForm').reset();
  }
}

document.getElementById("profileForm").addEventListener("submit",function(e){
  e.preventDefault();
  const profile={
    uid: myProfile ? myProfile.uid : generateUID(),
    name:document.getElementById("name").value.trim(),
    age:document.getElementById("age").value,
    skill:document.getElementById("skill").value,
    address:document.getElementById("address").value,
    contact:document.getElementById("contact").value.trim(),
    language:document.getElementById("language").value,
    description: document.getElementById("description").value.trim(),
    status: myProfile ? document.getElementById("status").value : "Free"
  };
  if(myProfile){
    const idx=profiles.findIndex(p=>p.uid===myProfile.uid);
    if(idx!==-1) profiles[idx]=profile;
  } else {
    profiles.push(profile);
  }
  myProfile=profile;
  document.getElementById("profileBtn").textContent="Manage Profile";
  try {
    localStorage.setItem(PROFILES_STORAGE_KEY, JSON.stringify(profiles));
    localStorage.setItem(MY_PROFILE_KEY, JSON.stringify(myProfile));
  } catch(e){ console.warn('Profile save failed', e); }

  alert("Profile saved successfully!");
  showPage('home');
});

function saveProfile(p){
  const index = savedProfiles.findIndex(sp=>sp.uid===p.uid);
  if(index===-1){
    savedProfiles.push(p);
    alert("Profile saved!");
  } else {
    savedProfiles.splice(index,1);
    alert("Removed from saved!");
  }
  displayProfiles();
  if(document.getElementById("savedProfilesPage").style.display==='block'){
    displaySaved();
  }
}

function displayProfiles(){
  const container=document.getElementById("profileList");
  container.innerHTML='';
  const search=document.getElementById("searchInput")?document.getElementById("searchInput").value.toLowerCase():"";
  profiles.filter(p=>{
    const statusMatch=p.status==="Free";
    const skillMatch=currentSkill==='All'||p.skill===currentSkill;
    const searchMatch=p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
    return statusMatch&&skillMatch&&searchMatch;
  }).forEach(p=>{
    const box=document.createElement('div'); box.className='profile-box';
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
    const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
    const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
    const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
    const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? previewText(p.description,50) : '';
    nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    left.appendChild(tag); left.appendChild(nameContainer);

    const actions=document.createElement('div'); actions.className='profile-actions';
    const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
    const saveBtn=document.createElement('span'); saveBtn.innerHTML='⭐'; 
    if(savedProfiles.some(sp=>sp.uid===p.uid)) saveBtn.classList.add("saved");
    saveBtn.className='save-btn';
    saveBtn.onclick=()=>saveProfile(p);
    actions.appendChild(openBtn); actions.appendChild(saveBtn);
    box.appendChild(left); box.appendChild(actions);
    container.appendChild(box);
  });
}

function openProfile(p){
  showPage('openProfilePage');
  currentOpenProfile = p;
  document.getElementById('profileName').textContent=p.name;
  document.getElementById('profileDescription').textContent = p.description || '';
  document.getElementById('profileUID').textContent=p.uid;
  document.getElementById('profileAge').textContent=p.age;
  document.getElementById('profileSkill').textContent=p.skill;
  document.getElementById('profileAddress').textContent=p.address;
  document.getElementById('profileLanguage').textContent=p.language;
  document.getElementById('profileStatus').textContent = p.status ? p.status : 'Free';

  // avatar initials
  const initials = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
  const avatar = document.getElementById('profileAvatar');
  avatar.textContent = initials;

  // update save button label/state
  updateSaveButtonState();
}

function closeProfile(){ showPage('categoriesPage'); currentOpenProfile=null; }

function toggleMenu(){
  const dd=document.getElementById("menuDropdown");
  dd.style.display = dd.style.display==="flex"?"none":"flex";
}

function displaySaved(){
  const c=document.getElementById("savedList");
  c.innerHTML="";
  const search=document.getElementById("savedSearchInput")?document.getElementById("savedSearchInput").value.toLowerCase():"";
  savedProfiles.filter(p=>{
    const skillMatch=savedSkill==='All'||p.skill===savedSkill;
    const searchMatch=p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
    return skillMatch&&searchMatch;
  }).forEach(p=>{
    const box=document.createElement('div'); box.className="profile-box";
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
    const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
    const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
    const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
    const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? previewText(p.description,50) : '';
    nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    left.appendChild(tag); left.appendChild(nameContainer);

    const actions=document.createElement('div'); actions.className='profile-actions';
    const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
    const saveBtn=document.createElement('span'); saveBtn.innerHTML='⭐'; saveBtn.className='save-btn saved';
    saveBtn.onclick=()=>saveProfile(p);
    actions.appendChild(openBtn); actions.appendChild(saveBtn);
    box.appendChild(left); box.appendChild(actions);
    c.appendChild(box);
  });
}

/* HIRE modal logic */
function openHireModal(){
  if(!currentOpenProfile){ alert('No profile selected.'); return; }
  const modal=document.getElementById('hireModal');
  modal.classList.add('open');
  document.getElementById('modalResult').innerHTML = '';
}

function closeHireModal(){
  const modal=document.getElementById('hireModal');
  modal.classList.remove('open');
  document.getElementById('modalResult').innerHTML = '';
}

function modalBackgroundClick(e){
  if(e.target && e.target.id === 'hireModal') closeHireModal();
}

function showContact(){
  if(!currentOpenProfile) return;
  const modalResult = document.getElementById('modalResult');
  // show contact with gentle privacy warning
  modalResult.innerHTML = `
    <div><strong>Contact No.:</strong> <span id="visibleContact">${escapeHtml(currentOpenProfile.contact)}</span></div>
    <div class="note">Click 'Hire → Contact' to view the number.</div>
    <div style="margin-top:10px; display:flex; gap:8px;">
      <button class="contact-btn copy-btn" onclick="copyToClipboard('${escapeJs(currentOpenProfile.contact)}')">📋 Copy</button>
      <button class="contact-btn close-btn" onclick="closeHireModal()">✖ Close</button>
    </div>
  `;
}

function showMessage(){
  const modalResult = document.getElementById('modalResult');
  modalResult.innerHTML = `<div><strong>Message</strong><div class="note">Coming soon — in-app messaging will be available in a future update.</div></div>`;
}

/* Copy helper (uses Clipboard API when available) */
function copyToClipboard(text){
  if(navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(text).then(()=> {
      alert('Contact copied to clipboard.');
    }, ()=> {
      fallbackCopy(text);
    });
  } else {
    fallbackCopy(text);
  }
}
function fallbackCopy(text){
  const ta = document.createElement('textarea');
  ta.value=text; document.body.appendChild(ta);
  ta.select();
  try { document.execCommand('copy'); alert('Contact copied to clipboard.'); } catch(e){ alert('Copy failed — please copy manually: '+text); }
  ta.remove();
}

/* Save toggle from open profile */
function toggleSaveFromOpen(){
  if(!currentOpenProfile) return;
  saveProfile(currentOpenProfile);
  updateSaveButtonState();
}

function updateSaveButtonState(){
  const btn=document.getElementById('saveBtn');
  if(!currentOpenProfile){ btn.textContent='⭐ Save'; return; }
  if(savedProfiles.some(sp=>sp.uid===currentOpenProfile.uid)){
    btn.textContent='⭐ Saved';
    btn.style.background='linear-gradient(90deg,#fde68a,#f97316)';
    btn.style.color='#111';
  } else {
    btn.textContent='⭐ Save';
    btn.style.background='transparent';
    btn.style.color='#fff';
  }
}

/* small helper to escape content inserted into HTML */
function escapeHtml(str){
  if(!str) return '';
  return String(str).replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]; });
}
/* escape for JS single-quoted string insertion */
function escapeJs(str){
  if(!str) return '';
  return String(str).replace(/\\/g,'\\\\').replace(/'/g,"\\'");
}



/* ===== Chat + Messaging System (fixed + improvements) ===== */
// Persistent storage keys
const STORAGE_KEYS = {
  MESSAGES: 'profiles_messages_v1',
  UNREAD: 'profiles_unread_notifications_v1',
  READ: 'profiles_read_notifications_v1'
};

// Data structures
let messages = {}; // { uid: [ {from:'me'|'them', text, time, seen:boolean}, ... ] }
let unreadNotifications = []; // [{uid,name,lastMessage,time}, ...]
let readNotifications = [];
let currentChatUID = null;
let lastNotificationTab = 'unread'; // remember last notifications tab so we can return to it
let notificationTabBeforeChat = null; // stores which tab the user was on BEFORE opening chat

// Load from localStorage
function loadMessagingState() {
  try {
    const rawMsgs = localStorage.getItem(STORAGE_KEYS.MESSAGES);
    messages = rawMsgs ? JSON.parse(rawMsgs) : {};
  } catch(e) { messages = {}; }
  try {
    const rawUnread = localStorage.getItem(STORAGE_KEYS.UNREAD);
    unreadNotifications = rawUnread ? JSON.parse(rawUnread) : [];
  } catch(e){ unreadNotifications = []; }
  try {
    const rawRead = localStorage.getItem(STORAGE_KEYS.READ);
    readNotifications = rawRead ? JSON.parse(rawRead) : [];
  } catch(e){ readNotifications = []; }
  updateNotificationBadge();
}

// Save to localStorage
function saveMessagingState() {
  try { localStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(messages)); } catch(e){}
  try { localStorage.setItem(STORAGE_KEYS.UNREAD, JSON.stringify(unreadNotifications)); } catch(e){}
  try { localStorage.setItem(STORAGE_KEYS.READ, JSON.stringify(readNotifications)); } catch(e){}
  updateNotificationBadge();
}

// Utility to truncate preview
function previewText(t, len=80){
  if(!t) return '';
  return t.length>len ? t.slice(0,len-1)+'…' : t;
}

// Update bell badge (red circle)
function updateNotificationBadge() {
  const bellWrap = document.getElementById("bellWrap");
  if (!bellWrap) return;
  let count = unreadNotifications.length;
  let badge = bellWrap.querySelector(".bell-badge");
  if (count > 0) {
    if (!badge) {
      badge = document.createElement("span");
      badge.className = "bell-badge";
      bellWrap.appendChild(badge);
    }
    badge.textContent = count;
  } else {
    if (badge) badge.remove();
  }
}

let lastOpenedProfile = null; // store the profile you came from

// Open chat with a profile object {uid,name}
function openChat(profile) {
  if (!profile) return;

  // remember which profile you were viewing
  lastOpenedProfile = profile;

  // remember the notifications tab the user was on before opening chat
  notificationTabBeforeChat = lastNotificationTab || 'unread';
  currentChatUID = profile.uid;

  const nameEl = document.getElementById("chatWithName");
  if (nameEl) nameEl.textContent = profile.name || "Chat";

  // Hide top icons while chatting
  const menuWrap = document.getElementById("menuWrap");
  const bellWrap = document.getElementById("bellWrap");
  if (menuWrap) menuWrap.style.display = "none";
  if (bellWrap) bellWrap.style.display = "none";

  showPage("chatPage");
  renderChat();
}

// Back from chat
function backFromChat() {
  // restore top icons
  const menuWrap = document.getElementById("menuWrap");
  const bellWrap = document.getElementById("bellWrap");
  if (menuWrap) menuWrap.style.display = "inline-block";
  if (bellWrap) bellWrap.style.display = "inline-block";

  // If a profile was open before chat → go back there
  if (lastOpenedProfile) {
    openProfile(lastOpenedProfile); 
  } else {
    // fallback → go to notifications (like your old logic)
    showPage('notificationsPage');
    switchTab(lastNotificationTab || 'unread');
  }
}

// Render chat messages for currentChatUID
function renderChat() {
  const container = document.getElementById("chatMessages");
  if (!container) return;
  container.innerHTML = "";
  if (!currentChatUID) {
    container.textContent = "No conversation selected.";
    return;
  }
  if (!messages[currentChatUID]) messages[currentChatUID] = [];
  messages[currentChatUID].forEach(m => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.marginBottom = "8px";
    row.style.alignItems = "flex-end";
    // bubble
    const bubble = document.createElement("div");
    bubble.textContent = m.text;
    bubble.style.maxWidth = "70%";
    bubble.style.padding = "10px 14px";
    bubble.style.borderRadius = "14px";
    bubble.style.wordBreak = "break-word";
    bubble.style.boxShadow = "0 6px 18px rgba(2,6,23,0.06)";
    // time small
    const timeSpan = document.createElement("div");
    timeSpan.textContent = m.time || "";
    timeSpan.style.fontSize = "11px";
    timeSpan.style.marginTop = "6px";
    timeSpan.style.opacity = "0.8";
    timeSpan.style.fontWeight = "600";
    if (m.from === "me") {
      row.style.justifyContent = "flex-end";
      bubble.style.background = "linear-gradient(90deg,#0077ff,#2aa0ff)";
      bubble.style.color = "#fff";
      // seen indicator
      const wrapper = document.createElement("div");
      wrapper.style.textAlign = "right";
      wrapper.appendChild(bubble);
      const meta = document.createElement("div");
      meta.style.display = "flex";
      meta.style.justifyContent = "flex-end";
      meta.style.gap = "8px";
      meta.style.alignItems = "center";
      const seenSpan = document.createElement("span");
      seenSpan.style.fontSize = "12px";
      seenSpan.style.opacity = m.seen ? "1" : "0.35";
      seenSpan.style.color = m.seen ? "#34d399" : "#e2e8f0"; // green when seen
      seenSpan.textContent = m.seen ? "✓✓ Seen" : "✓ Sent";
      meta.appendChild(timeSpan);
      meta.appendChild(seenSpan);
      wrapper.appendChild(meta);
      row.appendChild(wrapper);
    } else {
      row.style.justifyContent = "flex-start";
      bubble.style.background = "#e5e7eb";
      bubble.style.color = "#111";
      const wrapper = document.createElement("div");
      wrapper.appendChild(bubble);
      const meta = document.createElement("div");
      meta.style.marginTop = "6px";
      meta.appendChild(timeSpan);
      wrapper.appendChild(meta);
      row.appendChild(wrapper);
    }
    container.appendChild(row);
  });
  // scroll to bottom
  container.scrollTop = container.scrollHeight;
}

// Send a message from "me" to the currently opened profile
function sendMessage() {
  const input = document.getElementById("chatInput");
  if (!input) return;
  const text = input.value.trim();
  if (!text || !currentChatUID) return;
  const time = (new Date()).toLocaleString();
  const msg = {from: "me", text, time, seen: false};
  if (!messages[currentChatUID]) messages[currentChatUID] = [];
  messages[currentChatUID].push(msg);
  // Update / create unread notification for this profile (it represents the message waiting to be read)
  const profileName = getProfileNameByUID(currentChatUID) || "Unknown";
  const existing = unreadNotifications.find(n => n.uid === currentChatUID);
  if (existing) {
    existing.lastMessage = text;
    existing.time = time;
  } else {
    unreadNotifications.push({uid: currentChatUID, name: profileName, lastMessage: text, time});
  }
  saveMessagingState();
  input.value = "";
  renderChat();
  // don't force switch to 'unread' — keep user's current context (requested change)
}

// Helper to get profile name by UID from profiles array
function getProfileNameByUID(uid) {
  try {
    const p = profiles.find(x => x.uid === uid);
    return p ? p.name : null;
  } catch(e){ return null; }
}

// Mark a notification as read (move to readNotifications) and mark messages as seen
function markAsReadByUID(uid) {
  const idx = unreadNotifications.findIndex(n => n.uid === uid);
  if (idx === -1) return;
  const n = unreadNotifications.splice(idx,1)[0];
  readNotifications.unshift(n);
  // mark 'me' messages as seen for that conversation
  if (messages[uid]) {
    messages[uid].forEach(m => { if (m.from === "me") m.seen = true; });
  }
  saveMessagingState();
  // after marking read, show the Read tab (so user can use Delete / Reply)
  switchTab('read');
}

// Delete a notification from the read list
function deleteReadNotification(uid){
  const i = readNotifications.findIndex(x => x.uid === uid);
  if(i === -1) return;
  if(!confirm('Delete this read notification?')) return;
  readNotifications.splice(i,1);
  saveMessagingState();
  switchTab('read');
}

// Render notifications for current tab (unread/read)
function switchTab(tab){
  // remember last selected tab so we can return to it after opening chat
  lastNotificationTab = tab;
  document.querySelectorAll(".tabs button").forEach(btn=>btn.classList.remove("active"));
  const tabBtn = document.getElementById("tab-"+tab);
  if (tabBtn) tabBtn.classList.add("active");
  const content=document.getElementById("notificationContent");
  if (!content) return;
  content.innerHTML="";
  if(tab==="unread"){
    if(unreadNotifications.length===0){ content.textContent="No unread notifications."; updateNotificationBadge(); return; }
    unreadNotifications.forEach(n=>{
      const box = document.createElement("div");
      box.style.background="#fff";
      box.style.margin="8px";
      box.style.padding="12px";
      box.style.borderRadius="10px";
      box.style.boxShadow="0 4px 12px rgba(0,0,0,0.08)";
      const title = document.createElement("div"); title.style.fontWeight="800"; title.textContent = n.name;
      const preview = document.createElement("div"); preview.style.marginTop = "6px"; preview.style.color="#374151"; preview.textContent = previewText(n.lastMessage,100);
      const time = document.createElement("div"); time.style.fontSize="12px"; time.style.color="#6b7280"; time.textContent = n.time;
      box.appendChild(title); box.appendChild(preview); box.appendChild(time);
      const actions = document.createElement("div"); actions.style.marginTop = "8px";
      const replyBtn = document.createElement("button"); replyBtn.className = "notif-btn reply-btn"; replyBtn.textContent = "Reply";
      replyBtn.onclick = function(){ openChat({uid: n.uid, name: n.name}); };
      const readBtn = document.createElement("button"); readBtn.className = "notif-btn read-btn"; readBtn.textContent = "Mark as Read";
      readBtn.onclick = function(){ markAsReadByUID(n.uid); };
      actions.appendChild(replyBtn); actions.appendChild(readBtn);
      box.appendChild(actions);
      content.appendChild(box);
    });
  } else if(tab==="read"){
    if(readNotifications.length===0){ content.textContent="No read notifications."; return; }
    readNotifications.forEach(n=>{
      const box = document.createElement("div");
      box.style.background="#fff";
      box.style.margin="8px";
      box.style.padding="12px";
      box.style.borderRadius="10px";
      box.style.boxShadow="0 4px 12px rgba(0,0,0,0.06)";
      const title = document.createElement("div"); title.style.fontWeight="800"; title.textContent = n.name;
      const preview = document.createElement("div"); preview.style.marginTop = "6px"; preview.style.color="#374151"; preview.textContent = previewText(n.lastMessage,100);
      const time = document.createElement("div"); time.style.fontSize="12px"; time.style.color="#6b7280"; time.textContent = n.time;
      box.appendChild(title); box.appendChild(preview); box.appendChild(time);

      // add Reply + Delete buttons for read items (new: user requested)
      const actions = document.createElement("div"); actions.style.marginTop = "8px";
      const replyBtn = document.createElement("button"); replyBtn.className = "notif-btn reply-btn"; replyBtn.textContent = "Reply";
      replyBtn.onclick = function(){ openChat({uid: n.uid, name: n.name}); };
      const delBtn = document.createElement("button"); delBtn.className = "notif-btn"; delBtn.style.background = "linear-gradient(90deg,#ef4444,#f97316)"; delBtn.style.color = "#fff"; delBtn.textContent = "Delete";
      delBtn.onclick = function(){ deleteReadNotification(n.uid); };
      actions.appendChild(replyBtn); actions.appendChild(delBtn);
      box.appendChild(actions);

      content.appendChild(box);
    });
  } else if(tab==="hire") {
    content.textContent = "No hire notifications.";
  } else {
    content.textContent="No "+tab+" notifications.";
  }
  updateNotificationBadge();
}

// Overwrite showMessage to open chat from Hire modal
function showMessage(){
  if(!currentOpenProfile) return;
  closeHireModal();
  openChat(currentOpenProfile);
}

// Initialize on load
loadMessagingState();
/* ===== End Chat System ===== */
/* Start on home */
showPage('home');

</script>

<!-- BEGIN: Added script — Simulate Profile-Owner Replies & Improved Notification Routing -->
<script>
/* Enhancements: profile-owner reply simulation and improved notification routing */

/* persist/remember a "myUID" for the current browser user (set when profile is saved) */
let myUID = null;
try {
  const s = localStorage.getItem('profiles_my_uid_v1');
  if (s) myUID = isNaN(s) ? s : Number(s);
} catch(e){ myUID = null; }

/* ensure we capture the profile save action and store myUID after the existing profile form runs */
(function(){
  const form = document.getElementById('profileForm');
  if (!form) return;
  form.addEventListener('submit', function(){
    // after the original submit handler runs it sets myProfile — wait a bit and capture it
    setTimeout(()=>{
      try {
        if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
          myUID = myProfile.uid;
          localStorage.setItem('profiles_my_uid_v1', String(myUID));
        }
      } catch(e){}
    }, 60);
  });
})();

/* override sendMessage so messages include fromUid/toUid and notifications go to the recipient */
(function(){
  const originalSend = window.sendMessage;
  window.sendMessage = function(){
    const input = document.getElementById("chatInput");
    if (!input) return;
    const text = input.value.trim();
    if (!text || !currentChatUID) return;
    const time = (new Date()).toLocaleString();
    if (!messages[currentChatUID]) messages[currentChatUID] = [];
    const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
    const msg = {from: "me", text: text, time: time, seen: false, fromUid: fromUid, toUid: currentChatUID};
    messages[currentChatUID].push(msg);

    // Update / create unread notification FOR THE RECIPIENT (simulate that the recipient has an unread)
    const profileName = getProfileNameByUID(currentChatUID) || "Unknown";
    const existing = unreadNotifications.find(n => n.uid === currentChatUID);
    if (existing) {
      existing.lastMessage = text;
      existing.time = time;
    } else {
      unreadNotifications.push({uid: currentChatUID, name: profileName, lastMessage: text, time});
    }
    saveMessagingState();
    input.value = "";
    renderChat();
  };
})();

/* Function to simulate a reply originating from the profile owner (this will add a message 'from them' and create
   a simulated unread notification FOR THE SENDER — stored in localStorage under 'profiles_unread_for_others_v1') */
function simulateProfileOwnerReply(uid, name) {
  const text = prompt('Type reply from profile owner to send to ' + (name || uid) + ':');
  if (!text) return;
  const time = (new Date()).toLocaleString();
  if (!messages[uid]) messages[uid] = [];
  const ownerUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'owner';
  const msg = {from: "them", text: text, time: time, seen: false, fromUid: ownerUid, toUid: uid};
  messages[uid].push(msg);

  // create/update the simulated unread for the sender (stored separately so it represents "the other user's unread")
  try {
    const key = 'profiles_unread_for_others_v1';
    const raw = localStorage.getItem(key);
    const otherUnread = raw ? JSON.parse(raw) : [];
    const existing = otherUnread.find(n => n.uid === uid);
    if (existing) {
      existing.lastMessage = text;
      existing.time = time;
    } else {
      otherUnread.push({uid: uid, name: name || getProfileNameByUID(uid) || 'Unknown', lastMessage: text, time});
    }
    localStorage.setItem(key, JSON.stringify(otherUnread));
  } catch(e){ console.warn('simulateProfileOwnerReply storage failed', e); }

  saveMessagingState();
  alert('Reply sent as profile owner. Simulated unread for the sender created (localStorage key: profiles_unread_for_others_v1).');
}

/* Decorate the Notifications UI after it renders so each Unread box has a "Reply as Owner" button (which uses the function above).
   We do this by wrapping the existing switchTab function so the original behavior is preserved. */
(function(){
  const origSwitch = window.switchTab;
  window.switchTab = function(tab){
    origSwitch(tab);
    if (tab !== 'unread') return;
    // small delay to ensure DOM for notifications is built
    setTimeout(()=>{
      const content = document.getElementById('notificationContent');
      if (!content) return;
      // find all top-level notification boxes (heuristic: immediate child divs)
      const boxes = Array.from(content.children).filter(ch => ch.nodeType === 1);
      boxes.forEach(box => {
        // avoid adding the button twice
        if (box.querySelector('.owner-reply-btn')) return;
        // find the title text (first child div)
        const titleDiv = box.querySelector('div');
        const titleText = titleDiv ? titleDiv.textContent.trim() : '';
        // create button
        const ownerBtn = document.createElement('button');
        ownerBtn.className = 'notif-btn owner-reply-btn';
        ownerBtn.style.background = 'linear-gradient(90deg,#8b5cf6,#a78bfa)';
        ownerBtn.style.color = '#fff';
        ownerBtn.style.marginLeft = '6px';
        ownerBtn.textContent = 'Reply as Owner';
        ownerBtn.title = 'Simulate a reply from the profile owner — will create an unread notification for the sender (simulated).';
        ownerBtn.onclick = function(){
          // Find the corresponding unreadNotifications entry by matching name or uid
          const cand = unreadNotifications.find(n => (n.name === titleText) || String(n.uid) === titleText);
          const uid = cand ? cand.uid : null;
          const name = cand ? cand.name : titleText;
          if (!uid) {
            alert('Could not determine UID for this notification. Try opening the chat and reply normally.');
            return;
          }
          simulateProfileOwnerReply(uid, name);
        };
        // append into the actions container if found (heuristic: last child)
        const actions = box.querySelector('div:nth-child(4)') || box;
        actions.appendChild(ownerBtn);
      });
    }, 60);
  };
})();

/* Optional helper: show the simulated "other users' unread" (useful for debugging/testing)
   This does not modify the original UI but can be called from the console:
   window.showSimulatedOtherUnread();
*/
function showSimulatedOtherUnread(){
  try {
    const key = 'profiles_unread_for_others_v1';
    const raw = localStorage.getItem(key);
    const otherUnread = raw ? JSON.parse(raw) : [];
    if (!otherUnread.length) { alert('No simulated unread entries for other users.'); return; }
    let out = 'Simulated unread entries for OTHER users:\\n\\n';
    otherUnread.forEach(n => { out += `${n.name} (uid: ${n.uid}) — ${n.lastMessage} — ${n.time}\\n`; });
    alert(out);
  } catch(e){ alert('Unable to read simulated unread storage.'); }
}

/* end added script */
</script>
<!-- END: Added script -->


<!-- BEGIN: Assistant-added: Hire Complete + OTP verification + Hire count -->
<script>
(function(){

const OTP_STORAGE_KEY = 'profiles_pending_otp_v1';
const PROFILES_PERSIST_KEY = 'profiles_data_v1';

// load profiles from storage if present (merge with in-memory 'profiles' variable)
try {
  const raw = localStorage.getItem(PROFILES_PERSIST_KEY);
  if (raw) {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) {
      // merge without overwriting existing in-memory profiles (keep latest by uid)
      parsed.forEach(storedP => {
        const idx = profiles.findIndex(p => String(p.uid) === String(storedP.uid));
        if (idx === -1) profiles.push(storedP);
        else profiles[idx] = Object.assign({}, profiles[idx], storedP);
      });
    }
  }
} catch(e){ console.warn('Failed to load persisted profiles:', e); }

function saveProfilesToStorage() {
  try { localStorage.setItem(PROFILES_PERSIST_KEY, JSON.stringify(profiles)); } catch(e){ console.warn(e); }
}

// ensure hireCount exists for all profiles
(function ensureHireCounts(){
  let changed = false;
  profiles.forEach(p => { if (typeof p.hireCount === 'undefined') { p.hireCount = 0; changed = true; } });
  if (changed) saveProfilesToStorage();
})();

// after profile form submit (original script writes myProfile), make sure myProfile has hireCount and persist
const profileForm = document.getElementById('profileForm');
if (profileForm) {
  profileForm.addEventListener('submit', function(){
    setTimeout(()=>{
      try {
        if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
          if (typeof myProfile.hireCount === 'undefined') myProfile.hireCount = 0;
          const idx = profiles.findIndex(p => String(p.uid) === String(myProfile.uid));
          if (idx !== -1) profiles[idx] = myProfile;
          else profiles.push(myProfile);
          saveProfilesToStorage();
          localStorage.setItem('profiles_my_uid_v1', String(myProfile.uid));
          myUID = myProfile.uid;
        }
      } catch(e){ console.warn(e); }
    }, 80);
  });
}

// override openProfile to display hires count (decorate existing function)
if (window.openProfile) {
  const origOpenProfile = window.openProfile;
  window.openProfile = function(p){
    try { origOpenProfile(p); } catch(e){ console.warn('orig openProfile failed', e); }
    // ensure profile object has hireCount
    const stored = profiles.find(x => String(x.uid) === String(p.uid)) || p;
    if (typeof stored.hireCount === 'undefined') stored.hireCount = 0;
    // create or update hires element
    let el = document.getElementById('profileHireCount');
    const container = document.querySelector('.profile-header .profile-head-info');
    if (!container) return;
    if (!el) {
      el = document.createElement('div');
      el.id = 'profileHireCount';
      el.style.marginTop = '8px';
      el.style.fontWeight = '800';
      el.style.color = '#ffd6e0';
      container.appendChild(el);
    }
    el.textContent = 'Hires: ' + (stored.hireCount || 0);
  };
}

// Add "Hire Complete" button to chat header (next to back button)
(function addChatHireButton(){
  const header = document.querySelector('#chatPage > div');
  if (!header) return;
  // avoid duplicates
  if (header.querySelector('.hire-complete-chat-btn')) return;
  const hireBtn = document.createElement('button');
  hireBtn.textContent = 'Hire Complete';
  hireBtn.className = 'hire-complete-chat-btn';
  hireBtn.style.marginLeft = '8px';
  hireBtn.style.padding = '8px 12px';
  hireBtn.style.borderRadius = '8px';
  hireBtn.style.border = 'none';
  hireBtn.style.cursor = 'pointer';
  hireBtn.style.fontWeight = '800';
  hireBtn.style.background = 'linear-gradient(90deg,#ef4444,#f97316)';
  hireBtn.style.color = '#fff';
  hireBtn.onclick = function(){
    if (!currentChatUID) { alert('Open a chat first.'); return; }
    const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
    const toUid = currentChatUID;
    const toName = document.getElementById('chatWithName')?.textContent || '';
    sendHireOTP(fromUid, toUid, toName);
  };
  header.appendChild(hireBtn);
})();

// Decorate notifications unread boxes with "Hire Complete" button
(function wrapSwitchTabForHire(){
  if (!window.switchTab) return;
  const orig = window.switchTab;
  window.switchTab = function(tab){
    orig(tab);
    if (tab !== 'unread') return;
    setTimeout(()=>{
      const content = document.getElementById('notificationContent');
      if (!content) return;
      const boxes = Array.from(content.children).filter(ch => ch.nodeType === 1);
      boxes.forEach(box => {
        if (box.querySelector('.hire-complete-notif-btn')) return;
        // attempt to detect uid from the unreadNotifications array by matching title
        const titleDiv = box.querySelector('div');
        const titleText = titleDiv ? titleDiv.textContent.trim() : '';
        const cand = unreadNotifications.find(n => (n.name === titleText) || String(n.uid) === titleText);
        const uid = cand ? cand.uid : null;
        if (!uid) return;
        const actions = box.querySelector('div:nth-child(4)') || box;
        const btn = document.createElement('button');
        btn.className = 'hire-complete-notif-btn notif-btn';
        btn.style.background = 'linear-gradient(90deg,#ef4444,#f97316)';
        btn.style.color = '#fff';
        btn.style.marginLeft = '6px';
        btn.textContent = 'Hire Complete';
        btn.onclick = function(){
          const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
          sendHireOTP(fromUid, uid, cand.name);
        };
        actions.appendChild(btn);
      });
    }, 60);
  };
})();

// sendHireOTP: create pending OTP record in localStorage and notify
function sendHireOTP(fromUid, toUid, toName) {
  try {
    const otp = String(Math.floor(100000 + Math.random()*900000));
    const time = (new Date()).toISOString();
    const rec = { otp: otp, fromUid: String(fromUid), toUid: String(toUid), time: time, toName: toName || '' };
    let arr = [];
    try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
    arr.push(rec);
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(arr));
    // dispatch a same-tab event (so the recipient tab in same window will also show prompt)
    window.dispatchEvent(new CustomEvent('profiles-otp-sent', {detail: rec}));
    // For testing/development we show OTP to the sender — remove in production
    // show non-blocking OTP box instead of alert
        try{ document.getElementById('otpSentBox')?.remove(); }catch(e){}
        const otpBox = document.createElement('div');
        otpBox.id = 'otpSentBox';
        otpBox.className = 'otp-card';
        otpBox.style.position = 'fixed';
        otpBox.style.right = '20px';
        otpBox.style.bottom = '20px';
        otpBox.style.zIndex = 100000;
        otpBox.innerHTML = `
          <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
            <div>
              <div style="font-weight:800">OTP sent to ${escapeHtml(toName || toUid)}</div>
              <div style="margin-top:6px;font-weight:900;font-family:monospace;">Code (testing): ${otp}</div>
            </div>
            <div>
              <button onclick="document.getElementById('otpSentBox')?.remove()" style="padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:800;background:linear-gradient(90deg,#ef4444,#f97316);color:#fff;">Close</button>
            </div>
          </div>`;
        document.body.appendChild(otpBox);
  } catch(e){ console.warn('sendHireOTP failed', e); alert('Failed to send OTP'); }
}

// showPendingOTPModalForMe: if there's a pending OTP for myUID, prompt to verify
function showPendingOTPModalForMe() {
  const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
  if (!myuid) return;
  let arr = [];
  try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
  const pending = arr.find(r => String(r.toUid) === String(myuid));
  if (!pending) return;
  // avoid duplicate modal
  if (document.getElementById('otpVerifyModal')) return;
  // build modal
  const modal = document.createElement('div');
  modal.id = 'otpVerifyModal';
  modal.className = 'modal open';
  modal.style.zIndex = 99998;
  modal.innerHTML = `
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="otpTitle">
      <button class="modal-close" onclick="document.getElementById('otpVerifyModal')?.remove()">✕</button>
      <h4 id="otpTitle">Verify Hire OTP</h4>
      <p class="note">Someone marked a hire complete for your profile. Enter the 6-digit OTP sent to you to confirm.</p>
      <div style="margin-top:8px;">
        <input id="otpInputField" placeholder="Enter 6-digit OTP" style="width:100%; padding:10px; font-size:16px; border-radius:8px; border:1px solid #e8eefb;">
      </div>
      <div style="margin-top:10px; display:flex; gap:8px;">
        <button id="otpVerifyBtn" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:linear-gradient(90deg,#06b6d4,#0ea5a6); color:#fff;">Verify</button>
        <button id="otpCancelBtn" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:#eef2ff; color:#111;">Cancel</button>
      </div>
      <div id="otpNote" class="note"></div>
    </div>
  `;
  document.body.appendChild(modal);
  document.getElementById('otpCancelBtn').onclick = function(){ modal.remove(); };
  document.getElementById('otpVerifyBtn').onclick = function(){ verifyOTPForMe(document.getElementById('otpInputField').value.trim()); };
}

// verifyOTPForMe: check localStorage pending and validate; if OK increment hire count and remove pending otp
function verifyOTPForMe(value) {
  const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
  if (!myuid) return;
  try {
    let arr = [];
    try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
    const idx = arr.findIndex(r => String(r.toUid) === String(myuid) && String(r.otp) === String(value));
    if (idx === -1) {
      const note = document.getElementById('otpNote');
      if (note) note.textContent = 'Incorrect OTP. Please try again.';
      return;
    }
    const rec = arr.splice(idx,1)[0];
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(arr));
    // increment hireCount on associated profile (the owner)
    const pidx = profiles.findIndex(p => String(p.uid) === String(myuid));
    if (pidx !== -1) {
      profiles[pidx].hireCount = (profiles[pidx].hireCount || 0) + 1;
    } else {
      profiles.push({ uid: myuid, name: rec.toName || 'Profile', hireCount: 1 });
    }
    saveProfilesToStorage();
    // update UI if open profile is the same user
    const el = document.getElementById('profileHireCount');
    if (el) {
      const cnt = (profiles.find(p => String(p.uid) === String(myuid)) || {}).hireCount || 0;
      el.textContent = 'Hires: ' + cnt;
    }
    // feedback
    alert('OTP verified. Hire marked complete — hire count incremented.');
    // remove modal
    document.getElementById('otpVerifyModal')?.remove();
    // push a small read notification for record
    readNotifications.unshift({ uid: myuid, name: getProfileNameByUID(myuid) || 'Profile', lastMessage: 'Hire completed (verified)', time: new Date().toLocaleString() });
    saveMessagingState();
    switchTab('read');
  } catch(e){ console.warn(e); }
}

// react to storage events (other tabs)
window.addEventListener('storage', function(e){
  if (e.key === OTP_STORAGE_KEY) setTimeout(()=> showPendingOTPModalForMe(), 60);
});

// react to same-tab custom event
window.addEventListener('profiles-otp-sent', function(ev){ setTimeout(()=> showPendingOTPModalForMe(), 60); });

// run on load (in case OTP was stored while tab was inactive)
setTimeout(()=> showPendingOTPModalForMe(), 120);

})(); // end wrapper
</script>
<!-- END: Assistant-added: Hire Complete + OTP verification + Hire count -->


<!-- BEGIN: Leaderboard, Ratings & UID Integration -->
<div id="leaderboardPage" class="page" style="display:none; padding-top:28px;">
  <h2 style="text-align:center; margin-top:0;">Leaderboards</h2>
  <div class="leaderboard-tabs" role="tablist" aria-label="Leaderboards">
    <button id="lb-tab-hired" class="active" onclick="displayLeaderboard('hired')">Top 10 Most Hired</button>
    <button id="lb-tab-alltime" onclick="displayLeaderboard('alltime')">Top 10 All Time</button>
    <button id="lb-tab-rated" onclick="displayLeaderboard('rated')">Top 10 Most Rated</button>
  </div>
  <div id="leaderboardList" class="leaderboard-list" aria-live="polite"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<script>
/* Leaderboard + Ratings + UID integration script (appended) */
(function(){
  // safety: ensure global profiles exists
  if(typeof profiles === 'undefined') window.profiles = window.profiles || [];
  // helper: ensure fields
  function ensureFields(){
    profiles.forEach(p=>{
      if(typeof p.hireCount === 'undefined') p.hireCount = 0;
      if(typeof p.allTimeHires === 'undefined') p.allTimeHires = p.hireCount || 0;
      if(typeof p.ratingSum === 'undefined') p.ratingSum = 0;
      if(typeof p.ratingCount === 'undefined') p.ratingCount = 0;
    });
  }
  // compute rating %
  function ratingPctOf(p){ return p.ratingCount ? Math.round((p.ratingSum / (p.ratingCount * 5)) * 100) : 0; }

  // create menu item in 3-dots dropdown
  try{
    const dd = document.getElementById('menuDropdown');
    if(dd && !document.getElementById('menuDropdownLeaderboard')){
      const el = document.createElement('div');
      el.id = 'menuDropdownLeaderboard';
      el.textContent = 'Leaderboard';
      el.style.cursor = 'pointer';
      el.onclick = function(){ showPage('leaderboardPage'); displayLeaderboard('hired'); };
      dd.appendChild(el);
    }
  }catch(e){ console.warn('menuDropdown append failed',e); }

  // display leaderboard
  window.displayLeaderboard = function(type){
    ensureFields();
    // tab active classes
    document.querySelectorAll('.leaderboard-tabs button').forEach(b=>b.classList.remove('active'));
    if(type==='hired') document.getElementById('lb-tab-hired').classList.add('active');
    if(type==='alltime') document.getElementById('lb-tab-alltime').classList.add('active');
    if(type==='rated') document.getElementById('lb-tab-rated').classList.add('active');

    const list = document.getElementById('leaderboardList');
    list.innerHTML = '';
    // compute rating pct for sorting
    const arr = profiles.map(p=>{
      return Object.assign({}, p, { ratingPct: ratingPctOf(p) });
    });
    if(type === 'hired'){
      arr.sort((a,b)=> (b.hireCount - a.hireCount) || (b.ratingPct - a.ratingPct) );
    } else if(type === 'alltime'){
      // All-time uses allTimeHires (cumulative) then rating%
      arr.sort((a,b)=> (b.allTimeHires - a.allTimeHires) || (b.ratingPct - a.ratingPct) );
    } else {
      // rated
      arr.sort((a,b)=> (b.ratingPct - a.ratingPct) || (b.hireCount - a.hireCount) );
    }
    const top = arr.slice(0,10);

    // compute rank numbers but keep same rank for ties (primary + secondary equal)
    let lastPrimary = null, lastSecondary = null, lastRank = 0;
    top.forEach((p, i)=>{
      const primary = (type==='alltime') ? (p.allTimeHires||0) : (type==='rated' ? p.ratingPct : (p.hireCount||0));
      const secondary = p.ratingPct || 0;
      let rank = i+1;
      if(i>0 && primary===lastPrimary && secondary===lastSecondary) rank = lastRank;
      lastPrimary = primary; lastSecondary = secondary; lastRank = rank;
      const card = document.createElement('div'); card.className = 'leader-card';
      // rank box
      const rankBox = document.createElement('div'); rankBox.className = 'leader-rank';
      if(rank===1) rankBox.classList.add('leader-gold');
      else if(rank===2) rankBox.classList.add('leader-silver');
      else if(rank===3) rankBox.classList.add('leader-bronze');
      rankBox.textContent = rank;
      // info block
      const info = document.createElement('div'); info.className = 'leader-info';
      const nameHtml = document.createElement('div');
      const strong = document.createElement('strong'); strong.textContent = p.name || ('UID ' + (p.uid || '—'));
      nameHtml.appendChild(strong);
      const uid = document.createElement('div'); uid.className='uid'; uid.textContent = 'UID: ' + (p.uid || '—');
      nameHtml.appendChild(uid);
      const meta = document.createElement('div'); meta.className='meta';
      // choose fields shown per leaderboard type
      if(type==='hired'){
        meta.textContent = 'Hires: ' + (p.hireCount||0);
      } else if(type==='alltime'){
        meta.textContent = 'All-Time Hires: ' + (p.allTimeHires||0) + ' · Rating: ' + (p.ratingPct||0) + '%';
      } else {
        meta.textContent = 'Rating: ' + (p.ratingPct||0) + '%';
      }
      info.appendChild(nameHtml);
      info.appendChild(meta);

      // append without open button (leaderboard should not show Open)
      card.appendChild(rankBox);
      card.appendChild(info);
      list.appendChild(card);
    });
    // ensure we are on leaderboard page
    showPage('leaderboardPage');
  };

  // Override openProfile to inject rating UI (preserve original behavior)
  if(window.openProfile){
    const origOpen = window.openProfile;
    window.openProfile = function(p){
      try{ origOpen(p); } catch(e){ console.warn('orig openProfile error', e); }
      try{
        ensureFields();
        const container = document.querySelector('.profile-header .profile-head-info');
        if(!container) return;
        // remove previous rating container if exists
        const prev = document.getElementById('profileRatingContainer');
        if(prev) prev.remove();

        const rc = document.createElement('div'); rc.id='profileRatingContainer'; rc.className='profile-rating';
        // star row (select-only, no auto submit)
        const starRow = document.createElement('div'); starRow.className='rating-stars';
        const selected = {value:0};
        for(let i=1;i<=5;i++){
          const s = document.createElement('span');
          s.innerHTML = '★';
          s.dataset.value = i;
          s.style.userSelect = 'none';
          s.onclick = function(){
            // highlight up to this star
            selected.value = Number(this.dataset.value);
            const stars = starRow.querySelectorAll('span');
            stars.forEach(st => {
              if(Number(st.dataset.value) <= selected.value) st.classList.add('active');
              else st.classList.remove('active');
            });
            // enable submit
            submitBtn.disabled = false;
          };
          starRow.appendChild(s);
        }
        rc.appendChild(starRow);

        // submit button (disabled until selection)
        const submitBtn = document.createElement('button');
        submitBtn.textContent = 'Submit Rating';
        submitBtn.style.marginTop = '8px';
        submitBtn.style.padding = '8px 12px';
        submitBtn.style.borderRadius = '8px';
        submitBtn.style.border = 'none';
        submitBtn.style.cursor = 'pointer';
        submitBtn.style.fontWeight = '800';
        submitBtn.style.background = 'linear-gradient(90deg,#06b6d4,#0ea5a6)';
        submitBtn.style.color = '#fff';
        submitBtn.disabled = true;
        rc.appendChild(submitBtn);

        // rating bar container (hidden until after submit or if already voted)
        const barWrap = document.createElement('div');
        barWrap.style.marginTop = '10px';
        barWrap.style.display = 'block';
        const barOuter = document.createElement('div');
        barOuter.style.width = '100%';
        barOuter.style.height = '14px';
        barOuter.style.background = '#e6eefc';
        barOuter.style.borderRadius = '10px';
        barOuter.style.overflow = 'hidden';
        const barInner = document.createElement('div');
        barInner.style.height = '100%';
        barInner.style.width = '0%';
        barInner.style.transition = 'width 450ms ease';
        barInner.style.background = 'linear-gradient(90deg,#fbbf24,#f97316)';
        barOuter.appendChild(barInner);
        const pctText = document.createElement('div');
        pctText.style.marginTop = '8px';
        pctText.style.fontWeight = '800';
        pctText.style.color = '#0077ff';
        barWrap.appendChild(barOuter);
        barWrap.appendChild(pctText);
        rc.appendChild(barWrap);

        container.appendChild(rc);

        // helper to render rating bar based on profile
        function renderRatingResult(profileObj, hideControls){
          const idx = profiles.findIndex(x=>String(x.uid)===String(profileObj.uid));
          const pct = idx===-1 ? 0 : Math.round(((profiles[idx].ratingSum || 0) / ((profiles[idx].ratingCount||0) * 5)) * 100) || 0;
          // show or hide the selection controls depending on whether the user already voted
          if (hideControls) {
            starRow.style.display = 'none';
            submitBtn.style.display = 'none';
          } else {
            starRow.style.display = '';
            submitBtn.style.display = '';
          }
          // rating bar always visible
          barWrap.style.display = 'block';
          // animate bar
          setTimeout(()=>{ barInner.style.width = pct + '%'; }, 50);
          pctText.textContent = 'Ratings: ' + pct + '%';
        }

        // handle submit click
        submitBtn.onclick = function(){
          const score = Number(selected.value || 0);
          if(!score || !p || typeof p.uid === 'undefined'){ alert('Select stars to submit.'); return; }
          // find or create profile entry
          const idx = profiles.findIndex(x=>String(x.uid)===String(p.uid));
          if(idx===-1){
            const newP = { uid: p.uid, name: p.name || ('UID '+p.uid), hireCount: p.hireCount||0, allTimeHires: p.allTimeHires||0, ratingSum: score, ratingCount: 1 };
            profiles.push(newP);
          } else {
            profiles[idx].ratingSum = (profiles[idx].ratingSum || 0) + score;
            profiles[idx].ratingCount = (profiles[idx].ratingCount || 0) + 1;
          }
          // persist profiles
          try{ if(typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); }catch(e){}
          // mark voted locally to prevent re-vote
          const votedKey = 'profiles_votes_v1';
          let voted = [];
          try{ voted = JSON.parse(localStorage.getItem(votedKey) || '[]'); }catch(e){ voted = []; }
          voted.push(String(p.uid)); localStorage.setItem(votedKey, JSON.stringify(voted));
          // show result bar
          renderRatingResult(p, true);
          // refresh leaderboards if visible
          try{ if(document.getElementById('leaderboardPage') && document.getElementById('leaderboardPage').style.display!=='none') displayLeaderboard(document.querySelector('.leaderboard-tabs button.active')?.id?.includes('hired') ? 'hired' : (document.querySelector('.leaderboard-tabs button.active')?.id?.includes('alltime') ? 'alltime' : 'rated')); }catch(e){}
        };

        // If already voted -> show bar immediately
        const votedKey = 'profiles_votes_v1';
        let voted = [];
        try{ voted = JSON.parse(localStorage.getItem(votedKey) || '[]'); }catch(e){ voted = []; }
        renderRatingResult(p, voted.includes(String(p.uid)));}catch(e){ console.warn('rating widget error', e); }
    };
  }  // Wrap verifyOTPForMe to also increment allTimeHires (keeps original behavior)
  if(window.verifyOTPForMe){
    const origVerify = window.verifyOTPForMe;
    window.verifyOTPForMe = function(val){
      try{ origVerify(val); } catch(e){ console.warn('orig verifyOTP failed',e); }
      try{
        const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
        if(!myuid) return;
        ensureFields();
        const idx = profiles.findIndex(p=> String(p.uid) === String(myuid));
        if(idx !== -1){
          profiles[idx].allTimeHires = (profiles[idx].allTimeHires || 0) + 1;
        } else {
          // if profile not present, create minimal entry
          profiles.push({ uid: myuid, name: ('UID '+myuid), hireCount: 0, allTimeHires: 1, ratingSum:0, ratingCount:0 });
        }
        // persist
        try{ if(typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); }catch(e){}
        // update open profile UI if it's the same profile
        try{
          const el = document.getElementById('profileHireCount');
          if(el){
            const cnt = (profiles.find(p => String(p.uid) === String(myuid)) || {}).hireCount || 0;
            el.textContent = 'Hires: ' + cnt;
          }
        }catch(e){}
      }catch(e){ console.warn('post-verify wrapper error', e); }
    };
  }

  // Expose a helper to force refresh leaderboards externally
  window.refreshLeaderboards = function(){ if(document.getElementById('leaderboardPage') && document.getElementById('leaderboardPage').style.display!=='none'){ const active = document.querySelector('.leaderboard-tabs button.active'); if(active) { if(active.id.includes('hired')) displayLeaderboard('hired'); else if(active.id.includes('alltime')) displayLeaderboard('alltime'); else displayLeaderboard('rated'); } } };

  // run an initial ensure
  ensureFields();
})();
</script>
<!-- END: Leaderboard, Ratings & UID Integration -->





<!-- FULL Firebase integration: profiles, savedProfiles, chat, notifications, leaderboard, ratings, hireCount -->
<script>
(function(){
  try {
    if(typeof firebase === 'undefined' || !firebase.firestore){
      console.warn('Firebase SDK not found. Ensure Firebase scripts are included earlier.');
      return;
    }
    const db = firebase.firestore();
    const FieldValue = firebase.firestore.FieldValue;

    // read or set myUID (profile owner identifier) from localStorage
    let myUID = null;
    try { myUID = localStorage.getItem('profiles_my_uid_v1'); } catch(e){ myUID = null; }
    if(myUID === 'null') myUID = null;

    // helper to convert any uid to string
    function uidStr(u){ return (typeof u === 'number') ? String(u) : (u || ''); }

    // --- Load my profile on startup (if saved) and update the Create -> Manage button ---
    async function loadMyProfileFromFirestore() {
      try {
        myUID = myUID || localStorage.getItem('profiles_my_uid_v1');
        if(!myUID) {
          // no local profile; ensure UI still reflects that
          document.getElementById('profileBtn').textContent = 'Create a Profile';
          return;
        }
        const doc = await db.collection('profiles').doc(uidStr(myUID)).get();
        if(!doc.exists) {
          console.log('No remote profile found for myUID, clearing local reference.');
          // keep local myProfile if exists but don't falsely show Manage if not present remotely
          return;
        }
        myProfile = doc.data();
        // ensure local profiles array contains it
        const idx = profiles.findIndex(p => String(p.uid) === String(myProfile.uid));
        if(idx === -1) profiles.push(myProfile); else profiles[idx] = myProfile;
        // update UI to Manage Profile
        try {
          document.getElementById('profileBtn').textContent = 'Manage Profile';
        } catch(e){}
        console.log('Loaded my profile from Firestore', myProfile);
      } catch(e){ console.error('loadMyProfileFromFirestore failed', e); }
    }

    // --- Save profile to Firestore (called after form submit) ---
    async function saveProfileToFirebase(profile) {
      try {
        if(!profile || !profile.uid) return;
        await db.collection('profiles').doc(String(profile.uid)).set(profile, {merge: true});
        console.log('Profile saved to Firestore:', profile.uid);
        // if this is the current user's profile, persist myUID locally
        if(String(profile.uid) === String(myProfile?.uid)) {
          myUID = String(profile.uid);
          try { localStorage.setItem('profiles_my_uid_v1', myUID); } catch(e){}
          // ensure a user doc exists for savedProfiles etc
          await db.collection('users').doc(myUID).set({createdAt: new Date().toISOString()}, {merge:true});
          try { document.getElementById('profileBtn').textContent = 'Manage Profile'; } catch(e){}
        }
      } catch(err){ console.error('saveProfileToFirebase error', err); }
    }

    // --- Real-time loading of profiles into 'profiles' array ---
    let profilesUnsubscribe = null;
    function loadProfilesRealtime(){
      try {
        if(profilesUnsubscribe) profilesUnsubscribe();
        profilesUnsubscribe = db.collection('profiles').onSnapshot(snap => {
          profiles = snap.docs.map(d => d.data());
          // ensure hireCount and rating fields exist locally
          profiles.forEach(p => { if(typeof p.hireCount === 'undefined') p.hireCount = 0; if(typeof p.ratingAvg === 'undefined') p.ratingAvg = 0; if(typeof p.ratingCount === 'undefined') p.ratingCount = 0; });
          displayProfiles();
          // also update leaderboard if that exists
          if(window.loadLeaderboard) window.loadLeaderboard();
        }, err => console.error('profiles onSnapshot error', err));
      } catch(e){ console.error('loadProfilesRealtime failed', e); }
    }

    // --- Persist savedProfiles for current user in users/{myUID}.savedProfiles ---
    async function persistSavedProfilesToServer(){
      try {
        if(!myUID) { localStorage.setItem('profiles_saved_v1', JSON.stringify(savedProfiles)); return; }
        const uDoc = db.collection('users').doc(uidStr(myUID));
        const uids = savedProfiles.map(s => s.uid);
        await uDoc.set({ savedProfiles: uids }, {merge:true});
      } catch(e){ console.warn('persistSavedProfilesToServer failed', e); }
    }
    async function loadSavedProfilesForMe(){
      try {
        savedProfiles = savedProfiles || [];
        if(!myUID) {
          // try localStorage fallback
          const raw = localStorage.getItem('profiles_saved_v1');
          if(raw) {
            savedProfiles = JSON.parse(raw);
          }
          return;
        }
        const udoc = await db.collection('users').doc(uidStr(myUID)).get();
        if(!udoc.exists) { savedProfiles = []; return; }
        const data = udoc.data();
        if(Array.isArray(data.savedProfiles)) {
          // convert uids to profile objects if present in local profiles array
          const items = [];
          data.savedProfiles.forEach(suid => {
            const found = profiles.find(p => String(p.uid) === String(suid));
            if(found) items.push(found);
            else items.push({ uid: suid }); // placeholder; display will try to open and lazy-load
          });
          savedProfiles = items;
        } else {
          savedProfiles = [];
        }
        // sync local storage too
        try { localStorage.setItem('profiles_saved_v1', JSON.stringify(savedProfiles)); } catch(e){}
      } catch(e){ console.warn('loadSavedProfilesForMe failed', e); }
    }

    // Monkey-patch the existing saveProfile function so it persists to Firestore when possible
    if(window.saveProfile) {
      const originalSaveProfile = window.saveProfile;
      window.saveProfile = function(p){
        try {
          originalSaveProfile(p);
        } catch(e){ console.warn('original saveProfile error', e); }
        // After local update, persist for logged-in creator
        setTimeout(()=> persistSavedProfilesToServer(), 60);
      };
    }

    // Also ensure toggleSaveFromOpen will persist (it calls saveProfile already)
    // If the user creates a profile, make sure we save to server
    // Hook into the profile form submission to call saveProfileToFirebase (safeguarded earlier code may already do this)
    try {
      const form = document.getElementById('profileForm');
      if(form) {
        form.addEventListener('submit', function(ev){
          setTimeout(()=>{
            try {
              if(typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
                // ensure hireCount/rating fields exist
                if(typeof myProfile.hireCount === 'undefined') myProfile.hireCount = 0;
                if(typeof myProfile.ratingAvg === 'undefined') myProfile.ratingAvg = 0;
                if(typeof myProfile.ratingCount === 'undefined') myProfile.ratingCount = 0;
                saveProfileToFirebase(myProfile);
                // also persist to local profiles array & storage
                const idx = profiles.findIndex(x => String(x.uid) === String(myProfile.uid));
                if(idx === -1) profiles.push(myProfile); else profiles[idx] = myProfile;
                try { localStorage.setItem('profiles_my_uid_v1', String(myProfile.uid)); } catch(e){}
                try { localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); } catch(e){}
              }
            } catch(e){ console.warn('post-submit save failed', e); }
          }, 120);
        }, false);
      }
    }catch(e){ console.warn(e); }

    // --- Chat + Messages persistence ---
    // messages stored under collection 'messages' -> doc chatId -> subcollection 'msgs'
    let chatListenerUnsub = null;
    function chatDocId(a,b){ return [String(a), String(b)].sort().join('_'); }

    // override sendMessage to write into Firestore messages and notifications
    if(window.sendMessage){
      const originalSend = window.sendMessage;
      window.sendMessage = async function(){
        try {
          const input = document.getElementById("chatInput");
          if (!input) return;
          const text = input.value.trim();
          if (!text || !currentChatUID) return;
          const time = new Date().toISOString();
          const fromUid = myUID ? String(myUID) : ('anon_' + Date.now());
          const toUid = String(currentChatUID);
          const chatId = chatDocId(fromUid, toUid);
          const msgObj = { fromUid: fromUid, toUid: toUid, text: text, time: time, seen: false };
          // add to Firestore
          await db.collection('messages').doc(chatId).collection('msgs').add(msgObj);
          // create notification for recipient
          await db.collection('notifications').doc(toUid).collection('items').add({
            type: 'message',
            fromUid: fromUid,
            text: text,
            time: time,
            seen: false,
            profileName: getProfileNameByUID(fromUid) || ''
          });
          // also call original to preserve UI behavior for same-tab
          try { originalSend(); } catch(e){ console.warn('original send failed', e); }
          input.value = "";
        } catch(e){ console.error('sendMessage persistence failed', e); }
      };
    }

    // listen to chat messages for a pair (displayed in chat UI)
    async function listenToChatWith(otherUid){
      try {
        // unsubscribe previous listener
        if(chatListenerUnsub) { try { chatListenerUnsub(); } catch(e){} chatListenerUnsub = null; }
        const mine = myUID ? String(myUID) : null;
        if(!mine){ console.warn('listenToChatWith: no myUID set; chat will still work but may be anonymous'); }
        const chatId = chatDocId(mine || ('anon_'+Date.now()), otherUid);
        const coll = db.collection('messages').doc(chatId).collection('msgs').orderBy('time');
        chatListenerUnsub = coll.onSnapshot(snapshot => {
          messages[otherUid] = snapshot.docs.map(d => d.data());
          // update message seen flags for messages addressed to me (mark seen)
          snapshot.docs.forEach(async doc => {
            const m = doc.data();
            if(String(m.toUid) === String(myUID) && !m.seen) {
              try { await doc.ref.update({ seen: true }); } catch(e){}
            }
          });
          renderChat();
        }, err => console.error('chat onSnapshot error', err));
      } catch(e){ console.error('listenToChatWith failed', e); }
    }

    // Wrap openChat so that when a chat opens we listen to Firestore updates for it
    if(window.openChat){
      const originalOpenChat = window.openChat;
      window.openChat = function(profile){
        try {
          originalOpenChat(profile);
        } catch(e){ console.warn('original openChat error', e); }
        try { listenToChatWith(String(profile.uid)); } catch(e){ console.warn('listenToChatWith error', e); }
      };
    }

    // --- Notifications persistence & real-time updates for current user ---
    let notificationsUnsub = null;
    function startNotificationsListenerForMe(){
      try {
        if(!myUID) return;
        if(notificationsUnsub) notificationsUnsub();
        const coll = db.collection('notifications').doc(String(myUID)).collection('items').orderBy('time','desc');
        notificationsUnsub = coll.onSnapshot(snapshot => {
          unreadNotifications = [];
          readNotifications = [];
          snapshot.docs.forEach(d => {
            const data = d.data();
            // normalize shape for existing UI use: { uid, name, lastMessage, time }
            const item = {
              id: d.id,
              uid: data.fromUid || data.uid || '',
              name: data.profileName || data.name || getProfileNameByUID(data.fromUid) || '',
              lastMessage: data.text || data.lastMessage || '',
              time: data.time || ''
            };
            if(data.seen) readNotifications.push(item); else unreadNotifications.push(item);
          });
          updateNotificationBadge();
          // re-render current notifications tab if it's open
          if(document.getElementById('notificationsPage') && document.getElementById('notificationsPage').style.display!=='none') {
            switchTab(lastNotificationTab || 'unread');
          }
        }, err => console.error('notifications onSnapshot error', err));
      } catch(e){ console.warn('startNotificationsListenerForMe failed', e); }
    }

    // override markAsReadByUID to also update Firestore 'seen' flag for matching items
    if(window.markAsReadByUID){
      const origMark = window.markAsReadByUID;
      window.markAsReadByUID = async function(uid){
        try {
          // mark matching notifications as seen for current user
          if(myUID) {
            const coll = db.collection('notifications').doc(String(myUID)).collection('items');
            const snap = await coll.where('fromUid','==', String(uid)).where('seen','==', false).get();
            const batch = db.batch();
            snap.docs.forEach(doc => batch.update(doc.ref, { seen: true }));
            try { await batch.commit(); } catch(e){}
          }
        } catch(e){ console.warn('markAsReadByUID firestore update failed', e); }
        try { origMark(uid); } catch(e){ console.warn('orig mark read failed', e); }
      };
    }

    // --- Leaderboard functions ---
    window.loadLeaderboard = async function(){
      try {
        // simple top-by-hireCount leaderboard
        const topHireSnap = await db.collection('profiles').orderBy('hireCount','desc').limit(10).get();
        const hireLeaders = topHireSnap.docs.map(d => d.data());
        // and top-by-ratingAvg
        const topRatingSnap = await db.collection('profiles').orderBy('ratingAvg','desc').limit(10).get();
        const ratingLeaders = topRatingSnap.docs.map(d => d.data());
        // Store on window for UI to pick up if needed
        window.leaderboardHire = hireLeaders;
        window.leaderboardRating = ratingLeaders;
        // If there's a UI element or function to render leaderboard, call it
        if(typeof renderLeaderboard === 'function') renderLeaderboard({hireLeaders, ratingLeaders});
      } catch(e){ console.warn('loadLeaderboard failed', e); }
    };

    // --- Ratings: add a rating document under profiles/{uid}/ratings and recalc aggregate ---
    window.submitProfileRating = async function(profileUid, ratingValue){
      try {
        if(!profileUid || !ratingValue) return;
        const ratingsColl = db.collection('profiles').doc(String(profileUid)).collection('ratings');
        await ratingsColl.add({ value: Number(ratingValue), from: myUID || null, time: new Date().toISOString() });
        // recompute aggregate
        const snap = await ratingsColl.get();
        const vals = snap.docs.map(d => Number(d.data().value)||0).filter(x=>x>0);
        const count = vals.length;
        const avg = count ? (vals.reduce((a,b)=>a+b,0)/count) : 0;
        await db.collection('profiles').doc(String(profileUid)).set({ ratingAvg: avg, ratingCount: count }, {merge:true});
        // refresh profiles snapshot will pull latest values automatically via onSnapshot
      } catch(e){ console.error('submitProfileRating failed', e); }
    };

    // --- Hire Complete flow: increment hireCount on profile and write hire record ---
    window.markHireCompleteServer = async function(toProfileUid, metadata){
      try {
        if(!toProfileUid) return;
        // increment hireCount on profile doc atomically
        await db.collection('profiles').doc(String(toProfileUid)).set({ hireCount: FieldValue.increment(1) }, {merge:true});
        // also persist a hire record under hires collection for analytics
        await db.collection('hires').add({ profileUid: String(toProfileUid), byUid: myUID || null, time: new Date().toISOString(), meta: metadata || {} });
        // refresh leaderboard
        if(window.loadLeaderboard) loadLeaderboard();
      } catch(e){ console.error('markHireCompleteServer failed', e); }
    };

    // Expose helper to other parts of the app
    window._diame_firebase = {
      db, FieldValue, loadProfilesRealtime, loadMyProfileFromFirestore, persistSavedProfilesToServer, loadSavedProfilesForMe, listenToChatWith, startNotificationsListenerForMe, loadLeaderboard
    };

    // --- Initialize on load ---
    setTimeout(()=>{
      try {
        // 1) load profiles in real-time
        loadProfilesRealtime();
        // 2) load myProfile (if present) and saved profiles
        loadMyProfileFromFirestore().then(()=>{
          loadSavedProfilesForMe().then(()=> {
            // start notifications listening for myUID once loaded
            if(myUID) startNotificationsListenerForMe();
          });
        });
        // 3) ensure manage/create button text is correct (fallback)
        try {
          if(myUID) document.getElementById('profileBtn').textContent = 'Manage Profile';
        } catch(e){}
      } catch(e){ console.warn('firebase init (enhanced) failed', e); }
    }, 300);
  } catch(e){ console.error('Firebase enhanced integration failed to initialize', e); }
})();
</script>
<!-- END FULL Firebase integration -->


<!-- Startup fix: ensure myUID/profile state and savedProfiles persist across refreshes -->
<script>
document.addEventListener('DOMContentLoaded', async function(){
  try {
    const btn = document.getElementById('profileBtn');
    // Load stored myUID
    let storedUID = null;
    try { storedUID = localStorage.getItem('profiles_my_uid_v1'); } catch(e){ storedUID = null; }
    if(storedUID && storedUID !== 'null') {
      try { if(btn) btn.textContent = 'Manage Profile'; } catch(e){}
      window.myUID = storedUID;
    }

    // Load cached profiles (fast fallback)
    try {
      const raw = localStorage.getItem('profiles_data_v1');
      if(raw) {
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)) {
          window.profiles = parsed;
          try { displayProfiles(); } catch(e) {}
        }
      }
    } catch(e){}

    // If Firebase enhanced API is available, use its helpers
    if(window._diame_firebase && typeof window._diame_firebase.loadProfilesRealtime === 'function') {
       try {
         window._diame_firebase.loadProfilesRealtime();
       } catch(e){ console.warn('loadProfilesRealtime failed', e); }
       if(storedUID) {
         try {
           await window._diame_firebase.loadMyProfileFromFirestore();
           if(window._diame_firebase.startNotificationsListenerForMe) window._diame_firebase.startNotificationsListenerForMe();
           if(window._diame_firebase.loadSavedProfilesForMe) await window._diame_firebase.loadSavedProfilesForMe();
           if(typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
             try { document.getElementById('profileBtn').textContent = 'Manage Profile'; } catch(e) {}
           }
         } catch(e){ console.warn('loadMyProfileFromFirestore failed', e); }
       }
       // Persist profiles snapshot to localStorage periodically
       setInterval(function(){
         try { localStorage.setItem('profiles_data_v1', JSON.stringify(window.profiles || [])); } catch(e){}
       }, 2000);
    } else {
       // No firebase ready: keep create/manage based on storedUID
       if(storedUID && btn) btn.textContent = 'Manage Profile';
    }

    // Ensure form submit sets myUID and updates UI immediately
    const form = document.getElementById('profileForm');
    if(form) {
       form.addEventListener('submit', function(){
         setTimeout(function(){
           try {
             if(typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
               localStorage.setItem('profiles_my_uid_v1', String(myProfile.uid));
               window.myUID = String(myProfile.uid);
               try { document.getElementById('profileBtn').textContent = 'Manage Profile'; } catch(e){}
               // create or update user doc in Firestore if available
               try {
                 if(window._diame_firebase && window._diame_firebase.db) {
                   window._diame_firebase.db.collection('users').doc(String(myProfile.uid)).set({createdAt: new Date().toISOString()}, {merge:true}).catch(()=>{});
                 }
               } catch(e){}
             }
           } catch(e){}
         }, 120);
       }, false);
    }

    // Override saveProfile to persist savedProfiles to server/localStorage
    if(window.saveProfile) {
      const orig = window.saveProfile;
      window.saveProfile = function(p){
        try { orig(p); } catch(e){ console.warn('orig saveProfile error', e); }
        try {
          if(window._diame_firebase && window._diame_firebase.persistSavedProfilesToServer) {
            window._diame_firebase.persistSavedProfilesToServer();
          } else {
            try { localStorage.setItem('profiles_saved_v1', JSON.stringify(savedProfiles || [])); } catch(e){}
          }
        } catch(e){ console.warn('persist savedProfiles failed', e); }
      };
    }

    // If savedProfiles exist in localStorage (legacy), ensure it's available as array of objects
    try {
      const rawSaved = localStorage.getItem('profiles_saved_v1');
      if(rawSaved) {
        const parsed = JSON.parse(rawSaved);
        if(Array.isArray(parsed)) {
          // If parsed items are just uids, map to profile objects where possible
          if(parsed.length && (typeof parsed[0] === 'string' || typeof parsed[0] === 'number')) {
            const mapped = parsed.map(uid => (profiles.find(p=>String(p.uid)===String(uid)) || {uid: uid}));
            window.savedProfiles = mapped;
          } else {
            window.savedProfiles = parsed;
          }
          try { if(document.getElementById('savedProfilesPage') && document.getElementById('savedProfilesPage').style.display!=='none') displaySaved(); } catch(e){}
        }
      }
    } catch(e){}

  } catch(err){
    console.error('Startup fix error', err);
  }
});
</script>


<!-- Startup strict fix: validate profile existence before setting Manage Profile -->
<script>
document.addEventListener('DOMContentLoaded', async function(){
  try {
    const btn = document.getElementById('profileBtn');
    if(btn) btn.textContent = 'Create a Profile'; // default state

    let storedUID = null;
    try { storedUID = localStorage.getItem('profiles_my_uid_v1'); } catch(e){ storedUID = null; }
    if(storedUID === 'null') storedUID = null;

    // function to safely switch button text
    function setButtonManage() {
      try { if(btn) btn.textContent = 'Manage Profile'; } catch(e){}
    }
    function setButtonCreate() {
      try { if(btn) btn.textContent = 'Create a Profile'; } catch(e){}
    }

    // If we have a storedUID, verify with Firestore
    if(storedUID && window._diame_firebase && window._diame_firebase.db) {
      try {
        const doc = await window._diame_firebase.db.collection('profiles').doc(String(storedUID)).get();
        if(doc.exists) {
          window.myUID = String(storedUID);
          window.myProfile = doc.data();
          setButtonManage();
          // ensure profiles array has myProfile
          if(window.profiles){
            const idx = window.profiles.findIndex(p=>String(p.uid)===String(window.myProfile.uid));
            if(idx>=0) window.profiles[idx] = window.myProfile;
            else window.profiles.push(window.myProfile);
          }
        } else {
          // profile not in Firestore → clear key, show Create
          localStorage.removeItem('profiles_my_uid_v1');
          window.myUID = null;
          window.myProfile = null;
          setButtonCreate();
        }
      } catch(e){
        console.warn('Error verifying profile from Firestore', e);
        setButtonCreate();
      }
    }

    // Real-time profiles always start
    if(window._diame_firebase && window._diame_firebase.loadProfilesRealtime) {
      window._diame_firebase.loadProfilesRealtime();
    }

    // Handle profile form submission
    const form = document.getElementById('profileForm');
    if(form) {
      form.addEventListener('submit', function(){
        setTimeout(async function(){
          try {
            if(typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
              window.myUID = String(myProfile.uid);
              localStorage.setItem('profiles_my_uid_v1', window.myUID);
              setButtonManage();
              // Save to Firestore if possible
              if(window._diame_firebase && window._diame_firebase.db) {
                await window._diame_firebase.db.collection('profiles').doc(window.myUID).set(myProfile, {merge:true});
              }
            }
          } catch(e){ console.warn('post-submit save failed', e); }
        }, 150);
      }, false);
    }

    // Saved profiles load after Firestore profiles snapshot updates
    if(window._diame_firebase && window._diame_firebase.loadSavedProfilesForMe) {
      setTimeout(()=>{ window._diame_firebase.loadSavedProfilesForMe(); }, 1000);
    }

  } catch(err){
    console.error('Startup strict fix error', err);
  }
});
</script>
<!-- END Startup strict fix -->


<!-- Post-submit persistence: ensure profile is saved to Firestore and profiles_my_uid_v1 is set immediately -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
    const form = document.getElementById('profileForm');
    if(!form) return;
    form.addEventListener('submit', function(e){
      // run after other submit handlers
      setTimeout(async function(){
        try {
          if(typeof myProfile === 'undefined' || !myProfile || !myProfile.uid) return;
          const uid = String(myProfile.uid);
          // If firebase available, try save and await confirmation
          if(window._diame_firebase && window._diame_firebase.db) {
            try {
              await window._diame_firebase.db.collection('profiles').doc(uid).set(myProfile, {merge:true});
              await window._diame_firebase.db.collection('users').doc(uid).set({createdAt: new Date().toISOString()}, {merge:true});
            } catch(err){
              console.warn('Firestore save failed (post-submit), continuing with local persistence', err);
            }
          }
          // Persist UID locally so refresh recognizes it
          try { localStorage.setItem('profiles_my_uid_v1', uid); } catch(e){}
          window.myUID = uid;
          // Persist profiles array snapshot as fallback
          try { localStorage.setItem('profiles_data_v1', JSON.stringify(window.profiles || [])); } catch(e){}
          // Persist savedProfiles mapping too
          try { localStorage.setItem('profiles_saved_v1', JSON.stringify(window.savedProfiles || [])); } catch(e){}
          // Update UI
          try { document.getElementById('profileBtn').textContent = 'Manage Profile'; } catch(e){}
        } catch(err){
          console.error('post-submit persistence error', err);
        }
      }, 60);
    }, false);
  } catch(e){ console.error('post-submit script load failed', e); }
});
</script>
<!-- END post-submit persistence -->

</body>
</html>
